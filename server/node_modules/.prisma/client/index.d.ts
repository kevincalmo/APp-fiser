
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model anomaly
 * 
 */
export type anomaly = {
  id: number
  way_id: number | null
  date: Date
  type: string | null
  is_collected: string
  regularization_date: Date | null
  description: string | null
  report_id: number | null
  manual_town: string | null
  manual_way: string | null
  manual_flux: string | null
  manual_truck: string | null
  type_anomaly_id: number | null
}

/**
 * Model circuit
 * 
 */
export type circuit = {
  id: number
  default_outlet_id: number | null
  name: string
}

/**
 * Model collecte
 * 
 */
export type collecte = {
  id: number
  date: Date
  observation: string
  is_valid: boolean
}

/**
 * Model collecte_observation
 * 
 */
export type collecte_observation = {
  id: number
  collecte_id: number | null
  description: string
}

/**
 * Model container_mouvement
 * 
 */
export type container_mouvement = {
  id: number
  worksite_id: number | null
  driver_id: number | null
  truck_id: number | null
  flux_id: number | null
  outlet_id: number | null
  description: string
  tonnage: number
  operation_type_id: number | null
  container_type_id: number | null
  date: Date
}

/**
 * Model container_type
 * 
 */
export type container_type = {
  id: number
  name: string
}

/**
 * Model doctrine_migration_versions
 * 
 */
export type doctrine_migration_versions = {
  version: string
  executed_at: Date | null
  execution_time: number | null
}

/**
 * Model driver
 * 
 */
export type driver = {
  id: number
  last_name: string
  first_name: string
  type: string | null
}

/**
 * Model flux
 * 
 */
export type flux = {
  id: number
  name: string
  circuit_id: number | null
}

/**
 * Model messenger_messages
 * 
 */
export type messenger_messages = {
  id: bigint
  body: string
  headers: string
  queue_name: string
  created_at: Date
  available_at: Date
  delivered_at: Date | null
}

/**
 * Model operation_type
 * 
 */
export type operation_type = {
  id: number
  name: string
}

/**
 * Model outlet
 * 
 */
export type outlet = {
  id: number
  name: string
}

/**
 * Model replacement_team
 * 
 */
export type replacement_team = {
  id: number
  substitute_driver_id: number | null
  substitute_ripper1_id: number | null
  substitute_ripper2_id: number | null
}

/**
 * Model report
 * 
 */
export type report = {
  id: number
  default_outlet_id: number | null
  visited_outlet_id: number | null
  flux_id: number | null
  truck_id: number | null
  date: Date
  manual_circuit: string | null
  total_bac_collected: number
  total_bac_rejected: number
  tonnage: number | null
  tonnage2: number | null
  default_outlet2_id: number | null
  visited_outlet2_id: number | null
  default_outlet3_id: number | null
  visited_outlet3_id: number | null
  default_outlet4_id: number | null
  visited_outlet4_id: number | null
  tonnage3: number | null
  tonnage4: number | null
  circuit_id: number | null
  collecte_id: number | null
  observation: string | null
  geoloc_id: number | null
}

/**
 * Model ripper
 * 
 */
export type ripper = {
  id: number
  last_name: string
  first_name: string
}

/**
 * Model sinister
 * 
 */
export type sinister = {
  id: number
  truck_id: number | null
  driver_id: number | null
  date: Date
  place: string
  opposing_vehicule: string | null
  opposing_driver: string | null
  circumstance: string | null
  status: string
  observation: string | null
}

/**
 * Model tablet
 * 
 */
export type tablet = {
  id: number
  label: string
}

/**
 * Model team
 * 
 */
export type team = {
  id: number
  driver_id: number | null
  flux_id: number | null
  ripper1_id: number | null
  ripper2_id: number | null
  truck_id: number | null
  replacement_team_id: number | null
  name: string
  manual_circuit: string | null
  manual_tablet: string | null
}

/**
 * Model town
 * 
 */
export type town = {
  id: number
  circuit_id: number | null
  name: string
  postal_code: number
}

/**
 * Model truck
 * 
 */
export type truck = {
  id: number
  registration: string
  type: string | null
}

/**
 * Model type_anomaly
 * 
 */
export type type_anomaly = {
  id: number
  name: string
}

/**
 * Model user
 * 
 */
export type user = {
  id: number
  email: string
  roles: Prisma.JsonValue
  password: string
  refresh_token: string
}

/**
 * Model way
 * 
 */
export type way = {
  id: number
  town_id: number | null
  name: string
  type: string | null
}

/**
 * Model worksite
 * 
 */
export type worksite = {
  id: number
  town_id: number | null
  name: string
  adress: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Anomalies
 * const anomalies = await prisma.anomaly.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Anomalies
   * const anomalies = await prisma.anomaly.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.anomaly`: Exposes CRUD operations for the **anomaly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anomalies
    * const anomalies = await prisma.anomaly.findMany()
    * ```
    */
  get anomaly(): Prisma.anomalyDelegate<GlobalReject>;

  /**
   * `prisma.circuit`: Exposes CRUD operations for the **circuit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Circuits
    * const circuits = await prisma.circuit.findMany()
    * ```
    */
  get circuit(): Prisma.circuitDelegate<GlobalReject>;

  /**
   * `prisma.collecte`: Exposes CRUD operations for the **collecte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collectes
    * const collectes = await prisma.collecte.findMany()
    * ```
    */
  get collecte(): Prisma.collecteDelegate<GlobalReject>;

  /**
   * `prisma.collecte_observation`: Exposes CRUD operations for the **collecte_observation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collecte_observations
    * const collecte_observations = await prisma.collecte_observation.findMany()
    * ```
    */
  get collecte_observation(): Prisma.collecte_observationDelegate<GlobalReject>;

  /**
   * `prisma.container_mouvement`: Exposes CRUD operations for the **container_mouvement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Container_mouvements
    * const container_mouvements = await prisma.container_mouvement.findMany()
    * ```
    */
  get container_mouvement(): Prisma.container_mouvementDelegate<GlobalReject>;

  /**
   * `prisma.container_type`: Exposes CRUD operations for the **container_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Container_types
    * const container_types = await prisma.container_type.findMany()
    * ```
    */
  get container_type(): Prisma.container_typeDelegate<GlobalReject>;

  /**
   * `prisma.doctrine_migration_versions`: Exposes CRUD operations for the **doctrine_migration_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctrine_migration_versions
    * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
    * ```
    */
  get doctrine_migration_versions(): Prisma.doctrine_migration_versionsDelegate<GlobalReject>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.driverDelegate<GlobalReject>;

  /**
   * `prisma.flux`: Exposes CRUD operations for the **flux** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fluxes
    * const fluxes = await prisma.flux.findMany()
    * ```
    */
  get flux(): Prisma.fluxDelegate<GlobalReject>;

  /**
   * `prisma.messenger_messages`: Exposes CRUD operations for the **messenger_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messenger_messages
    * const messenger_messages = await prisma.messenger_messages.findMany()
    * ```
    */
  get messenger_messages(): Prisma.messenger_messagesDelegate<GlobalReject>;

  /**
   * `prisma.operation_type`: Exposes CRUD operations for the **operation_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operation_types
    * const operation_types = await prisma.operation_type.findMany()
    * ```
    */
  get operation_type(): Prisma.operation_typeDelegate<GlobalReject>;

  /**
   * `prisma.outlet`: Exposes CRUD operations for the **outlet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outlets
    * const outlets = await prisma.outlet.findMany()
    * ```
    */
  get outlet(): Prisma.outletDelegate<GlobalReject>;

  /**
   * `prisma.replacement_team`: Exposes CRUD operations for the **replacement_team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Replacement_teams
    * const replacement_teams = await prisma.replacement_team.findMany()
    * ```
    */
  get replacement_team(): Prisma.replacement_teamDelegate<GlobalReject>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.reportDelegate<GlobalReject>;

  /**
   * `prisma.ripper`: Exposes CRUD operations for the **ripper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rippers
    * const rippers = await prisma.ripper.findMany()
    * ```
    */
  get ripper(): Prisma.ripperDelegate<GlobalReject>;

  /**
   * `prisma.sinister`: Exposes CRUD operations for the **sinister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sinisters
    * const sinisters = await prisma.sinister.findMany()
    * ```
    */
  get sinister(): Prisma.sinisterDelegate<GlobalReject>;

  /**
   * `prisma.tablet`: Exposes CRUD operations for the **tablet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tablets
    * const tablets = await prisma.tablet.findMany()
    * ```
    */
  get tablet(): Prisma.tabletDelegate<GlobalReject>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<GlobalReject>;

  /**
   * `prisma.town`: Exposes CRUD operations for the **town** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Towns
    * const towns = await prisma.town.findMany()
    * ```
    */
  get town(): Prisma.townDelegate<GlobalReject>;

  /**
   * `prisma.truck`: Exposes CRUD operations for the **truck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.truck.findMany()
    * ```
    */
  get truck(): Prisma.truckDelegate<GlobalReject>;

  /**
   * `prisma.type_anomaly`: Exposes CRUD operations for the **type_anomaly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_anomalies
    * const type_anomalies = await prisma.type_anomaly.findMany()
    * ```
    */
  get type_anomaly(): Prisma.type_anomalyDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;

  /**
   * `prisma.way`: Exposes CRUD operations for the **way** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ways
    * const ways = await prisma.way.findMany()
    * ```
    */
  get way(): Prisma.wayDelegate<GlobalReject>;

  /**
   * `prisma.worksite`: Exposes CRUD operations for the **worksite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Worksites
    * const worksites = await prisma.worksite.findMany()
    * ```
    */
  get worksite(): Prisma.worksiteDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    anomaly: 'anomaly',
    circuit: 'circuit',
    collecte: 'collecte',
    collecte_observation: 'collecte_observation',
    container_mouvement: 'container_mouvement',
    container_type: 'container_type',
    doctrine_migration_versions: 'doctrine_migration_versions',
    driver: 'driver',
    flux: 'flux',
    messenger_messages: 'messenger_messages',
    operation_type: 'operation_type',
    outlet: 'outlet',
    replacement_team: 'replacement_team',
    report: 'report',
    ripper: 'ripper',
    sinister: 'sinister',
    tablet: 'tablet',
    team: 'team',
    town: 'town',
    truck: 'truck',
    type_anomaly: 'type_anomaly',
    user: 'user',
    way: 'way',
    worksite: 'worksite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CircuitCountOutputType
   */


  export type CircuitCountOutputType = {
    flux: number
    report: number
    town: number
  }

  export type CircuitCountOutputTypeSelect = {
    flux?: boolean
    report?: boolean
    town?: boolean
  }

  export type CircuitCountOutputTypeGetPayload<S extends boolean | null | undefined | CircuitCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CircuitCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CircuitCountOutputTypeArgs)
    ? CircuitCountOutputType 
    : S extends { select: any } & (CircuitCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CircuitCountOutputType ? CircuitCountOutputType[P] : never
  } 
      : CircuitCountOutputType




  // Custom InputTypes

  /**
   * CircuitCountOutputType without action
   */
  export type CircuitCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CircuitCountOutputType
     */
    select?: CircuitCountOutputTypeSelect | null
  }



  /**
   * Count Type CollecteCountOutputType
   */


  export type CollecteCountOutputType = {
    collecte_observation: number
    report: number
  }

  export type CollecteCountOutputTypeSelect = {
    collecte_observation?: boolean
    report?: boolean
  }

  export type CollecteCountOutputTypeGetPayload<S extends boolean | null | undefined | CollecteCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CollecteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CollecteCountOutputTypeArgs)
    ? CollecteCountOutputType 
    : S extends { select: any } & (CollecteCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CollecteCountOutputType ? CollecteCountOutputType[P] : never
  } 
      : CollecteCountOutputType




  // Custom InputTypes

  /**
   * CollecteCountOutputType without action
   */
  export type CollecteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CollecteCountOutputType
     */
    select?: CollecteCountOutputTypeSelect | null
  }



  /**
   * Count Type Container_typeCountOutputType
   */


  export type Container_typeCountOutputType = {
    container_mouvement: number
  }

  export type Container_typeCountOutputTypeSelect = {
    container_mouvement?: boolean
  }

  export type Container_typeCountOutputTypeGetPayload<S extends boolean | null | undefined | Container_typeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Container_typeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Container_typeCountOutputTypeArgs)
    ? Container_typeCountOutputType 
    : S extends { select: any } & (Container_typeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Container_typeCountOutputType ? Container_typeCountOutputType[P] : never
  } 
      : Container_typeCountOutputType




  // Custom InputTypes

  /**
   * Container_typeCountOutputType without action
   */
  export type Container_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Container_typeCountOutputType
     */
    select?: Container_typeCountOutputTypeSelect | null
  }



  /**
   * Count Type DriverCountOutputType
   */


  export type DriverCountOutputType = {
    container_mouvement: number
    replacement_team: number
    sinister: number
  }

  export type DriverCountOutputTypeSelect = {
    container_mouvement?: boolean
    replacement_team?: boolean
    sinister?: boolean
  }

  export type DriverCountOutputTypeGetPayload<S extends boolean | null | undefined | DriverCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DriverCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DriverCountOutputTypeArgs)
    ? DriverCountOutputType 
    : S extends { select: any } & (DriverCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DriverCountOutputType ? DriverCountOutputType[P] : never
  } 
      : DriverCountOutputType




  // Custom InputTypes

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect | null
  }



  /**
   * Count Type FluxCountOutputType
   */


  export type FluxCountOutputType = {
    container_mouvement: number
    report: number
    team: number
  }

  export type FluxCountOutputTypeSelect = {
    container_mouvement?: boolean
    report?: boolean
    team?: boolean
  }

  export type FluxCountOutputTypeGetPayload<S extends boolean | null | undefined | FluxCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FluxCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FluxCountOutputTypeArgs)
    ? FluxCountOutputType 
    : S extends { select: any } & (FluxCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FluxCountOutputType ? FluxCountOutputType[P] : never
  } 
      : FluxCountOutputType




  // Custom InputTypes

  /**
   * FluxCountOutputType without action
   */
  export type FluxCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FluxCountOutputType
     */
    select?: FluxCountOutputTypeSelect | null
  }



  /**
   * Count Type Operation_typeCountOutputType
   */


  export type Operation_typeCountOutputType = {
    container_mouvement: number
  }

  export type Operation_typeCountOutputTypeSelect = {
    container_mouvement?: boolean
  }

  export type Operation_typeCountOutputTypeGetPayload<S extends boolean | null | undefined | Operation_typeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Operation_typeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Operation_typeCountOutputTypeArgs)
    ? Operation_typeCountOutputType 
    : S extends { select: any } & (Operation_typeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Operation_typeCountOutputType ? Operation_typeCountOutputType[P] : never
  } 
      : Operation_typeCountOutputType




  // Custom InputTypes

  /**
   * Operation_typeCountOutputType without action
   */
  export type Operation_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Operation_typeCountOutputType
     */
    select?: Operation_typeCountOutputTypeSelect | null
  }



  /**
   * Count Type OutletCountOutputType
   */


  export type OutletCountOutputType = {
    circuit: number
    container_mouvement: number
    report_report_visited_outlet4_idTooutlet: number
    report_report_visited_outlet2_idTooutlet: number
    report_report_default_outlet_idTooutlet: number
    report_report_default_outlet3_idTooutlet: number
    report_report_visited_outlet3_idTooutlet: number
    report_report_visited_outlet_idTooutlet: number
    report_report_default_outlet2_idTooutlet: number
    report_report_default_outlet4_idTooutlet: number
  }

  export type OutletCountOutputTypeSelect = {
    circuit?: boolean
    container_mouvement?: boolean
    report_report_visited_outlet4_idTooutlet?: boolean
    report_report_visited_outlet2_idTooutlet?: boolean
    report_report_default_outlet_idTooutlet?: boolean
    report_report_default_outlet3_idTooutlet?: boolean
    report_report_visited_outlet3_idTooutlet?: boolean
    report_report_visited_outlet_idTooutlet?: boolean
    report_report_default_outlet2_idTooutlet?: boolean
    report_report_default_outlet4_idTooutlet?: boolean
  }

  export type OutletCountOutputTypeGetPayload<S extends boolean | null | undefined | OutletCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OutletCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OutletCountOutputTypeArgs)
    ? OutletCountOutputType 
    : S extends { select: any } & (OutletCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OutletCountOutputType ? OutletCountOutputType[P] : never
  } 
      : OutletCountOutputType




  // Custom InputTypes

  /**
   * OutletCountOutputType without action
   */
  export type OutletCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OutletCountOutputType
     */
    select?: OutletCountOutputTypeSelect | null
  }



  /**
   * Count Type ReportCountOutputType
   */


  export type ReportCountOutputType = {
    anomaly: number
  }

  export type ReportCountOutputTypeSelect = {
    anomaly?: boolean
  }

  export type ReportCountOutputTypeGetPayload<S extends boolean | null | undefined | ReportCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReportCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReportCountOutputTypeArgs)
    ? ReportCountOutputType 
    : S extends { select: any } & (ReportCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReportCountOutputType ? ReportCountOutputType[P] : never
  } 
      : ReportCountOutputType




  // Custom InputTypes

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect | null
  }



  /**
   * Count Type RipperCountOutputType
   */


  export type RipperCountOutputType = {
    replacement_team_replacement_team_substitute_ripper2_idToripper: number
    replacement_team_replacement_team_substitute_ripper1_idToripper: number
  }

  export type RipperCountOutputTypeSelect = {
    replacement_team_replacement_team_substitute_ripper2_idToripper?: boolean
    replacement_team_replacement_team_substitute_ripper1_idToripper?: boolean
  }

  export type RipperCountOutputTypeGetPayload<S extends boolean | null | undefined | RipperCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RipperCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RipperCountOutputTypeArgs)
    ? RipperCountOutputType 
    : S extends { select: any } & (RipperCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RipperCountOutputType ? RipperCountOutputType[P] : never
  } 
      : RipperCountOutputType




  // Custom InputTypes

  /**
   * RipperCountOutputType without action
   */
  export type RipperCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RipperCountOutputType
     */
    select?: RipperCountOutputTypeSelect | null
  }



  /**
   * Count Type TabletCountOutputType
   */


  export type TabletCountOutputType = {
    report: number
  }

  export type TabletCountOutputTypeSelect = {
    report?: boolean
  }

  export type TabletCountOutputTypeGetPayload<S extends boolean | null | undefined | TabletCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TabletCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TabletCountOutputTypeArgs)
    ? TabletCountOutputType 
    : S extends { select: any } & (TabletCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TabletCountOutputType ? TabletCountOutputType[P] : never
  } 
      : TabletCountOutputType




  // Custom InputTypes

  /**
   * TabletCountOutputType without action
   */
  export type TabletCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TabletCountOutputType
     */
    select?: TabletCountOutputTypeSelect | null
  }



  /**
   * Count Type TownCountOutputType
   */


  export type TownCountOutputType = {
    way: number
    worksite: number
  }

  export type TownCountOutputTypeSelect = {
    way?: boolean
    worksite?: boolean
  }

  export type TownCountOutputTypeGetPayload<S extends boolean | null | undefined | TownCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TownCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TownCountOutputTypeArgs)
    ? TownCountOutputType 
    : S extends { select: any } & (TownCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TownCountOutputType ? TownCountOutputType[P] : never
  } 
      : TownCountOutputType




  // Custom InputTypes

  /**
   * TownCountOutputType without action
   */
  export type TownCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TownCountOutputType
     */
    select?: TownCountOutputTypeSelect | null
  }



  /**
   * Count Type TruckCountOutputType
   */


  export type TruckCountOutputType = {
    container_mouvement: number
    report: number
    sinister: number
    team: number
  }

  export type TruckCountOutputTypeSelect = {
    container_mouvement?: boolean
    report?: boolean
    sinister?: boolean
    team?: boolean
  }

  export type TruckCountOutputTypeGetPayload<S extends boolean | null | undefined | TruckCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TruckCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TruckCountOutputTypeArgs)
    ? TruckCountOutputType 
    : S extends { select: any } & (TruckCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TruckCountOutputType ? TruckCountOutputType[P] : never
  } 
      : TruckCountOutputType




  // Custom InputTypes

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TruckCountOutputType
     */
    select?: TruckCountOutputTypeSelect | null
  }



  /**
   * Count Type Type_anomalyCountOutputType
   */


  export type Type_anomalyCountOutputType = {
    anomaly: number
  }

  export type Type_anomalyCountOutputTypeSelect = {
    anomaly?: boolean
  }

  export type Type_anomalyCountOutputTypeGetPayload<S extends boolean | null | undefined | Type_anomalyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Type_anomalyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Type_anomalyCountOutputTypeArgs)
    ? Type_anomalyCountOutputType 
    : S extends { select: any } & (Type_anomalyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Type_anomalyCountOutputType ? Type_anomalyCountOutputType[P] : never
  } 
      : Type_anomalyCountOutputType




  // Custom InputTypes

  /**
   * Type_anomalyCountOutputType without action
   */
  export type Type_anomalyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Type_anomalyCountOutputType
     */
    select?: Type_anomalyCountOutputTypeSelect | null
  }



  /**
   * Count Type WayCountOutputType
   */


  export type WayCountOutputType = {
    anomaly: number
  }

  export type WayCountOutputTypeSelect = {
    anomaly?: boolean
  }

  export type WayCountOutputTypeGetPayload<S extends boolean | null | undefined | WayCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WayCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WayCountOutputTypeArgs)
    ? WayCountOutputType 
    : S extends { select: any } & (WayCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WayCountOutputType ? WayCountOutputType[P] : never
  } 
      : WayCountOutputType




  // Custom InputTypes

  /**
   * WayCountOutputType without action
   */
  export type WayCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WayCountOutputType
     */
    select?: WayCountOutputTypeSelect | null
  }



  /**
   * Count Type WorksiteCountOutputType
   */


  export type WorksiteCountOutputType = {
    container_mouvement: number
  }

  export type WorksiteCountOutputTypeSelect = {
    container_mouvement?: boolean
  }

  export type WorksiteCountOutputTypeGetPayload<S extends boolean | null | undefined | WorksiteCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorksiteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorksiteCountOutputTypeArgs)
    ? WorksiteCountOutputType 
    : S extends { select: any } & (WorksiteCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorksiteCountOutputType ? WorksiteCountOutputType[P] : never
  } 
      : WorksiteCountOutputType




  // Custom InputTypes

  /**
   * WorksiteCountOutputType without action
   */
  export type WorksiteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorksiteCountOutputType
     */
    select?: WorksiteCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model anomaly
   */


  export type AggregateAnomaly = {
    _count: AnomalyCountAggregateOutputType | null
    _avg: AnomalyAvgAggregateOutputType | null
    _sum: AnomalySumAggregateOutputType | null
    _min: AnomalyMinAggregateOutputType | null
    _max: AnomalyMaxAggregateOutputType | null
  }

  export type AnomalyAvgAggregateOutputType = {
    id: number | null
    way_id: number | null
    report_id: number | null
    type_anomaly_id: number | null
  }

  export type AnomalySumAggregateOutputType = {
    id: number | null
    way_id: number | null
    report_id: number | null
    type_anomaly_id: number | null
  }

  export type AnomalyMinAggregateOutputType = {
    id: number | null
    way_id: number | null
    date: Date | null
    type: string | null
    is_collected: string | null
    regularization_date: Date | null
    description: string | null
    report_id: number | null
    manual_town: string | null
    manual_way: string | null
    manual_flux: string | null
    manual_truck: string | null
    type_anomaly_id: number | null
  }

  export type AnomalyMaxAggregateOutputType = {
    id: number | null
    way_id: number | null
    date: Date | null
    type: string | null
    is_collected: string | null
    regularization_date: Date | null
    description: string | null
    report_id: number | null
    manual_town: string | null
    manual_way: string | null
    manual_flux: string | null
    manual_truck: string | null
    type_anomaly_id: number | null
  }

  export type AnomalyCountAggregateOutputType = {
    id: number
    way_id: number
    date: number
    type: number
    is_collected: number
    regularization_date: number
    description: number
    report_id: number
    manual_town: number
    manual_way: number
    manual_flux: number
    manual_truck: number
    type_anomaly_id: number
    _all: number
  }


  export type AnomalyAvgAggregateInputType = {
    id?: true
    way_id?: true
    report_id?: true
    type_anomaly_id?: true
  }

  export type AnomalySumAggregateInputType = {
    id?: true
    way_id?: true
    report_id?: true
    type_anomaly_id?: true
  }

  export type AnomalyMinAggregateInputType = {
    id?: true
    way_id?: true
    date?: true
    type?: true
    is_collected?: true
    regularization_date?: true
    description?: true
    report_id?: true
    manual_town?: true
    manual_way?: true
    manual_flux?: true
    manual_truck?: true
    type_anomaly_id?: true
  }

  export type AnomalyMaxAggregateInputType = {
    id?: true
    way_id?: true
    date?: true
    type?: true
    is_collected?: true
    regularization_date?: true
    description?: true
    report_id?: true
    manual_town?: true
    manual_way?: true
    manual_flux?: true
    manual_truck?: true
    type_anomaly_id?: true
  }

  export type AnomalyCountAggregateInputType = {
    id?: true
    way_id?: true
    date?: true
    type?: true
    is_collected?: true
    regularization_date?: true
    description?: true
    report_id?: true
    manual_town?: true
    manual_way?: true
    manual_flux?: true
    manual_truck?: true
    type_anomaly_id?: true
    _all?: true
  }

  export type AnomalyAggregateArgs = {
    /**
     * Filter which anomaly to aggregate.
     */
    where?: anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anomalies to fetch.
     */
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anomalies
    **/
    _count?: true | AnomalyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnomalyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnomalySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnomalyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnomalyMaxAggregateInputType
  }

  export type GetAnomalyAggregateType<T extends AnomalyAggregateArgs> = {
        [P in keyof T & keyof AggregateAnomaly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnomaly[P]>
      : GetScalarType<T[P], AggregateAnomaly[P]>
  }




  export type AnomalyGroupByArgs = {
    where?: anomalyWhereInput
    orderBy?: Enumerable<anomalyOrderByWithAggregationInput>
    by: AnomalyScalarFieldEnum[]
    having?: anomalyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnomalyCountAggregateInputType | true
    _avg?: AnomalyAvgAggregateInputType
    _sum?: AnomalySumAggregateInputType
    _min?: AnomalyMinAggregateInputType
    _max?: AnomalyMaxAggregateInputType
  }


  export type AnomalyGroupByOutputType = {
    id: number
    way_id: number | null
    date: Date
    type: string | null
    is_collected: string
    regularization_date: Date | null
    description: string | null
    report_id: number | null
    manual_town: string | null
    manual_way: string | null
    manual_flux: string | null
    manual_truck: string | null
    type_anomaly_id: number | null
    _count: AnomalyCountAggregateOutputType | null
    _avg: AnomalyAvgAggregateOutputType | null
    _sum: AnomalySumAggregateOutputType | null
    _min: AnomalyMinAggregateOutputType | null
    _max: AnomalyMaxAggregateOutputType | null
  }

  type GetAnomalyGroupByPayload<T extends AnomalyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AnomalyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnomalyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnomalyGroupByOutputType[P]>
            : GetScalarType<T[P], AnomalyGroupByOutputType[P]>
        }
      >
    >


  export type anomalySelect = {
    id?: boolean
    way_id?: boolean
    date?: boolean
    type?: boolean
    is_collected?: boolean
    regularization_date?: boolean
    description?: boolean
    report_id?: boolean
    manual_town?: boolean
    manual_way?: boolean
    manual_flux?: boolean
    manual_truck?: boolean
    type_anomaly_id?: boolean
    report?: boolean | reportArgs
    way?: boolean | wayArgs
    type_anomaly?: boolean | type_anomalyArgs
  }


  export type anomalyInclude = {
    report?: boolean | reportArgs
    way?: boolean | wayArgs
    type_anomaly?: boolean | type_anomalyArgs
  }

  export type anomalyGetPayload<S extends boolean | null | undefined | anomalyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? anomaly :
    S extends undefined ? never :
    S extends { include: any } & (anomalyArgs | anomalyFindManyArgs)
    ? anomaly  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'report' ? reportGetPayload<S['include'][P]> | null :
        P extends 'way' ? wayGetPayload<S['include'][P]> | null :
        P extends 'type_anomaly' ? type_anomalyGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (anomalyArgs | anomalyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'report' ? reportGetPayload<S['select'][P]> | null :
        P extends 'way' ? wayGetPayload<S['select'][P]> | null :
        P extends 'type_anomaly' ? type_anomalyGetPayload<S['select'][P]> | null :  P extends keyof anomaly ? anomaly[P] : never
  } 
      : anomaly


  type anomalyCountArgs = 
    Omit<anomalyFindManyArgs, 'select' | 'include'> & {
      select?: AnomalyCountAggregateInputType | true
    }

  export interface anomalyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Anomaly that matches the filter.
     * @param {anomalyFindUniqueArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends anomalyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, anomalyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'anomaly'> extends True ? Prisma__anomalyClient<anomalyGetPayload<T>> : Prisma__anomalyClient<anomalyGetPayload<T> | null, null>

    /**
     * Find one Anomaly that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {anomalyFindUniqueOrThrowArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends anomalyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, anomalyFindUniqueOrThrowArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Find the first Anomaly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anomalyFindFirstArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends anomalyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, anomalyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'anomaly'> extends True ? Prisma__anomalyClient<anomalyGetPayload<T>> : Prisma__anomalyClient<anomalyGetPayload<T> | null, null>

    /**
     * Find the first Anomaly that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anomalyFindFirstOrThrowArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends anomalyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, anomalyFindFirstOrThrowArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Find zero or more Anomalies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anomalyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anomalies
     * const anomalies = await prisma.anomaly.findMany()
     * 
     * // Get first 10 Anomalies
     * const anomalies = await prisma.anomaly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anomalyWithIdOnly = await prisma.anomaly.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends anomalyFindManyArgs>(
      args?: SelectSubset<T, anomalyFindManyArgs>
    ): Prisma.PrismaPromise<Array<anomalyGetPayload<T>>>

    /**
     * Create a Anomaly.
     * @param {anomalyCreateArgs} args - Arguments to create a Anomaly.
     * @example
     * // Create one Anomaly
     * const Anomaly = await prisma.anomaly.create({
     *   data: {
     *     // ... data to create a Anomaly
     *   }
     * })
     * 
    **/
    create<T extends anomalyCreateArgs>(
      args: SelectSubset<T, anomalyCreateArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Create many Anomalies.
     *     @param {anomalyCreateManyArgs} args - Arguments to create many Anomalies.
     *     @example
     *     // Create many Anomalies
     *     const anomaly = await prisma.anomaly.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends anomalyCreateManyArgs>(
      args?: SelectSubset<T, anomalyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anomaly.
     * @param {anomalyDeleteArgs} args - Arguments to delete one Anomaly.
     * @example
     * // Delete one Anomaly
     * const Anomaly = await prisma.anomaly.delete({
     *   where: {
     *     // ... filter to delete one Anomaly
     *   }
     * })
     * 
    **/
    delete<T extends anomalyDeleteArgs>(
      args: SelectSubset<T, anomalyDeleteArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Update one Anomaly.
     * @param {anomalyUpdateArgs} args - Arguments to update one Anomaly.
     * @example
     * // Update one Anomaly
     * const anomaly = await prisma.anomaly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends anomalyUpdateArgs>(
      args: SelectSubset<T, anomalyUpdateArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Delete zero or more Anomalies.
     * @param {anomalyDeleteManyArgs} args - Arguments to filter Anomalies to delete.
     * @example
     * // Delete a few Anomalies
     * const { count } = await prisma.anomaly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends anomalyDeleteManyArgs>(
      args?: SelectSubset<T, anomalyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anomalyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anomalies
     * const anomaly = await prisma.anomaly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends anomalyUpdateManyArgs>(
      args: SelectSubset<T, anomalyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anomaly.
     * @param {anomalyUpsertArgs} args - Arguments to update or create a Anomaly.
     * @example
     * // Update or create a Anomaly
     * const anomaly = await prisma.anomaly.upsert({
     *   create: {
     *     // ... data to create a Anomaly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anomaly we want to update
     *   }
     * })
    **/
    upsert<T extends anomalyUpsertArgs>(
      args: SelectSubset<T, anomalyUpsertArgs>
    ): Prisma__anomalyClient<anomalyGetPayload<T>>

    /**
     * Count the number of Anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anomalyCountArgs} args - Arguments to filter Anomalies to count.
     * @example
     * // Count the number of Anomalies
     * const count = await prisma.anomaly.count({
     *   where: {
     *     // ... the filter for the Anomalies we want to count
     *   }
     * })
    **/
    count<T extends anomalyCountArgs>(
      args?: Subset<T, anomalyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnomalyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnomalyAggregateArgs>(args: Subset<T, AnomalyAggregateArgs>): Prisma.PrismaPromise<GetAnomalyAggregateType<T>>

    /**
     * Group by Anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnomalyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnomalyGroupByArgs['orderBy'] }
        : { orderBy?: AnomalyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnomalyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnomalyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for anomaly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__anomalyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    report<T extends reportArgs= {}>(args?: Subset<T, reportArgs>): Prisma__reportClient<reportGetPayload<T> | Null>;

    way<T extends wayArgs= {}>(args?: Subset<T, wayArgs>): Prisma__wayClient<wayGetPayload<T> | Null>;

    type_anomaly<T extends type_anomalyArgs= {}>(args?: Subset<T, type_anomalyArgs>): Prisma__type_anomalyClient<type_anomalyGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * anomaly base type for findUnique actions
   */
  export type anomalyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter, which anomaly to fetch.
     */
    where: anomalyWhereUniqueInput
  }

  /**
   * anomaly findUnique
   */
  export interface anomalyFindUniqueArgs extends anomalyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * anomaly findUniqueOrThrow
   */
  export type anomalyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter, which anomaly to fetch.
     */
    where: anomalyWhereUniqueInput
  }


  /**
   * anomaly base type for findFirst actions
   */
  export type anomalyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter, which anomaly to fetch.
     */
    where?: anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anomalies to fetch.
     */
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anomalies.
     */
    cursor?: anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anomalies.
     */
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }

  /**
   * anomaly findFirst
   */
  export interface anomalyFindFirstArgs extends anomalyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * anomaly findFirstOrThrow
   */
  export type anomalyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter, which anomaly to fetch.
     */
    where?: anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anomalies to fetch.
     */
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anomalies.
     */
    cursor?: anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anomalies.
     */
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }


  /**
   * anomaly findMany
   */
  export type anomalyFindManyArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter, which anomalies to fetch.
     */
    where?: anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anomalies to fetch.
     */
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anomalies.
     */
    cursor?: anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anomalies.
     */
    skip?: number
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }


  /**
   * anomaly create
   */
  export type anomalyCreateArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * The data needed to create a anomaly.
     */
    data: XOR<anomalyCreateInput, anomalyUncheckedCreateInput>
  }


  /**
   * anomaly createMany
   */
  export type anomalyCreateManyArgs = {
    /**
     * The data used to create many anomalies.
     */
    data: Enumerable<anomalyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * anomaly update
   */
  export type anomalyUpdateArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * The data needed to update a anomaly.
     */
    data: XOR<anomalyUpdateInput, anomalyUncheckedUpdateInput>
    /**
     * Choose, which anomaly to update.
     */
    where: anomalyWhereUniqueInput
  }


  /**
   * anomaly updateMany
   */
  export type anomalyUpdateManyArgs = {
    /**
     * The data used to update anomalies.
     */
    data: XOR<anomalyUpdateManyMutationInput, anomalyUncheckedUpdateManyInput>
    /**
     * Filter which anomalies to update
     */
    where?: anomalyWhereInput
  }


  /**
   * anomaly upsert
   */
  export type anomalyUpsertArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * The filter to search for the anomaly to update in case it exists.
     */
    where: anomalyWhereUniqueInput
    /**
     * In case the anomaly found by the `where` argument doesn't exist, create a new anomaly with this data.
     */
    create: XOR<anomalyCreateInput, anomalyUncheckedCreateInput>
    /**
     * In case the anomaly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anomalyUpdateInput, anomalyUncheckedUpdateInput>
  }


  /**
   * anomaly delete
   */
  export type anomalyDeleteArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    /**
     * Filter which anomaly to delete.
     */
    where: anomalyWhereUniqueInput
  }


  /**
   * anomaly deleteMany
   */
  export type anomalyDeleteManyArgs = {
    /**
     * Filter which anomalies to delete
     */
    where?: anomalyWhereInput
  }


  /**
   * anomaly without action
   */
  export type anomalyArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
  }



  /**
   * Model circuit
   */


  export type AggregateCircuit = {
    _count: CircuitCountAggregateOutputType | null
    _avg: CircuitAvgAggregateOutputType | null
    _sum: CircuitSumAggregateOutputType | null
    _min: CircuitMinAggregateOutputType | null
    _max: CircuitMaxAggregateOutputType | null
  }

  export type CircuitAvgAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
  }

  export type CircuitSumAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
  }

  export type CircuitMinAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    name: string | null
  }

  export type CircuitMaxAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    name: string | null
  }

  export type CircuitCountAggregateOutputType = {
    id: number
    default_outlet_id: number
    name: number
    _all: number
  }


  export type CircuitAvgAggregateInputType = {
    id?: true
    default_outlet_id?: true
  }

  export type CircuitSumAggregateInputType = {
    id?: true
    default_outlet_id?: true
  }

  export type CircuitMinAggregateInputType = {
    id?: true
    default_outlet_id?: true
    name?: true
  }

  export type CircuitMaxAggregateInputType = {
    id?: true
    default_outlet_id?: true
    name?: true
  }

  export type CircuitCountAggregateInputType = {
    id?: true
    default_outlet_id?: true
    name?: true
    _all?: true
  }

  export type CircuitAggregateArgs = {
    /**
     * Filter which circuit to aggregate.
     */
    where?: circuitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of circuits to fetch.
     */
    orderBy?: Enumerable<circuitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: circuitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` circuits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` circuits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned circuits
    **/
    _count?: true | CircuitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircuitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircuitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircuitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircuitMaxAggregateInputType
  }

  export type GetCircuitAggregateType<T extends CircuitAggregateArgs> = {
        [P in keyof T & keyof AggregateCircuit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircuit[P]>
      : GetScalarType<T[P], AggregateCircuit[P]>
  }




  export type CircuitGroupByArgs = {
    where?: circuitWhereInput
    orderBy?: Enumerable<circuitOrderByWithAggregationInput>
    by: CircuitScalarFieldEnum[]
    having?: circuitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircuitCountAggregateInputType | true
    _avg?: CircuitAvgAggregateInputType
    _sum?: CircuitSumAggregateInputType
    _min?: CircuitMinAggregateInputType
    _max?: CircuitMaxAggregateInputType
  }


  export type CircuitGroupByOutputType = {
    id: number
    default_outlet_id: number | null
    name: string
    _count: CircuitCountAggregateOutputType | null
    _avg: CircuitAvgAggregateOutputType | null
    _sum: CircuitSumAggregateOutputType | null
    _min: CircuitMinAggregateOutputType | null
    _max: CircuitMaxAggregateOutputType | null
  }

  type GetCircuitGroupByPayload<T extends CircuitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CircuitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircuitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircuitGroupByOutputType[P]>
            : GetScalarType<T[P], CircuitGroupByOutputType[P]>
        }
      >
    >


  export type circuitSelect = {
    id?: boolean
    default_outlet_id?: boolean
    name?: boolean
    outlet?: boolean | outletArgs
    flux?: boolean | circuit$fluxArgs
    report?: boolean | circuit$reportArgs
    town?: boolean | circuit$townArgs
    _count?: boolean | CircuitCountOutputTypeArgs
  }


  export type circuitInclude = {
    outlet?: boolean | outletArgs
    flux?: boolean | circuit$fluxArgs
    report?: boolean | circuit$reportArgs
    town?: boolean | circuit$townArgs
    _count?: boolean | CircuitCountOutputTypeArgs
  }

  export type circuitGetPayload<S extends boolean | null | undefined | circuitArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? circuit :
    S extends undefined ? never :
    S extends { include: any } & (circuitArgs | circuitFindManyArgs)
    ? circuit  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'outlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'flux' ? Array < fluxGetPayload<S['include'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'town' ? Array < townGetPayload<S['include'][P]>>  :
        P extends '_count' ? CircuitCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (circuitArgs | circuitFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'outlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'flux' ? Array < fluxGetPayload<S['select'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'town' ? Array < townGetPayload<S['select'][P]>>  :
        P extends '_count' ? CircuitCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof circuit ? circuit[P] : never
  } 
      : circuit


  type circuitCountArgs = 
    Omit<circuitFindManyArgs, 'select' | 'include'> & {
      select?: CircuitCountAggregateInputType | true
    }

  export interface circuitDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Circuit that matches the filter.
     * @param {circuitFindUniqueArgs} args - Arguments to find a Circuit
     * @example
     * // Get one Circuit
     * const circuit = await prisma.circuit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends circuitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, circuitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'circuit'> extends True ? Prisma__circuitClient<circuitGetPayload<T>> : Prisma__circuitClient<circuitGetPayload<T> | null, null>

    /**
     * Find one Circuit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {circuitFindUniqueOrThrowArgs} args - Arguments to find a Circuit
     * @example
     * // Get one Circuit
     * const circuit = await prisma.circuit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends circuitFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, circuitFindUniqueOrThrowArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Find the first Circuit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {circuitFindFirstArgs} args - Arguments to find a Circuit
     * @example
     * // Get one Circuit
     * const circuit = await prisma.circuit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends circuitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, circuitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'circuit'> extends True ? Prisma__circuitClient<circuitGetPayload<T>> : Prisma__circuitClient<circuitGetPayload<T> | null, null>

    /**
     * Find the first Circuit that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {circuitFindFirstOrThrowArgs} args - Arguments to find a Circuit
     * @example
     * // Get one Circuit
     * const circuit = await prisma.circuit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends circuitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, circuitFindFirstOrThrowArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Find zero or more Circuits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {circuitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Circuits
     * const circuits = await prisma.circuit.findMany()
     * 
     * // Get first 10 Circuits
     * const circuits = await prisma.circuit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circuitWithIdOnly = await prisma.circuit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends circuitFindManyArgs>(
      args?: SelectSubset<T, circuitFindManyArgs>
    ): Prisma.PrismaPromise<Array<circuitGetPayload<T>>>

    /**
     * Create a Circuit.
     * @param {circuitCreateArgs} args - Arguments to create a Circuit.
     * @example
     * // Create one Circuit
     * const Circuit = await prisma.circuit.create({
     *   data: {
     *     // ... data to create a Circuit
     *   }
     * })
     * 
    **/
    create<T extends circuitCreateArgs>(
      args: SelectSubset<T, circuitCreateArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Create many Circuits.
     *     @param {circuitCreateManyArgs} args - Arguments to create many Circuits.
     *     @example
     *     // Create many Circuits
     *     const circuit = await prisma.circuit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends circuitCreateManyArgs>(
      args?: SelectSubset<T, circuitCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Circuit.
     * @param {circuitDeleteArgs} args - Arguments to delete one Circuit.
     * @example
     * // Delete one Circuit
     * const Circuit = await prisma.circuit.delete({
     *   where: {
     *     // ... filter to delete one Circuit
     *   }
     * })
     * 
    **/
    delete<T extends circuitDeleteArgs>(
      args: SelectSubset<T, circuitDeleteArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Update one Circuit.
     * @param {circuitUpdateArgs} args - Arguments to update one Circuit.
     * @example
     * // Update one Circuit
     * const circuit = await prisma.circuit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends circuitUpdateArgs>(
      args: SelectSubset<T, circuitUpdateArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Delete zero or more Circuits.
     * @param {circuitDeleteManyArgs} args - Arguments to filter Circuits to delete.
     * @example
     * // Delete a few Circuits
     * const { count } = await prisma.circuit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends circuitDeleteManyArgs>(
      args?: SelectSubset<T, circuitDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circuits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {circuitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Circuits
     * const circuit = await prisma.circuit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends circuitUpdateManyArgs>(
      args: SelectSubset<T, circuitUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Circuit.
     * @param {circuitUpsertArgs} args - Arguments to update or create a Circuit.
     * @example
     * // Update or create a Circuit
     * const circuit = await prisma.circuit.upsert({
     *   create: {
     *     // ... data to create a Circuit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Circuit we want to update
     *   }
     * })
    **/
    upsert<T extends circuitUpsertArgs>(
      args: SelectSubset<T, circuitUpsertArgs>
    ): Prisma__circuitClient<circuitGetPayload<T>>

    /**
     * Count the number of Circuits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {circuitCountArgs} args - Arguments to filter Circuits to count.
     * @example
     * // Count the number of Circuits
     * const count = await prisma.circuit.count({
     *   where: {
     *     // ... the filter for the Circuits we want to count
     *   }
     * })
    **/
    count<T extends circuitCountArgs>(
      args?: Subset<T, circuitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircuitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Circuit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircuitAggregateArgs>(args: Subset<T, CircuitAggregateArgs>): Prisma.PrismaPromise<GetCircuitAggregateType<T>>

    /**
     * Group by Circuit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircuitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircuitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircuitGroupByArgs['orderBy'] }
        : { orderBy?: CircuitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircuitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircuitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for circuit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__circuitClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    outlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    flux<T extends circuit$fluxArgs= {}>(args?: Subset<T, circuit$fluxArgs>): Prisma.PrismaPromise<Array<fluxGetPayload<T>>| Null>;

    report<T extends circuit$reportArgs= {}>(args?: Subset<T, circuit$reportArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    town<T extends circuit$townArgs= {}>(args?: Subset<T, circuit$townArgs>): Prisma.PrismaPromise<Array<townGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * circuit base type for findUnique actions
   */
  export type circuitFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter, which circuit to fetch.
     */
    where: circuitWhereUniqueInput
  }

  /**
   * circuit findUnique
   */
  export interface circuitFindUniqueArgs extends circuitFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * circuit findUniqueOrThrow
   */
  export type circuitFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter, which circuit to fetch.
     */
    where: circuitWhereUniqueInput
  }


  /**
   * circuit base type for findFirst actions
   */
  export type circuitFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter, which circuit to fetch.
     */
    where?: circuitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of circuits to fetch.
     */
    orderBy?: Enumerable<circuitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for circuits.
     */
    cursor?: circuitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` circuits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` circuits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of circuits.
     */
    distinct?: Enumerable<CircuitScalarFieldEnum>
  }

  /**
   * circuit findFirst
   */
  export interface circuitFindFirstArgs extends circuitFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * circuit findFirstOrThrow
   */
  export type circuitFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter, which circuit to fetch.
     */
    where?: circuitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of circuits to fetch.
     */
    orderBy?: Enumerable<circuitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for circuits.
     */
    cursor?: circuitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` circuits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` circuits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of circuits.
     */
    distinct?: Enumerable<CircuitScalarFieldEnum>
  }


  /**
   * circuit findMany
   */
  export type circuitFindManyArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter, which circuits to fetch.
     */
    where?: circuitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of circuits to fetch.
     */
    orderBy?: Enumerable<circuitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing circuits.
     */
    cursor?: circuitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` circuits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` circuits.
     */
    skip?: number
    distinct?: Enumerable<CircuitScalarFieldEnum>
  }


  /**
   * circuit create
   */
  export type circuitCreateArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * The data needed to create a circuit.
     */
    data: XOR<circuitCreateInput, circuitUncheckedCreateInput>
  }


  /**
   * circuit createMany
   */
  export type circuitCreateManyArgs = {
    /**
     * The data used to create many circuits.
     */
    data: Enumerable<circuitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * circuit update
   */
  export type circuitUpdateArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * The data needed to update a circuit.
     */
    data: XOR<circuitUpdateInput, circuitUncheckedUpdateInput>
    /**
     * Choose, which circuit to update.
     */
    where: circuitWhereUniqueInput
  }


  /**
   * circuit updateMany
   */
  export type circuitUpdateManyArgs = {
    /**
     * The data used to update circuits.
     */
    data: XOR<circuitUpdateManyMutationInput, circuitUncheckedUpdateManyInput>
    /**
     * Filter which circuits to update
     */
    where?: circuitWhereInput
  }


  /**
   * circuit upsert
   */
  export type circuitUpsertArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * The filter to search for the circuit to update in case it exists.
     */
    where: circuitWhereUniqueInput
    /**
     * In case the circuit found by the `where` argument doesn't exist, create a new circuit with this data.
     */
    create: XOR<circuitCreateInput, circuitUncheckedCreateInput>
    /**
     * In case the circuit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<circuitUpdateInput, circuitUncheckedUpdateInput>
  }


  /**
   * circuit delete
   */
  export type circuitDeleteArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    /**
     * Filter which circuit to delete.
     */
    where: circuitWhereUniqueInput
  }


  /**
   * circuit deleteMany
   */
  export type circuitDeleteManyArgs = {
    /**
     * Filter which circuits to delete
     */
    where?: circuitWhereInput
  }


  /**
   * circuit.flux
   */
  export type circuit$fluxArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    where?: fluxWhereInput
    orderBy?: Enumerable<fluxOrderByWithRelationInput>
    cursor?: fluxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FluxScalarFieldEnum>
  }


  /**
   * circuit.report
   */
  export type circuit$reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * circuit.town
   */
  export type circuit$townArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    where?: townWhereInput
    orderBy?: Enumerable<townOrderByWithRelationInput>
    cursor?: townWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TownScalarFieldEnum>
  }


  /**
   * circuit without action
   */
  export type circuitArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
  }



  /**
   * Model collecte
   */


  export type AggregateCollecte = {
    _count: CollecteCountAggregateOutputType | null
    _avg: CollecteAvgAggregateOutputType | null
    _sum: CollecteSumAggregateOutputType | null
    _min: CollecteMinAggregateOutputType | null
    _max: CollecteMaxAggregateOutputType | null
  }

  export type CollecteAvgAggregateOutputType = {
    id: number | null
  }

  export type CollecteSumAggregateOutputType = {
    id: number | null
  }

  export type CollecteMinAggregateOutputType = {
    id: number | null
    date: Date | null
    observation: string | null
    is_valid: boolean | null
  }

  export type CollecteMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    observation: string | null
    is_valid: boolean | null
  }

  export type CollecteCountAggregateOutputType = {
    id: number
    date: number
    observation: number
    is_valid: number
    _all: number
  }


  export type CollecteAvgAggregateInputType = {
    id?: true
  }

  export type CollecteSumAggregateInputType = {
    id?: true
  }

  export type CollecteMinAggregateInputType = {
    id?: true
    date?: true
    observation?: true
    is_valid?: true
  }

  export type CollecteMaxAggregateInputType = {
    id?: true
    date?: true
    observation?: true
    is_valid?: true
  }

  export type CollecteCountAggregateInputType = {
    id?: true
    date?: true
    observation?: true
    is_valid?: true
    _all?: true
  }

  export type CollecteAggregateArgs = {
    /**
     * Filter which collecte to aggregate.
     */
    where?: collecteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectes to fetch.
     */
    orderBy?: Enumerable<collecteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collecteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collectes
    **/
    _count?: true | CollecteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollecteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollecteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollecteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollecteMaxAggregateInputType
  }

  export type GetCollecteAggregateType<T extends CollecteAggregateArgs> = {
        [P in keyof T & keyof AggregateCollecte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollecte[P]>
      : GetScalarType<T[P], AggregateCollecte[P]>
  }




  export type CollecteGroupByArgs = {
    where?: collecteWhereInput
    orderBy?: Enumerable<collecteOrderByWithAggregationInput>
    by: CollecteScalarFieldEnum[]
    having?: collecteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollecteCountAggregateInputType | true
    _avg?: CollecteAvgAggregateInputType
    _sum?: CollecteSumAggregateInputType
    _min?: CollecteMinAggregateInputType
    _max?: CollecteMaxAggregateInputType
  }


  export type CollecteGroupByOutputType = {
    id: number
    date: Date
    observation: string
    is_valid: boolean
    _count: CollecteCountAggregateOutputType | null
    _avg: CollecteAvgAggregateOutputType | null
    _sum: CollecteSumAggregateOutputType | null
    _min: CollecteMinAggregateOutputType | null
    _max: CollecteMaxAggregateOutputType | null
  }

  type GetCollecteGroupByPayload<T extends CollecteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollecteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollecteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollecteGroupByOutputType[P]>
            : GetScalarType<T[P], CollecteGroupByOutputType[P]>
        }
      >
    >


  export type collecteSelect = {
    id?: boolean
    date?: boolean
    observation?: boolean
    is_valid?: boolean
    collecte_observation?: boolean | collecte$collecte_observationArgs
    report?: boolean | collecte$reportArgs
    _count?: boolean | CollecteCountOutputTypeArgs
  }


  export type collecteInclude = {
    collecte_observation?: boolean | collecte$collecte_observationArgs
    report?: boolean | collecte$reportArgs
    _count?: boolean | CollecteCountOutputTypeArgs
  }

  export type collecteGetPayload<S extends boolean | null | undefined | collecteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? collecte :
    S extends undefined ? never :
    S extends { include: any } & (collecteArgs | collecteFindManyArgs)
    ? collecte  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'collecte_observation' ? Array < collecte_observationGetPayload<S['include'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends '_count' ? CollecteCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (collecteArgs | collecteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'collecte_observation' ? Array < collecte_observationGetPayload<S['select'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends '_count' ? CollecteCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof collecte ? collecte[P] : never
  } 
      : collecte


  type collecteCountArgs = 
    Omit<collecteFindManyArgs, 'select' | 'include'> & {
      select?: CollecteCountAggregateInputType | true
    }

  export interface collecteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Collecte that matches the filter.
     * @param {collecteFindUniqueArgs} args - Arguments to find a Collecte
     * @example
     * // Get one Collecte
     * const collecte = await prisma.collecte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collecteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, collecteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'collecte'> extends True ? Prisma__collecteClient<collecteGetPayload<T>> : Prisma__collecteClient<collecteGetPayload<T> | null, null>

    /**
     * Find one Collecte that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collecteFindUniqueOrThrowArgs} args - Arguments to find a Collecte
     * @example
     * // Get one Collecte
     * const collecte = await prisma.collecte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collecteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, collecteFindUniqueOrThrowArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Find the first Collecte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecteFindFirstArgs} args - Arguments to find a Collecte
     * @example
     * // Get one Collecte
     * const collecte = await prisma.collecte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collecteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, collecteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'collecte'> extends True ? Prisma__collecteClient<collecteGetPayload<T>> : Prisma__collecteClient<collecteGetPayload<T> | null, null>

    /**
     * Find the first Collecte that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecteFindFirstOrThrowArgs} args - Arguments to find a Collecte
     * @example
     * // Get one Collecte
     * const collecte = await prisma.collecte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collecteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, collecteFindFirstOrThrowArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Find zero or more Collectes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collectes
     * const collectes = await prisma.collecte.findMany()
     * 
     * // Get first 10 Collectes
     * const collectes = await prisma.collecte.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collecteWithIdOnly = await prisma.collecte.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends collecteFindManyArgs>(
      args?: SelectSubset<T, collecteFindManyArgs>
    ): Prisma.PrismaPromise<Array<collecteGetPayload<T>>>

    /**
     * Create a Collecte.
     * @param {collecteCreateArgs} args - Arguments to create a Collecte.
     * @example
     * // Create one Collecte
     * const Collecte = await prisma.collecte.create({
     *   data: {
     *     // ... data to create a Collecte
     *   }
     * })
     * 
    **/
    create<T extends collecteCreateArgs>(
      args: SelectSubset<T, collecteCreateArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Create many Collectes.
     *     @param {collecteCreateManyArgs} args - Arguments to create many Collectes.
     *     @example
     *     // Create many Collectes
     *     const collecte = await prisma.collecte.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends collecteCreateManyArgs>(
      args?: SelectSubset<T, collecteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collecte.
     * @param {collecteDeleteArgs} args - Arguments to delete one Collecte.
     * @example
     * // Delete one Collecte
     * const Collecte = await prisma.collecte.delete({
     *   where: {
     *     // ... filter to delete one Collecte
     *   }
     * })
     * 
    **/
    delete<T extends collecteDeleteArgs>(
      args: SelectSubset<T, collecteDeleteArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Update one Collecte.
     * @param {collecteUpdateArgs} args - Arguments to update one Collecte.
     * @example
     * // Update one Collecte
     * const collecte = await prisma.collecte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collecteUpdateArgs>(
      args: SelectSubset<T, collecteUpdateArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Delete zero or more Collectes.
     * @param {collecteDeleteManyArgs} args - Arguments to filter Collectes to delete.
     * @example
     * // Delete a few Collectes
     * const { count } = await prisma.collecte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collecteDeleteManyArgs>(
      args?: SelectSubset<T, collecteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collectes
     * const collecte = await prisma.collecte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collecteUpdateManyArgs>(
      args: SelectSubset<T, collecteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collecte.
     * @param {collecteUpsertArgs} args - Arguments to update or create a Collecte.
     * @example
     * // Update or create a Collecte
     * const collecte = await prisma.collecte.upsert({
     *   create: {
     *     // ... data to create a Collecte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collecte we want to update
     *   }
     * })
    **/
    upsert<T extends collecteUpsertArgs>(
      args: SelectSubset<T, collecteUpsertArgs>
    ): Prisma__collecteClient<collecteGetPayload<T>>

    /**
     * Count the number of Collectes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecteCountArgs} args - Arguments to filter Collectes to count.
     * @example
     * // Count the number of Collectes
     * const count = await prisma.collecte.count({
     *   where: {
     *     // ... the filter for the Collectes we want to count
     *   }
     * })
    **/
    count<T extends collecteCountArgs>(
      args?: Subset<T, collecteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollecteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collecte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollecteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollecteAggregateArgs>(args: Subset<T, CollecteAggregateArgs>): Prisma.PrismaPromise<GetCollecteAggregateType<T>>

    /**
     * Group by Collecte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollecteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollecteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollecteGroupByArgs['orderBy'] }
        : { orderBy?: CollecteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollecteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollecteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for collecte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__collecteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collecte_observation<T extends collecte$collecte_observationArgs= {}>(args?: Subset<T, collecte$collecte_observationArgs>): Prisma.PrismaPromise<Array<collecte_observationGetPayload<T>>| Null>;

    report<T extends collecte$reportArgs= {}>(args?: Subset<T, collecte$reportArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * collecte base type for findUnique actions
   */
  export type collecteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter, which collecte to fetch.
     */
    where: collecteWhereUniqueInput
  }

  /**
   * collecte findUnique
   */
  export interface collecteFindUniqueArgs extends collecteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collecte findUniqueOrThrow
   */
  export type collecteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter, which collecte to fetch.
     */
    where: collecteWhereUniqueInput
  }


  /**
   * collecte base type for findFirst actions
   */
  export type collecteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter, which collecte to fetch.
     */
    where?: collecteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectes to fetch.
     */
    orderBy?: Enumerable<collecteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectes.
     */
    cursor?: collecteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectes.
     */
    distinct?: Enumerable<CollecteScalarFieldEnum>
  }

  /**
   * collecte findFirst
   */
  export interface collecteFindFirstArgs extends collecteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collecte findFirstOrThrow
   */
  export type collecteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter, which collecte to fetch.
     */
    where?: collecteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectes to fetch.
     */
    orderBy?: Enumerable<collecteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectes.
     */
    cursor?: collecteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectes.
     */
    distinct?: Enumerable<CollecteScalarFieldEnum>
  }


  /**
   * collecte findMany
   */
  export type collecteFindManyArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter, which collectes to fetch.
     */
    where?: collecteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectes to fetch.
     */
    orderBy?: Enumerable<collecteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collectes.
     */
    cursor?: collecteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectes.
     */
    skip?: number
    distinct?: Enumerable<CollecteScalarFieldEnum>
  }


  /**
   * collecte create
   */
  export type collecteCreateArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * The data needed to create a collecte.
     */
    data: XOR<collecteCreateInput, collecteUncheckedCreateInput>
  }


  /**
   * collecte createMany
   */
  export type collecteCreateManyArgs = {
    /**
     * The data used to create many collectes.
     */
    data: Enumerable<collecteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * collecte update
   */
  export type collecteUpdateArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * The data needed to update a collecte.
     */
    data: XOR<collecteUpdateInput, collecteUncheckedUpdateInput>
    /**
     * Choose, which collecte to update.
     */
    where: collecteWhereUniqueInput
  }


  /**
   * collecte updateMany
   */
  export type collecteUpdateManyArgs = {
    /**
     * The data used to update collectes.
     */
    data: XOR<collecteUpdateManyMutationInput, collecteUncheckedUpdateManyInput>
    /**
     * Filter which collectes to update
     */
    where?: collecteWhereInput
  }


  /**
   * collecte upsert
   */
  export type collecteUpsertArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * The filter to search for the collecte to update in case it exists.
     */
    where: collecteWhereUniqueInput
    /**
     * In case the collecte found by the `where` argument doesn't exist, create a new collecte with this data.
     */
    create: XOR<collecteCreateInput, collecteUncheckedCreateInput>
    /**
     * In case the collecte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collecteUpdateInput, collecteUncheckedUpdateInput>
  }


  /**
   * collecte delete
   */
  export type collecteDeleteArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
    /**
     * Filter which collecte to delete.
     */
    where: collecteWhereUniqueInput
  }


  /**
   * collecte deleteMany
   */
  export type collecteDeleteManyArgs = {
    /**
     * Filter which collectes to delete
     */
    where?: collecteWhereInput
  }


  /**
   * collecte.collecte_observation
   */
  export type collecte$collecte_observationArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    where?: collecte_observationWhereInput
    orderBy?: Enumerable<collecte_observationOrderByWithRelationInput>
    cursor?: collecte_observationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Collecte_observationScalarFieldEnum>
  }


  /**
   * collecte.report
   */
  export type collecte$reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * collecte without action
   */
  export type collecteArgs = {
    /**
     * Select specific fields to fetch from the collecte
     */
    select?: collecteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecteInclude | null
  }



  /**
   * Model collecte_observation
   */


  export type AggregateCollecte_observation = {
    _count: Collecte_observationCountAggregateOutputType | null
    _avg: Collecte_observationAvgAggregateOutputType | null
    _sum: Collecte_observationSumAggregateOutputType | null
    _min: Collecte_observationMinAggregateOutputType | null
    _max: Collecte_observationMaxAggregateOutputType | null
  }

  export type Collecte_observationAvgAggregateOutputType = {
    id: number | null
    collecte_id: number | null
  }

  export type Collecte_observationSumAggregateOutputType = {
    id: number | null
    collecte_id: number | null
  }

  export type Collecte_observationMinAggregateOutputType = {
    id: number | null
    collecte_id: number | null
    description: string | null
  }

  export type Collecte_observationMaxAggregateOutputType = {
    id: number | null
    collecte_id: number | null
    description: string | null
  }

  export type Collecte_observationCountAggregateOutputType = {
    id: number
    collecte_id: number
    description: number
    _all: number
  }


  export type Collecte_observationAvgAggregateInputType = {
    id?: true
    collecte_id?: true
  }

  export type Collecte_observationSumAggregateInputType = {
    id?: true
    collecte_id?: true
  }

  export type Collecte_observationMinAggregateInputType = {
    id?: true
    collecte_id?: true
    description?: true
  }

  export type Collecte_observationMaxAggregateInputType = {
    id?: true
    collecte_id?: true
    description?: true
  }

  export type Collecte_observationCountAggregateInputType = {
    id?: true
    collecte_id?: true
    description?: true
    _all?: true
  }

  export type Collecte_observationAggregateArgs = {
    /**
     * Filter which collecte_observation to aggregate.
     */
    where?: collecte_observationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collecte_observations to fetch.
     */
    orderBy?: Enumerable<collecte_observationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collecte_observationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collecte_observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collecte_observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collecte_observations
    **/
    _count?: true | Collecte_observationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collecte_observationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collecte_observationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collecte_observationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collecte_observationMaxAggregateInputType
  }

  export type GetCollecte_observationAggregateType<T extends Collecte_observationAggregateArgs> = {
        [P in keyof T & keyof AggregateCollecte_observation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollecte_observation[P]>
      : GetScalarType<T[P], AggregateCollecte_observation[P]>
  }




  export type Collecte_observationGroupByArgs = {
    where?: collecte_observationWhereInput
    orderBy?: Enumerable<collecte_observationOrderByWithAggregationInput>
    by: Collecte_observationScalarFieldEnum[]
    having?: collecte_observationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collecte_observationCountAggregateInputType | true
    _avg?: Collecte_observationAvgAggregateInputType
    _sum?: Collecte_observationSumAggregateInputType
    _min?: Collecte_observationMinAggregateInputType
    _max?: Collecte_observationMaxAggregateInputType
  }


  export type Collecte_observationGroupByOutputType = {
    id: number
    collecte_id: number | null
    description: string
    _count: Collecte_observationCountAggregateOutputType | null
    _avg: Collecte_observationAvgAggregateOutputType | null
    _sum: Collecte_observationSumAggregateOutputType | null
    _min: Collecte_observationMinAggregateOutputType | null
    _max: Collecte_observationMaxAggregateOutputType | null
  }

  type GetCollecte_observationGroupByPayload<T extends Collecte_observationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Collecte_observationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collecte_observationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collecte_observationGroupByOutputType[P]>
            : GetScalarType<T[P], Collecte_observationGroupByOutputType[P]>
        }
      >
    >


  export type collecte_observationSelect = {
    id?: boolean
    collecte_id?: boolean
    description?: boolean
    collecte?: boolean | collecteArgs
  }


  export type collecte_observationInclude = {
    collecte?: boolean | collecteArgs
  }

  export type collecte_observationGetPayload<S extends boolean | null | undefined | collecte_observationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? collecte_observation :
    S extends undefined ? never :
    S extends { include: any } & (collecte_observationArgs | collecte_observationFindManyArgs)
    ? collecte_observation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'collecte' ? collecteGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (collecte_observationArgs | collecte_observationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'collecte' ? collecteGetPayload<S['select'][P]> | null :  P extends keyof collecte_observation ? collecte_observation[P] : never
  } 
      : collecte_observation


  type collecte_observationCountArgs = 
    Omit<collecte_observationFindManyArgs, 'select' | 'include'> & {
      select?: Collecte_observationCountAggregateInputType | true
    }

  export interface collecte_observationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Collecte_observation that matches the filter.
     * @param {collecte_observationFindUniqueArgs} args - Arguments to find a Collecte_observation
     * @example
     * // Get one Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collecte_observationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, collecte_observationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'collecte_observation'> extends True ? Prisma__collecte_observationClient<collecte_observationGetPayload<T>> : Prisma__collecte_observationClient<collecte_observationGetPayload<T> | null, null>

    /**
     * Find one Collecte_observation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collecte_observationFindUniqueOrThrowArgs} args - Arguments to find a Collecte_observation
     * @example
     * // Get one Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collecte_observationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, collecte_observationFindUniqueOrThrowArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Find the first Collecte_observation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecte_observationFindFirstArgs} args - Arguments to find a Collecte_observation
     * @example
     * // Get one Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collecte_observationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, collecte_observationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'collecte_observation'> extends True ? Prisma__collecte_observationClient<collecte_observationGetPayload<T>> : Prisma__collecte_observationClient<collecte_observationGetPayload<T> | null, null>

    /**
     * Find the first Collecte_observation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecte_observationFindFirstOrThrowArgs} args - Arguments to find a Collecte_observation
     * @example
     * // Get one Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collecte_observationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, collecte_observationFindFirstOrThrowArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Find zero or more Collecte_observations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecte_observationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collecte_observations
     * const collecte_observations = await prisma.collecte_observation.findMany()
     * 
     * // Get first 10 Collecte_observations
     * const collecte_observations = await prisma.collecte_observation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collecte_observationWithIdOnly = await prisma.collecte_observation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends collecte_observationFindManyArgs>(
      args?: SelectSubset<T, collecte_observationFindManyArgs>
    ): Prisma.PrismaPromise<Array<collecte_observationGetPayload<T>>>

    /**
     * Create a Collecte_observation.
     * @param {collecte_observationCreateArgs} args - Arguments to create a Collecte_observation.
     * @example
     * // Create one Collecte_observation
     * const Collecte_observation = await prisma.collecte_observation.create({
     *   data: {
     *     // ... data to create a Collecte_observation
     *   }
     * })
     * 
    **/
    create<T extends collecte_observationCreateArgs>(
      args: SelectSubset<T, collecte_observationCreateArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Create many Collecte_observations.
     *     @param {collecte_observationCreateManyArgs} args - Arguments to create many Collecte_observations.
     *     @example
     *     // Create many Collecte_observations
     *     const collecte_observation = await prisma.collecte_observation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends collecte_observationCreateManyArgs>(
      args?: SelectSubset<T, collecte_observationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collecte_observation.
     * @param {collecte_observationDeleteArgs} args - Arguments to delete one Collecte_observation.
     * @example
     * // Delete one Collecte_observation
     * const Collecte_observation = await prisma.collecte_observation.delete({
     *   where: {
     *     // ... filter to delete one Collecte_observation
     *   }
     * })
     * 
    **/
    delete<T extends collecte_observationDeleteArgs>(
      args: SelectSubset<T, collecte_observationDeleteArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Update one Collecte_observation.
     * @param {collecte_observationUpdateArgs} args - Arguments to update one Collecte_observation.
     * @example
     * // Update one Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collecte_observationUpdateArgs>(
      args: SelectSubset<T, collecte_observationUpdateArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Delete zero or more Collecte_observations.
     * @param {collecte_observationDeleteManyArgs} args - Arguments to filter Collecte_observations to delete.
     * @example
     * // Delete a few Collecte_observations
     * const { count } = await prisma.collecte_observation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collecte_observationDeleteManyArgs>(
      args?: SelectSubset<T, collecte_observationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collecte_observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecte_observationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collecte_observations
     * const collecte_observation = await prisma.collecte_observation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collecte_observationUpdateManyArgs>(
      args: SelectSubset<T, collecte_observationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collecte_observation.
     * @param {collecte_observationUpsertArgs} args - Arguments to update or create a Collecte_observation.
     * @example
     * // Update or create a Collecte_observation
     * const collecte_observation = await prisma.collecte_observation.upsert({
     *   create: {
     *     // ... data to create a Collecte_observation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collecte_observation we want to update
     *   }
     * })
    **/
    upsert<T extends collecte_observationUpsertArgs>(
      args: SelectSubset<T, collecte_observationUpsertArgs>
    ): Prisma__collecte_observationClient<collecte_observationGetPayload<T>>

    /**
     * Count the number of Collecte_observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collecte_observationCountArgs} args - Arguments to filter Collecte_observations to count.
     * @example
     * // Count the number of Collecte_observations
     * const count = await prisma.collecte_observation.count({
     *   where: {
     *     // ... the filter for the Collecte_observations we want to count
     *   }
     * })
    **/
    count<T extends collecte_observationCountArgs>(
      args?: Subset<T, collecte_observationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collecte_observationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collecte_observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collecte_observationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collecte_observationAggregateArgs>(args: Subset<T, Collecte_observationAggregateArgs>): Prisma.PrismaPromise<GetCollecte_observationAggregateType<T>>

    /**
     * Group by Collecte_observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collecte_observationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Collecte_observationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Collecte_observationGroupByArgs['orderBy'] }
        : { orderBy?: Collecte_observationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Collecte_observationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollecte_observationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for collecte_observation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__collecte_observationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    collecte<T extends collecteArgs= {}>(args?: Subset<T, collecteArgs>): Prisma__collecteClient<collecteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * collecte_observation base type for findUnique actions
   */
  export type collecte_observationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter, which collecte_observation to fetch.
     */
    where: collecte_observationWhereUniqueInput
  }

  /**
   * collecte_observation findUnique
   */
  export interface collecte_observationFindUniqueArgs extends collecte_observationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collecte_observation findUniqueOrThrow
   */
  export type collecte_observationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter, which collecte_observation to fetch.
     */
    where: collecte_observationWhereUniqueInput
  }


  /**
   * collecte_observation base type for findFirst actions
   */
  export type collecte_observationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter, which collecte_observation to fetch.
     */
    where?: collecte_observationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collecte_observations to fetch.
     */
    orderBy?: Enumerable<collecte_observationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collecte_observations.
     */
    cursor?: collecte_observationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collecte_observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collecte_observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collecte_observations.
     */
    distinct?: Enumerable<Collecte_observationScalarFieldEnum>
  }

  /**
   * collecte_observation findFirst
   */
  export interface collecte_observationFindFirstArgs extends collecte_observationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collecte_observation findFirstOrThrow
   */
  export type collecte_observationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter, which collecte_observation to fetch.
     */
    where?: collecte_observationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collecte_observations to fetch.
     */
    orderBy?: Enumerable<collecte_observationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collecte_observations.
     */
    cursor?: collecte_observationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collecte_observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collecte_observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collecte_observations.
     */
    distinct?: Enumerable<Collecte_observationScalarFieldEnum>
  }


  /**
   * collecte_observation findMany
   */
  export type collecte_observationFindManyArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter, which collecte_observations to fetch.
     */
    where?: collecte_observationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collecte_observations to fetch.
     */
    orderBy?: Enumerable<collecte_observationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collecte_observations.
     */
    cursor?: collecte_observationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collecte_observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collecte_observations.
     */
    skip?: number
    distinct?: Enumerable<Collecte_observationScalarFieldEnum>
  }


  /**
   * collecte_observation create
   */
  export type collecte_observationCreateArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * The data needed to create a collecte_observation.
     */
    data: XOR<collecte_observationCreateInput, collecte_observationUncheckedCreateInput>
  }


  /**
   * collecte_observation createMany
   */
  export type collecte_observationCreateManyArgs = {
    /**
     * The data used to create many collecte_observations.
     */
    data: Enumerable<collecte_observationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * collecte_observation update
   */
  export type collecte_observationUpdateArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * The data needed to update a collecte_observation.
     */
    data: XOR<collecte_observationUpdateInput, collecte_observationUncheckedUpdateInput>
    /**
     * Choose, which collecte_observation to update.
     */
    where: collecte_observationWhereUniqueInput
  }


  /**
   * collecte_observation updateMany
   */
  export type collecte_observationUpdateManyArgs = {
    /**
     * The data used to update collecte_observations.
     */
    data: XOR<collecte_observationUpdateManyMutationInput, collecte_observationUncheckedUpdateManyInput>
    /**
     * Filter which collecte_observations to update
     */
    where?: collecte_observationWhereInput
  }


  /**
   * collecte_observation upsert
   */
  export type collecte_observationUpsertArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * The filter to search for the collecte_observation to update in case it exists.
     */
    where: collecte_observationWhereUniqueInput
    /**
     * In case the collecte_observation found by the `where` argument doesn't exist, create a new collecte_observation with this data.
     */
    create: XOR<collecte_observationCreateInput, collecte_observationUncheckedCreateInput>
    /**
     * In case the collecte_observation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collecte_observationUpdateInput, collecte_observationUncheckedUpdateInput>
  }


  /**
   * collecte_observation delete
   */
  export type collecte_observationDeleteArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
    /**
     * Filter which collecte_observation to delete.
     */
    where: collecte_observationWhereUniqueInput
  }


  /**
   * collecte_observation deleteMany
   */
  export type collecte_observationDeleteManyArgs = {
    /**
     * Filter which collecte_observations to delete
     */
    where?: collecte_observationWhereInput
  }


  /**
   * collecte_observation without action
   */
  export type collecte_observationArgs = {
    /**
     * Select specific fields to fetch from the collecte_observation
     */
    select?: collecte_observationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collecte_observationInclude | null
  }



  /**
   * Model container_mouvement
   */


  export type AggregateContainer_mouvement = {
    _count: Container_mouvementCountAggregateOutputType | null
    _avg: Container_mouvementAvgAggregateOutputType | null
    _sum: Container_mouvementSumAggregateOutputType | null
    _min: Container_mouvementMinAggregateOutputType | null
    _max: Container_mouvementMaxAggregateOutputType | null
  }

  export type Container_mouvementAvgAggregateOutputType = {
    id: number | null
    worksite_id: number | null
    driver_id: number | null
    truck_id: number | null
    flux_id: number | null
    outlet_id: number | null
    tonnage: number | null
    operation_type_id: number | null
    container_type_id: number | null
  }

  export type Container_mouvementSumAggregateOutputType = {
    id: number | null
    worksite_id: number | null
    driver_id: number | null
    truck_id: number | null
    flux_id: number | null
    outlet_id: number | null
    tonnage: number | null
    operation_type_id: number | null
    container_type_id: number | null
  }

  export type Container_mouvementMinAggregateOutputType = {
    id: number | null
    worksite_id: number | null
    driver_id: number | null
    truck_id: number | null
    flux_id: number | null
    outlet_id: number | null
    description: string | null
    tonnage: number | null
    operation_type_id: number | null
    container_type_id: number | null
    date: Date | null
  }

  export type Container_mouvementMaxAggregateOutputType = {
    id: number | null
    worksite_id: number | null
    driver_id: number | null
    truck_id: number | null
    flux_id: number | null
    outlet_id: number | null
    description: string | null
    tonnage: number | null
    operation_type_id: number | null
    container_type_id: number | null
    date: Date | null
  }

  export type Container_mouvementCountAggregateOutputType = {
    id: number
    worksite_id: number
    driver_id: number
    truck_id: number
    flux_id: number
    outlet_id: number
    description: number
    tonnage: number
    operation_type_id: number
    container_type_id: number
    date: number
    _all: number
  }


  export type Container_mouvementAvgAggregateInputType = {
    id?: true
    worksite_id?: true
    driver_id?: true
    truck_id?: true
    flux_id?: true
    outlet_id?: true
    tonnage?: true
    operation_type_id?: true
    container_type_id?: true
  }

  export type Container_mouvementSumAggregateInputType = {
    id?: true
    worksite_id?: true
    driver_id?: true
    truck_id?: true
    flux_id?: true
    outlet_id?: true
    tonnage?: true
    operation_type_id?: true
    container_type_id?: true
  }

  export type Container_mouvementMinAggregateInputType = {
    id?: true
    worksite_id?: true
    driver_id?: true
    truck_id?: true
    flux_id?: true
    outlet_id?: true
    description?: true
    tonnage?: true
    operation_type_id?: true
    container_type_id?: true
    date?: true
  }

  export type Container_mouvementMaxAggregateInputType = {
    id?: true
    worksite_id?: true
    driver_id?: true
    truck_id?: true
    flux_id?: true
    outlet_id?: true
    description?: true
    tonnage?: true
    operation_type_id?: true
    container_type_id?: true
    date?: true
  }

  export type Container_mouvementCountAggregateInputType = {
    id?: true
    worksite_id?: true
    driver_id?: true
    truck_id?: true
    flux_id?: true
    outlet_id?: true
    description?: true
    tonnage?: true
    operation_type_id?: true
    container_type_id?: true
    date?: true
    _all?: true
  }

  export type Container_mouvementAggregateArgs = {
    /**
     * Filter which container_mouvement to aggregate.
     */
    where?: container_mouvementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_mouvements to fetch.
     */
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: container_mouvementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_mouvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_mouvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned container_mouvements
    **/
    _count?: true | Container_mouvementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Container_mouvementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Container_mouvementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Container_mouvementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Container_mouvementMaxAggregateInputType
  }

  export type GetContainer_mouvementAggregateType<T extends Container_mouvementAggregateArgs> = {
        [P in keyof T & keyof AggregateContainer_mouvement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainer_mouvement[P]>
      : GetScalarType<T[P], AggregateContainer_mouvement[P]>
  }




  export type Container_mouvementGroupByArgs = {
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithAggregationInput>
    by: Container_mouvementScalarFieldEnum[]
    having?: container_mouvementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Container_mouvementCountAggregateInputType | true
    _avg?: Container_mouvementAvgAggregateInputType
    _sum?: Container_mouvementSumAggregateInputType
    _min?: Container_mouvementMinAggregateInputType
    _max?: Container_mouvementMaxAggregateInputType
  }


  export type Container_mouvementGroupByOutputType = {
    id: number
    worksite_id: number | null
    driver_id: number | null
    truck_id: number | null
    flux_id: number | null
    outlet_id: number | null
    description: string
    tonnage: number
    operation_type_id: number | null
    container_type_id: number | null
    date: Date
    _count: Container_mouvementCountAggregateOutputType | null
    _avg: Container_mouvementAvgAggregateOutputType | null
    _sum: Container_mouvementSumAggregateOutputType | null
    _min: Container_mouvementMinAggregateOutputType | null
    _max: Container_mouvementMaxAggregateOutputType | null
  }

  type GetContainer_mouvementGroupByPayload<T extends Container_mouvementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Container_mouvementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Container_mouvementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Container_mouvementGroupByOutputType[P]>
            : GetScalarType<T[P], Container_mouvementGroupByOutputType[P]>
        }
      >
    >


  export type container_mouvementSelect = {
    id?: boolean
    worksite_id?: boolean
    driver_id?: boolean
    truck_id?: boolean
    flux_id?: boolean
    outlet_id?: boolean
    description?: boolean
    tonnage?: boolean
    operation_type_id?: boolean
    container_type_id?: boolean
    date?: boolean
    container_type?: boolean | container_typeArgs
    operation_type?: boolean | operation_typeArgs
    worksite?: boolean | worksiteArgs
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    outlet?: boolean | outletArgs
  }


  export type container_mouvementInclude = {
    container_type?: boolean | container_typeArgs
    operation_type?: boolean | operation_typeArgs
    worksite?: boolean | worksiteArgs
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    outlet?: boolean | outletArgs
  }

  export type container_mouvementGetPayload<S extends boolean | null | undefined | container_mouvementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? container_mouvement :
    S extends undefined ? never :
    S extends { include: any } & (container_mouvementArgs | container_mouvementFindManyArgs)
    ? container_mouvement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_type' ? container_typeGetPayload<S['include'][P]> | null :
        P extends 'operation_type' ? operation_typeGetPayload<S['include'][P]> | null :
        P extends 'worksite' ? worksiteGetPayload<S['include'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['include'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['include'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['include'][P]> | null :
        P extends 'outlet' ? outletGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (container_mouvementArgs | container_mouvementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_type' ? container_typeGetPayload<S['select'][P]> | null :
        P extends 'operation_type' ? operation_typeGetPayload<S['select'][P]> | null :
        P extends 'worksite' ? worksiteGetPayload<S['select'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['select'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['select'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['select'][P]> | null :
        P extends 'outlet' ? outletGetPayload<S['select'][P]> | null :  P extends keyof container_mouvement ? container_mouvement[P] : never
  } 
      : container_mouvement


  type container_mouvementCountArgs = 
    Omit<container_mouvementFindManyArgs, 'select' | 'include'> & {
      select?: Container_mouvementCountAggregateInputType | true
    }

  export interface container_mouvementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Container_mouvement that matches the filter.
     * @param {container_mouvementFindUniqueArgs} args - Arguments to find a Container_mouvement
     * @example
     * // Get one Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends container_mouvementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, container_mouvementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'container_mouvement'> extends True ? Prisma__container_mouvementClient<container_mouvementGetPayload<T>> : Prisma__container_mouvementClient<container_mouvementGetPayload<T> | null, null>

    /**
     * Find one Container_mouvement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {container_mouvementFindUniqueOrThrowArgs} args - Arguments to find a Container_mouvement
     * @example
     * // Get one Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends container_mouvementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, container_mouvementFindUniqueOrThrowArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Find the first Container_mouvement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_mouvementFindFirstArgs} args - Arguments to find a Container_mouvement
     * @example
     * // Get one Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends container_mouvementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, container_mouvementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'container_mouvement'> extends True ? Prisma__container_mouvementClient<container_mouvementGetPayload<T>> : Prisma__container_mouvementClient<container_mouvementGetPayload<T> | null, null>

    /**
     * Find the first Container_mouvement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_mouvementFindFirstOrThrowArgs} args - Arguments to find a Container_mouvement
     * @example
     * // Get one Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends container_mouvementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, container_mouvementFindFirstOrThrowArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Find zero or more Container_mouvements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_mouvementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Container_mouvements
     * const container_mouvements = await prisma.container_mouvement.findMany()
     * 
     * // Get first 10 Container_mouvements
     * const container_mouvements = await prisma.container_mouvement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const container_mouvementWithIdOnly = await prisma.container_mouvement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends container_mouvementFindManyArgs>(
      args?: SelectSubset<T, container_mouvementFindManyArgs>
    ): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>>

    /**
     * Create a Container_mouvement.
     * @param {container_mouvementCreateArgs} args - Arguments to create a Container_mouvement.
     * @example
     * // Create one Container_mouvement
     * const Container_mouvement = await prisma.container_mouvement.create({
     *   data: {
     *     // ... data to create a Container_mouvement
     *   }
     * })
     * 
    **/
    create<T extends container_mouvementCreateArgs>(
      args: SelectSubset<T, container_mouvementCreateArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Create many Container_mouvements.
     *     @param {container_mouvementCreateManyArgs} args - Arguments to create many Container_mouvements.
     *     @example
     *     // Create many Container_mouvements
     *     const container_mouvement = await prisma.container_mouvement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends container_mouvementCreateManyArgs>(
      args?: SelectSubset<T, container_mouvementCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Container_mouvement.
     * @param {container_mouvementDeleteArgs} args - Arguments to delete one Container_mouvement.
     * @example
     * // Delete one Container_mouvement
     * const Container_mouvement = await prisma.container_mouvement.delete({
     *   where: {
     *     // ... filter to delete one Container_mouvement
     *   }
     * })
     * 
    **/
    delete<T extends container_mouvementDeleteArgs>(
      args: SelectSubset<T, container_mouvementDeleteArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Update one Container_mouvement.
     * @param {container_mouvementUpdateArgs} args - Arguments to update one Container_mouvement.
     * @example
     * // Update one Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends container_mouvementUpdateArgs>(
      args: SelectSubset<T, container_mouvementUpdateArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Delete zero or more Container_mouvements.
     * @param {container_mouvementDeleteManyArgs} args - Arguments to filter Container_mouvements to delete.
     * @example
     * // Delete a few Container_mouvements
     * const { count } = await prisma.container_mouvement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends container_mouvementDeleteManyArgs>(
      args?: SelectSubset<T, container_mouvementDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Container_mouvements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_mouvementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Container_mouvements
     * const container_mouvement = await prisma.container_mouvement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends container_mouvementUpdateManyArgs>(
      args: SelectSubset<T, container_mouvementUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Container_mouvement.
     * @param {container_mouvementUpsertArgs} args - Arguments to update or create a Container_mouvement.
     * @example
     * // Update or create a Container_mouvement
     * const container_mouvement = await prisma.container_mouvement.upsert({
     *   create: {
     *     // ... data to create a Container_mouvement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Container_mouvement we want to update
     *   }
     * })
    **/
    upsert<T extends container_mouvementUpsertArgs>(
      args: SelectSubset<T, container_mouvementUpsertArgs>
    ): Prisma__container_mouvementClient<container_mouvementGetPayload<T>>

    /**
     * Count the number of Container_mouvements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_mouvementCountArgs} args - Arguments to filter Container_mouvements to count.
     * @example
     * // Count the number of Container_mouvements
     * const count = await prisma.container_mouvement.count({
     *   where: {
     *     // ... the filter for the Container_mouvements we want to count
     *   }
     * })
    **/
    count<T extends container_mouvementCountArgs>(
      args?: Subset<T, container_mouvementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Container_mouvementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Container_mouvement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Container_mouvementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Container_mouvementAggregateArgs>(args: Subset<T, Container_mouvementAggregateArgs>): Prisma.PrismaPromise<GetContainer_mouvementAggregateType<T>>

    /**
     * Group by Container_mouvement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Container_mouvementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Container_mouvementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Container_mouvementGroupByArgs['orderBy'] }
        : { orderBy?: Container_mouvementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Container_mouvementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainer_mouvementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for container_mouvement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__container_mouvementClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_type<T extends container_typeArgs= {}>(args?: Subset<T, container_typeArgs>): Prisma__container_typeClient<container_typeGetPayload<T> | Null>;

    operation_type<T extends operation_typeArgs= {}>(args?: Subset<T, operation_typeArgs>): Prisma__operation_typeClient<operation_typeGetPayload<T> | Null>;

    worksite<T extends worksiteArgs= {}>(args?: Subset<T, worksiteArgs>): Prisma__worksiteClient<worksiteGetPayload<T> | Null>;

    driver<T extends driverArgs= {}>(args?: Subset<T, driverArgs>): Prisma__driverClient<driverGetPayload<T> | Null>;

    truck<T extends truckArgs= {}>(args?: Subset<T, truckArgs>): Prisma__truckClient<truckGetPayload<T> | Null>;

    flux<T extends fluxArgs= {}>(args?: Subset<T, fluxArgs>): Prisma__fluxClient<fluxGetPayload<T> | Null>;

    outlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * container_mouvement base type for findUnique actions
   */
  export type container_mouvementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter, which container_mouvement to fetch.
     */
    where: container_mouvementWhereUniqueInput
  }

  /**
   * container_mouvement findUnique
   */
  export interface container_mouvementFindUniqueArgs extends container_mouvementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * container_mouvement findUniqueOrThrow
   */
  export type container_mouvementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter, which container_mouvement to fetch.
     */
    where: container_mouvementWhereUniqueInput
  }


  /**
   * container_mouvement base type for findFirst actions
   */
  export type container_mouvementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter, which container_mouvement to fetch.
     */
    where?: container_mouvementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_mouvements to fetch.
     */
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for container_mouvements.
     */
    cursor?: container_mouvementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_mouvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_mouvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of container_mouvements.
     */
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }

  /**
   * container_mouvement findFirst
   */
  export interface container_mouvementFindFirstArgs extends container_mouvementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * container_mouvement findFirstOrThrow
   */
  export type container_mouvementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter, which container_mouvement to fetch.
     */
    where?: container_mouvementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_mouvements to fetch.
     */
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for container_mouvements.
     */
    cursor?: container_mouvementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_mouvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_mouvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of container_mouvements.
     */
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * container_mouvement findMany
   */
  export type container_mouvementFindManyArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter, which container_mouvements to fetch.
     */
    where?: container_mouvementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_mouvements to fetch.
     */
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing container_mouvements.
     */
    cursor?: container_mouvementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_mouvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_mouvements.
     */
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * container_mouvement create
   */
  export type container_mouvementCreateArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * The data needed to create a container_mouvement.
     */
    data: XOR<container_mouvementCreateInput, container_mouvementUncheckedCreateInput>
  }


  /**
   * container_mouvement createMany
   */
  export type container_mouvementCreateManyArgs = {
    /**
     * The data used to create many container_mouvements.
     */
    data: Enumerable<container_mouvementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * container_mouvement update
   */
  export type container_mouvementUpdateArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * The data needed to update a container_mouvement.
     */
    data: XOR<container_mouvementUpdateInput, container_mouvementUncheckedUpdateInput>
    /**
     * Choose, which container_mouvement to update.
     */
    where: container_mouvementWhereUniqueInput
  }


  /**
   * container_mouvement updateMany
   */
  export type container_mouvementUpdateManyArgs = {
    /**
     * The data used to update container_mouvements.
     */
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyInput>
    /**
     * Filter which container_mouvements to update
     */
    where?: container_mouvementWhereInput
  }


  /**
   * container_mouvement upsert
   */
  export type container_mouvementUpsertArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * The filter to search for the container_mouvement to update in case it exists.
     */
    where: container_mouvementWhereUniqueInput
    /**
     * In case the container_mouvement found by the `where` argument doesn't exist, create a new container_mouvement with this data.
     */
    create: XOR<container_mouvementCreateInput, container_mouvementUncheckedCreateInput>
    /**
     * In case the container_mouvement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<container_mouvementUpdateInput, container_mouvementUncheckedUpdateInput>
  }


  /**
   * container_mouvement delete
   */
  export type container_mouvementDeleteArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    /**
     * Filter which container_mouvement to delete.
     */
    where: container_mouvementWhereUniqueInput
  }


  /**
   * container_mouvement deleteMany
   */
  export type container_mouvementDeleteManyArgs = {
    /**
     * Filter which container_mouvements to delete
     */
    where?: container_mouvementWhereInput
  }


  /**
   * container_mouvement without action
   */
  export type container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
  }



  /**
   * Model container_type
   */


  export type AggregateContainer_type = {
    _count: Container_typeCountAggregateOutputType | null
    _avg: Container_typeAvgAggregateOutputType | null
    _sum: Container_typeSumAggregateOutputType | null
    _min: Container_typeMinAggregateOutputType | null
    _max: Container_typeMaxAggregateOutputType | null
  }

  export type Container_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Container_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Container_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Container_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Container_typeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Container_typeAvgAggregateInputType = {
    id?: true
  }

  export type Container_typeSumAggregateInputType = {
    id?: true
  }

  export type Container_typeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Container_typeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Container_typeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Container_typeAggregateArgs = {
    /**
     * Filter which container_type to aggregate.
     */
    where?: container_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_types to fetch.
     */
    orderBy?: Enumerable<container_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: container_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned container_types
    **/
    _count?: true | Container_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Container_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Container_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Container_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Container_typeMaxAggregateInputType
  }

  export type GetContainer_typeAggregateType<T extends Container_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateContainer_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContainer_type[P]>
      : GetScalarType<T[P], AggregateContainer_type[P]>
  }




  export type Container_typeGroupByArgs = {
    where?: container_typeWhereInput
    orderBy?: Enumerable<container_typeOrderByWithAggregationInput>
    by: Container_typeScalarFieldEnum[]
    having?: container_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Container_typeCountAggregateInputType | true
    _avg?: Container_typeAvgAggregateInputType
    _sum?: Container_typeSumAggregateInputType
    _min?: Container_typeMinAggregateInputType
    _max?: Container_typeMaxAggregateInputType
  }


  export type Container_typeGroupByOutputType = {
    id: number
    name: string
    _count: Container_typeCountAggregateOutputType | null
    _avg: Container_typeAvgAggregateOutputType | null
    _sum: Container_typeSumAggregateOutputType | null
    _min: Container_typeMinAggregateOutputType | null
    _max: Container_typeMaxAggregateOutputType | null
  }

  type GetContainer_typeGroupByPayload<T extends Container_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Container_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Container_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Container_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Container_typeGroupByOutputType[P]>
        }
      >
    >


  export type container_typeSelect = {
    id?: boolean
    name?: boolean
    container_mouvement?: boolean | container_type$container_mouvementArgs
    _count?: boolean | Container_typeCountOutputTypeArgs
  }


  export type container_typeInclude = {
    container_mouvement?: boolean | container_type$container_mouvementArgs
    _count?: boolean | Container_typeCountOutputTypeArgs
  }

  export type container_typeGetPayload<S extends boolean | null | undefined | container_typeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? container_type :
    S extends undefined ? never :
    S extends { include: any } & (container_typeArgs | container_typeFindManyArgs)
    ? container_type  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends '_count' ? Container_typeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (container_typeArgs | container_typeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends '_count' ? Container_typeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof container_type ? container_type[P] : never
  } 
      : container_type


  type container_typeCountArgs = 
    Omit<container_typeFindManyArgs, 'select' | 'include'> & {
      select?: Container_typeCountAggregateInputType | true
    }

  export interface container_typeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Container_type that matches the filter.
     * @param {container_typeFindUniqueArgs} args - Arguments to find a Container_type
     * @example
     * // Get one Container_type
     * const container_type = await prisma.container_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends container_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, container_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'container_type'> extends True ? Prisma__container_typeClient<container_typeGetPayload<T>> : Prisma__container_typeClient<container_typeGetPayload<T> | null, null>

    /**
     * Find one Container_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {container_typeFindUniqueOrThrowArgs} args - Arguments to find a Container_type
     * @example
     * // Get one Container_type
     * const container_type = await prisma.container_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends container_typeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, container_typeFindUniqueOrThrowArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Find the first Container_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_typeFindFirstArgs} args - Arguments to find a Container_type
     * @example
     * // Get one Container_type
     * const container_type = await prisma.container_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends container_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, container_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'container_type'> extends True ? Prisma__container_typeClient<container_typeGetPayload<T>> : Prisma__container_typeClient<container_typeGetPayload<T> | null, null>

    /**
     * Find the first Container_type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_typeFindFirstOrThrowArgs} args - Arguments to find a Container_type
     * @example
     * // Get one Container_type
     * const container_type = await prisma.container_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends container_typeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, container_typeFindFirstOrThrowArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Find zero or more Container_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Container_types
     * const container_types = await prisma.container_type.findMany()
     * 
     * // Get first 10 Container_types
     * const container_types = await prisma.container_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const container_typeWithIdOnly = await prisma.container_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends container_typeFindManyArgs>(
      args?: SelectSubset<T, container_typeFindManyArgs>
    ): Prisma.PrismaPromise<Array<container_typeGetPayload<T>>>

    /**
     * Create a Container_type.
     * @param {container_typeCreateArgs} args - Arguments to create a Container_type.
     * @example
     * // Create one Container_type
     * const Container_type = await prisma.container_type.create({
     *   data: {
     *     // ... data to create a Container_type
     *   }
     * })
     * 
    **/
    create<T extends container_typeCreateArgs>(
      args: SelectSubset<T, container_typeCreateArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Create many Container_types.
     *     @param {container_typeCreateManyArgs} args - Arguments to create many Container_types.
     *     @example
     *     // Create many Container_types
     *     const container_type = await prisma.container_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends container_typeCreateManyArgs>(
      args?: SelectSubset<T, container_typeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Container_type.
     * @param {container_typeDeleteArgs} args - Arguments to delete one Container_type.
     * @example
     * // Delete one Container_type
     * const Container_type = await prisma.container_type.delete({
     *   where: {
     *     // ... filter to delete one Container_type
     *   }
     * })
     * 
    **/
    delete<T extends container_typeDeleteArgs>(
      args: SelectSubset<T, container_typeDeleteArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Update one Container_type.
     * @param {container_typeUpdateArgs} args - Arguments to update one Container_type.
     * @example
     * // Update one Container_type
     * const container_type = await prisma.container_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends container_typeUpdateArgs>(
      args: SelectSubset<T, container_typeUpdateArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Delete zero or more Container_types.
     * @param {container_typeDeleteManyArgs} args - Arguments to filter Container_types to delete.
     * @example
     * // Delete a few Container_types
     * const { count } = await prisma.container_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends container_typeDeleteManyArgs>(
      args?: SelectSubset<T, container_typeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Container_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Container_types
     * const container_type = await prisma.container_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends container_typeUpdateManyArgs>(
      args: SelectSubset<T, container_typeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Container_type.
     * @param {container_typeUpsertArgs} args - Arguments to update or create a Container_type.
     * @example
     * // Update or create a Container_type
     * const container_type = await prisma.container_type.upsert({
     *   create: {
     *     // ... data to create a Container_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Container_type we want to update
     *   }
     * })
    **/
    upsert<T extends container_typeUpsertArgs>(
      args: SelectSubset<T, container_typeUpsertArgs>
    ): Prisma__container_typeClient<container_typeGetPayload<T>>

    /**
     * Count the number of Container_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {container_typeCountArgs} args - Arguments to filter Container_types to count.
     * @example
     * // Count the number of Container_types
     * const count = await prisma.container_type.count({
     *   where: {
     *     // ... the filter for the Container_types we want to count
     *   }
     * })
    **/
    count<T extends container_typeCountArgs>(
      args?: Subset<T, container_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Container_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Container_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Container_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Container_typeAggregateArgs>(args: Subset<T, Container_typeAggregateArgs>): Prisma.PrismaPromise<GetContainer_typeAggregateType<T>>

    /**
     * Group by Container_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Container_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Container_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Container_typeGroupByArgs['orderBy'] }
        : { orderBy?: Container_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Container_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContainer_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for container_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__container_typeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends container_type$container_mouvementArgs= {}>(args?: Subset<T, container_type$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * container_type base type for findUnique actions
   */
  export type container_typeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter, which container_type to fetch.
     */
    where: container_typeWhereUniqueInput
  }

  /**
   * container_type findUnique
   */
  export interface container_typeFindUniqueArgs extends container_typeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * container_type findUniqueOrThrow
   */
  export type container_typeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter, which container_type to fetch.
     */
    where: container_typeWhereUniqueInput
  }


  /**
   * container_type base type for findFirst actions
   */
  export type container_typeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter, which container_type to fetch.
     */
    where?: container_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_types to fetch.
     */
    orderBy?: Enumerable<container_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for container_types.
     */
    cursor?: container_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of container_types.
     */
    distinct?: Enumerable<Container_typeScalarFieldEnum>
  }

  /**
   * container_type findFirst
   */
  export interface container_typeFindFirstArgs extends container_typeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * container_type findFirstOrThrow
   */
  export type container_typeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter, which container_type to fetch.
     */
    where?: container_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_types to fetch.
     */
    orderBy?: Enumerable<container_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for container_types.
     */
    cursor?: container_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of container_types.
     */
    distinct?: Enumerable<Container_typeScalarFieldEnum>
  }


  /**
   * container_type findMany
   */
  export type container_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter, which container_types to fetch.
     */
    where?: container_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of container_types to fetch.
     */
    orderBy?: Enumerable<container_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing container_types.
     */
    cursor?: container_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` container_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` container_types.
     */
    skip?: number
    distinct?: Enumerable<Container_typeScalarFieldEnum>
  }


  /**
   * container_type create
   */
  export type container_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * The data needed to create a container_type.
     */
    data: XOR<container_typeCreateInput, container_typeUncheckedCreateInput>
  }


  /**
   * container_type createMany
   */
  export type container_typeCreateManyArgs = {
    /**
     * The data used to create many container_types.
     */
    data: Enumerable<container_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * container_type update
   */
  export type container_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * The data needed to update a container_type.
     */
    data: XOR<container_typeUpdateInput, container_typeUncheckedUpdateInput>
    /**
     * Choose, which container_type to update.
     */
    where: container_typeWhereUniqueInput
  }


  /**
   * container_type updateMany
   */
  export type container_typeUpdateManyArgs = {
    /**
     * The data used to update container_types.
     */
    data: XOR<container_typeUpdateManyMutationInput, container_typeUncheckedUpdateManyInput>
    /**
     * Filter which container_types to update
     */
    where?: container_typeWhereInput
  }


  /**
   * container_type upsert
   */
  export type container_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * The filter to search for the container_type to update in case it exists.
     */
    where: container_typeWhereUniqueInput
    /**
     * In case the container_type found by the `where` argument doesn't exist, create a new container_type with this data.
     */
    create: XOR<container_typeCreateInput, container_typeUncheckedCreateInput>
    /**
     * In case the container_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<container_typeUpdateInput, container_typeUncheckedUpdateInput>
  }


  /**
   * container_type delete
   */
  export type container_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
    /**
     * Filter which container_type to delete.
     */
    where: container_typeWhereUniqueInput
  }


  /**
   * container_type deleteMany
   */
  export type container_typeDeleteManyArgs = {
    /**
     * Filter which container_types to delete
     */
    where?: container_typeWhereInput
  }


  /**
   * container_type.container_mouvement
   */
  export type container_type$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * container_type without action
   */
  export type container_typeArgs = {
    /**
     * Select specific fields to fetch from the container_type
     */
    select?: container_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_typeInclude | null
  }



  /**
   * Model doctrine_migration_versions
   */


  export type AggregateDoctrine_migration_versions = {
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  export type Doctrine_migration_versionsAvgAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsSumAggregateOutputType = {
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMinAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsMaxAggregateOutputType = {
    version: string | null
    executed_at: Date | null
    execution_time: number | null
  }

  export type Doctrine_migration_versionsCountAggregateOutputType = {
    version: number
    executed_at: number
    execution_time: number
    _all: number
  }


  export type Doctrine_migration_versionsAvgAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsSumAggregateInputType = {
    execution_time?: true
  }

  export type Doctrine_migration_versionsMinAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsMaxAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
  }

  export type Doctrine_migration_versionsCountAggregateInputType = {
    version?: true
    executed_at?: true
    execution_time?: true
    _all?: true
  }

  export type Doctrine_migration_versionsAggregateArgs = {
    /**
     * Filter which doctrine_migration_versions to aggregate.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: Enumerable<doctrine_migration_versionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned doctrine_migration_versions
    **/
    _count?: true | Doctrine_migration_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Doctrine_migration_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }

  export type GetDoctrine_migration_versionsAggregateType<T extends Doctrine_migration_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctrine_migration_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
      : GetScalarType<T[P], AggregateDoctrine_migration_versions[P]>
  }




  export type Doctrine_migration_versionsGroupByArgs = {
    where?: doctrine_migration_versionsWhereInput
    orderBy?: Enumerable<doctrine_migration_versionsOrderByWithAggregationInput>
    by: Doctrine_migration_versionsScalarFieldEnum[]
    having?: doctrine_migration_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Doctrine_migration_versionsCountAggregateInputType | true
    _avg?: Doctrine_migration_versionsAvgAggregateInputType
    _sum?: Doctrine_migration_versionsSumAggregateInputType
    _min?: Doctrine_migration_versionsMinAggregateInputType
    _max?: Doctrine_migration_versionsMaxAggregateInputType
  }


  export type Doctrine_migration_versionsGroupByOutputType = {
    version: string
    executed_at: Date | null
    execution_time: number | null
    _count: Doctrine_migration_versionsCountAggregateOutputType | null
    _avg: Doctrine_migration_versionsAvgAggregateOutputType | null
    _sum: Doctrine_migration_versionsSumAggregateOutputType | null
    _min: Doctrine_migration_versionsMinAggregateOutputType | null
    _max: Doctrine_migration_versionsMaxAggregateOutputType | null
  }

  type GetDoctrine_migration_versionsGroupByPayload<T extends Doctrine_migration_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Doctrine_migration_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Doctrine_migration_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Doctrine_migration_versionsGroupByOutputType[P]>
        }
      >
    >


  export type doctrine_migration_versionsSelect = {
    version?: boolean
    executed_at?: boolean
    execution_time?: boolean
  }


  export type doctrine_migration_versionsGetPayload<S extends boolean | null | undefined | doctrine_migration_versionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? doctrine_migration_versions :
    S extends undefined ? never :
    S extends { include: any } & (doctrine_migration_versionsArgs | doctrine_migration_versionsFindManyArgs)
    ? doctrine_migration_versions 
    : S extends { select: any } & (doctrine_migration_versionsArgs | doctrine_migration_versionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof doctrine_migration_versions ? doctrine_migration_versions[P] : never
  } 
      : doctrine_migration_versions


  type doctrine_migration_versionsCountArgs = 
    Omit<doctrine_migration_versionsFindManyArgs, 'select' | 'include'> & {
      select?: Doctrine_migration_versionsCountAggregateInputType | true
    }

  export interface doctrine_migration_versionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Doctrine_migration_versions that matches the filter.
     * @param {doctrine_migration_versionsFindUniqueArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends doctrine_migration_versionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, doctrine_migration_versionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'doctrine_migration_versions'> extends True ? Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>> : Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T> | null, null>

    /**
     * Find one Doctrine_migration_versions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {doctrine_migration_versionsFindUniqueOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends doctrine_migration_versionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, doctrine_migration_versionsFindUniqueOrThrowArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Find the first Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends doctrine_migration_versionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'doctrine_migration_versions'> extends True ? Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>> : Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T> | null, null>

    /**
     * Find the first Doctrine_migration_versions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindFirstOrThrowArgs} args - Arguments to find a Doctrine_migration_versions
     * @example
     * // Get one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends doctrine_migration_versionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, doctrine_migration_versionsFindFirstOrThrowArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Find zero or more Doctrine_migration_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany()
     * 
     * // Get first 10 Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const doctrine_migration_versionsWithVersionOnly = await prisma.doctrine_migration_versions.findMany({ select: { version: true } })
     * 
    **/
    findMany<T extends doctrine_migration_versionsFindManyArgs>(
      args?: SelectSubset<T, doctrine_migration_versionsFindManyArgs>
    ): Prisma.PrismaPromise<Array<doctrine_migration_versionsGetPayload<T>>>

    /**
     * Create a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsCreateArgs} args - Arguments to create a Doctrine_migration_versions.
     * @example
     * // Create one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.create({
     *   data: {
     *     // ... data to create a Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    create<T extends doctrine_migration_versionsCreateArgs>(
      args: SelectSubset<T, doctrine_migration_versionsCreateArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Create many Doctrine_migration_versions.
     *     @param {doctrine_migration_versionsCreateManyArgs} args - Arguments to create many Doctrine_migration_versions.
     *     @example
     *     // Create many Doctrine_migration_versions
     *     const doctrine_migration_versions = await prisma.doctrine_migration_versions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends doctrine_migration_versionsCreateManyArgs>(
      args?: SelectSubset<T, doctrine_migration_versionsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteArgs} args - Arguments to delete one Doctrine_migration_versions.
     * @example
     * // Delete one Doctrine_migration_versions
     * const Doctrine_migration_versions = await prisma.doctrine_migration_versions.delete({
     *   where: {
     *     // ... filter to delete one Doctrine_migration_versions
     *   }
     * })
     * 
    **/
    delete<T extends doctrine_migration_versionsDeleteArgs>(
      args: SelectSubset<T, doctrine_migration_versionsDeleteArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpdateArgs} args - Arguments to update one Doctrine_migration_versions.
     * @example
     * // Update one Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends doctrine_migration_versionsUpdateArgs>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Delete zero or more Doctrine_migration_versions.
     * @param {doctrine_migration_versionsDeleteManyArgs} args - Arguments to filter Doctrine_migration_versions to delete.
     * @example
     * // Delete a few Doctrine_migration_versions
     * const { count } = await prisma.doctrine_migration_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends doctrine_migration_versionsDeleteManyArgs>(
      args?: SelectSubset<T, doctrine_migration_versionsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends doctrine_migration_versionsUpdateManyArgs>(
      args: SelectSubset<T, doctrine_migration_versionsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctrine_migration_versions.
     * @param {doctrine_migration_versionsUpsertArgs} args - Arguments to update or create a Doctrine_migration_versions.
     * @example
     * // Update or create a Doctrine_migration_versions
     * const doctrine_migration_versions = await prisma.doctrine_migration_versions.upsert({
     *   create: {
     *     // ... data to create a Doctrine_migration_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to update
     *   }
     * })
    **/
    upsert<T extends doctrine_migration_versionsUpsertArgs>(
      args: SelectSubset<T, doctrine_migration_versionsUpsertArgs>
    ): Prisma__doctrine_migration_versionsClient<doctrine_migration_versionsGetPayload<T>>

    /**
     * Count the number of Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {doctrine_migration_versionsCountArgs} args - Arguments to filter Doctrine_migration_versions to count.
     * @example
     * // Count the number of Doctrine_migration_versions
     * const count = await prisma.doctrine_migration_versions.count({
     *   where: {
     *     // ... the filter for the Doctrine_migration_versions we want to count
     *   }
     * })
    **/
    count<T extends doctrine_migration_versionsCountArgs>(
      args?: Subset<T, doctrine_migration_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Doctrine_migration_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Doctrine_migration_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Doctrine_migration_versionsAggregateArgs>(args: Subset<T, Doctrine_migration_versionsAggregateArgs>): Prisma.PrismaPromise<GetDoctrine_migration_versionsAggregateType<T>>

    /**
     * Group by Doctrine_migration_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Doctrine_migration_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Doctrine_migration_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Doctrine_migration_versionsGroupByArgs['orderBy'] }
        : { orderBy?: Doctrine_migration_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Doctrine_migration_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctrine_migration_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for doctrine_migration_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__doctrine_migration_versionsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * doctrine_migration_versions base type for findUnique actions
   */
  export type doctrine_migration_versionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }

  /**
   * doctrine_migration_versions findUnique
   */
  export interface doctrine_migration_versionsFindUniqueArgs extends doctrine_migration_versionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * doctrine_migration_versions findUniqueOrThrow
   */
  export type doctrine_migration_versionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions base type for findFirst actions
   */
  export type doctrine_migration_versionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: Enumerable<doctrine_migration_versionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Enumerable<Doctrine_migration_versionsScalarFieldEnum>
  }

  /**
   * doctrine_migration_versions findFirst
   */
  export interface doctrine_migration_versionsFindFirstArgs extends doctrine_migration_versionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * doctrine_migration_versions findFirstOrThrow
   */
  export type doctrine_migration_versionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: Enumerable<doctrine_migration_versionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of doctrine_migration_versions.
     */
    distinct?: Enumerable<Doctrine_migration_versionsScalarFieldEnum>
  }


  /**
   * doctrine_migration_versions findMany
   */
  export type doctrine_migration_versionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter, which doctrine_migration_versions to fetch.
     */
    where?: doctrine_migration_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of doctrine_migration_versions to fetch.
     */
    orderBy?: Enumerable<doctrine_migration_versionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing doctrine_migration_versions.
     */
    cursor?: doctrine_migration_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` doctrine_migration_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` doctrine_migration_versions.
     */
    skip?: number
    distinct?: Enumerable<Doctrine_migration_versionsScalarFieldEnum>
  }


  /**
   * doctrine_migration_versions create
   */
  export type doctrine_migration_versionsCreateArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * The data needed to create a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
  }


  /**
   * doctrine_migration_versions createMany
   */
  export type doctrine_migration_versionsCreateManyArgs = {
    /**
     * The data used to create many doctrine_migration_versions.
     */
    data: Enumerable<doctrine_migration_versionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * doctrine_migration_versions update
   */
  export type doctrine_migration_versionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * The data needed to update a doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
    /**
     * Choose, which doctrine_migration_versions to update.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions updateMany
   */
  export type doctrine_migration_versionsUpdateManyArgs = {
    /**
     * The data used to update doctrine_migration_versions.
     */
    data: XOR<doctrine_migration_versionsUpdateManyMutationInput, doctrine_migration_versionsUncheckedUpdateManyInput>
    /**
     * Filter which doctrine_migration_versions to update
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions upsert
   */
  export type doctrine_migration_versionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * The filter to search for the doctrine_migration_versions to update in case it exists.
     */
    where: doctrine_migration_versionsWhereUniqueInput
    /**
     * In case the doctrine_migration_versions found by the `where` argument doesn't exist, create a new doctrine_migration_versions with this data.
     */
    create: XOR<doctrine_migration_versionsCreateInput, doctrine_migration_versionsUncheckedCreateInput>
    /**
     * In case the doctrine_migration_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<doctrine_migration_versionsUpdateInput, doctrine_migration_versionsUncheckedUpdateInput>
  }


  /**
   * doctrine_migration_versions delete
   */
  export type doctrine_migration_versionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
    /**
     * Filter which doctrine_migration_versions to delete.
     */
    where: doctrine_migration_versionsWhereUniqueInput
  }


  /**
   * doctrine_migration_versions deleteMany
   */
  export type doctrine_migration_versionsDeleteManyArgs = {
    /**
     * Filter which doctrine_migration_versions to delete
     */
    where?: doctrine_migration_versionsWhereInput
  }


  /**
   * doctrine_migration_versions without action
   */
  export type doctrine_migration_versionsArgs = {
    /**
     * Select specific fields to fetch from the doctrine_migration_versions
     */
    select?: doctrine_migration_versionsSelect | null
  }



  /**
   * Model driver
   */


  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    id: number | null
  }

  export type DriverSumAggregateOutputType = {
    id: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: number | null
    last_name: string | null
    first_name: string | null
    type: string | null
  }

  export type DriverMaxAggregateOutputType = {
    id: number | null
    last_name: string | null
    first_name: string | null
    type: string | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    last_name: number
    first_name: number
    type: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    id?: true
  }

  export type DriverSumAggregateInputType = {
    id?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
    type?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
    type?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
    type?: true
    _all?: true
  }

  export type DriverAggregateArgs = {
    /**
     * Filter which driver to aggregate.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs = {
    where?: driverWhereInput
    orderBy?: Enumerable<driverOrderByWithAggregationInput>
    by: DriverScalarFieldEnum[]
    having?: driverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }


  export type DriverGroupByOutputType = {
    id: number
    last_name: string
    first_name: string
    type: string | null
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type driverSelect = {
    id?: boolean
    last_name?: boolean
    first_name?: boolean
    type?: boolean
    container_mouvement?: boolean | driver$container_mouvementArgs
    replacement_team?: boolean | driver$replacement_teamArgs
    sinister?: boolean | driver$sinisterArgs
    team?: boolean | teamArgs
    _count?: boolean | DriverCountOutputTypeArgs
  }


  export type driverInclude = {
    container_mouvement?: boolean | driver$container_mouvementArgs
    replacement_team?: boolean | driver$replacement_teamArgs
    sinister?: boolean | driver$sinisterArgs
    team?: boolean | teamArgs
    _count?: boolean | DriverCountOutputTypeArgs
  }

  export type driverGetPayload<S extends boolean | null | undefined | driverArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? driver :
    S extends undefined ? never :
    S extends { include: any } & (driverArgs | driverFindManyArgs)
    ? driver  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends 'replacement_team' ? Array < replacement_teamGetPayload<S['include'][P]>>  :
        P extends 'sinister' ? Array < sinisterGetPayload<S['include'][P]>>  :
        P extends 'team' ? teamGetPayload<S['include'][P]> | null :
        P extends '_count' ? DriverCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (driverArgs | driverFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends 'replacement_team' ? Array < replacement_teamGetPayload<S['select'][P]>>  :
        P extends 'sinister' ? Array < sinisterGetPayload<S['select'][P]>>  :
        P extends 'team' ? teamGetPayload<S['select'][P]> | null :
        P extends '_count' ? DriverCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof driver ? driver[P] : never
  } 
      : driver


  type driverCountArgs = 
    Omit<driverFindManyArgs, 'select' | 'include'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface driverDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Driver that matches the filter.
     * @param {driverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends driverFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, driverFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'driver'> extends True ? Prisma__driverClient<driverGetPayload<T>> : Prisma__driverClient<driverGetPayload<T> | null, null>

    /**
     * Find one Driver that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {driverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends driverFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, driverFindUniqueOrThrowArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends driverFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, driverFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'driver'> extends True ? Prisma__driverClient<driverGetPayload<T>> : Prisma__driverClient<driverGetPayload<T> | null, null>

    /**
     * Find the first Driver that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends driverFindFirstOrThrowArgs>(
      args?: SelectSubset<T, driverFindFirstOrThrowArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends driverFindManyArgs>(
      args?: SelectSubset<T, driverFindManyArgs>
    ): Prisma.PrismaPromise<Array<driverGetPayload<T>>>

    /**
     * Create a Driver.
     * @param {driverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
    **/
    create<T extends driverCreateArgs>(
      args: SelectSubset<T, driverCreateArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Create many Drivers.
     *     @param {driverCreateManyArgs} args - Arguments to create many Drivers.
     *     @example
     *     // Create many Drivers
     *     const driver = await prisma.driver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends driverCreateManyArgs>(
      args?: SelectSubset<T, driverCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Driver.
     * @param {driverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
    **/
    delete<T extends driverDeleteArgs>(
      args: SelectSubset<T, driverDeleteArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Update one Driver.
     * @param {driverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends driverUpdateArgs>(
      args: SelectSubset<T, driverUpdateArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Delete zero or more Drivers.
     * @param {driverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends driverDeleteManyArgs>(
      args?: SelectSubset<T, driverDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends driverUpdateManyArgs>(
      args: SelectSubset<T, driverUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {driverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
    **/
    upsert<T extends driverUpsertArgs>(
      args: SelectSubset<T, driverUpsertArgs>
    ): Prisma__driverClient<driverGetPayload<T>>

    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends driverCountArgs>(
      args?: Subset<T, driverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__driverClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends driver$container_mouvementArgs= {}>(args?: Subset<T, driver$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    replacement_team<T extends driver$replacement_teamArgs= {}>(args?: Subset<T, driver$replacement_teamArgs>): Prisma.PrismaPromise<Array<replacement_teamGetPayload<T>>| Null>;

    sinister<T extends driver$sinisterArgs= {}>(args?: Subset<T, driver$sinisterArgs>): Prisma.PrismaPromise<Array<sinisterGetPayload<T>>| Null>;

    team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * driver base type for findUnique actions
   */
  export type driverFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter, which driver to fetch.
     */
    where: driverWhereUniqueInput
  }

  /**
   * driver findUnique
   */
  export interface driverFindUniqueArgs extends driverFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * driver findUniqueOrThrow
   */
  export type driverFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter, which driver to fetch.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver base type for findFirst actions
   */
  export type driverFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter, which driver to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: Enumerable<DriverScalarFieldEnum>
  }

  /**
   * driver findFirst
   */
  export interface driverFindFirstArgs extends driverFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * driver findFirstOrThrow
   */
  export type driverFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter, which driver to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drivers.
     */
    distinct?: Enumerable<DriverScalarFieldEnum>
  }


  /**
   * driver findMany
   */
  export type driverFindManyArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter, which drivers to fetch.
     */
    where?: driverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drivers to fetch.
     */
    orderBy?: Enumerable<driverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drivers.
     */
    cursor?: driverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drivers.
     */
    skip?: number
    distinct?: Enumerable<DriverScalarFieldEnum>
  }


  /**
   * driver create
   */
  export type driverCreateArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * The data needed to create a driver.
     */
    data: XOR<driverCreateInput, driverUncheckedCreateInput>
  }


  /**
   * driver createMany
   */
  export type driverCreateManyArgs = {
    /**
     * The data used to create many drivers.
     */
    data: Enumerable<driverCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * driver update
   */
  export type driverUpdateArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * The data needed to update a driver.
     */
    data: XOR<driverUpdateInput, driverUncheckedUpdateInput>
    /**
     * Choose, which driver to update.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver updateMany
   */
  export type driverUpdateManyArgs = {
    /**
     * The data used to update drivers.
     */
    data: XOR<driverUpdateManyMutationInput, driverUncheckedUpdateManyInput>
    /**
     * Filter which drivers to update
     */
    where?: driverWhereInput
  }


  /**
   * driver upsert
   */
  export type driverUpsertArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * The filter to search for the driver to update in case it exists.
     */
    where: driverWhereUniqueInput
    /**
     * In case the driver found by the `where` argument doesn't exist, create a new driver with this data.
     */
    create: XOR<driverCreateInput, driverUncheckedCreateInput>
    /**
     * In case the driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driverUpdateInput, driverUncheckedUpdateInput>
  }


  /**
   * driver delete
   */
  export type driverDeleteArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
    /**
     * Filter which driver to delete.
     */
    where: driverWhereUniqueInput
  }


  /**
   * driver deleteMany
   */
  export type driverDeleteManyArgs = {
    /**
     * Filter which drivers to delete
     */
    where?: driverWhereInput
  }


  /**
   * driver.container_mouvement
   */
  export type driver$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * driver.replacement_team
   */
  export type driver$replacement_teamArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    where?: replacement_teamWhereInput
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    cursor?: replacement_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }


  /**
   * driver.sinister
   */
  export type driver$sinisterArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    where?: sinisterWhereInput
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    cursor?: sinisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SinisterScalarFieldEnum>
  }


  /**
   * driver without action
   */
  export type driverArgs = {
    /**
     * Select specific fields to fetch from the driver
     */
    select?: driverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driverInclude | null
  }



  /**
   * Model flux
   */


  export type AggregateFlux = {
    _count: FluxCountAggregateOutputType | null
    _avg: FluxAvgAggregateOutputType | null
    _sum: FluxSumAggregateOutputType | null
    _min: FluxMinAggregateOutputType | null
    _max: FluxMaxAggregateOutputType | null
  }

  export type FluxAvgAggregateOutputType = {
    id: number | null
    circuit_id: number | null
  }

  export type FluxSumAggregateOutputType = {
    id: number | null
    circuit_id: number | null
  }

  export type FluxMinAggregateOutputType = {
    id: number | null
    name: string | null
    circuit_id: number | null
  }

  export type FluxMaxAggregateOutputType = {
    id: number | null
    name: string | null
    circuit_id: number | null
  }

  export type FluxCountAggregateOutputType = {
    id: number
    name: number
    circuit_id: number
    _all: number
  }


  export type FluxAvgAggregateInputType = {
    id?: true
    circuit_id?: true
  }

  export type FluxSumAggregateInputType = {
    id?: true
    circuit_id?: true
  }

  export type FluxMinAggregateInputType = {
    id?: true
    name?: true
    circuit_id?: true
  }

  export type FluxMaxAggregateInputType = {
    id?: true
    name?: true
    circuit_id?: true
  }

  export type FluxCountAggregateInputType = {
    id?: true
    name?: true
    circuit_id?: true
    _all?: true
  }

  export type FluxAggregateArgs = {
    /**
     * Filter which flux to aggregate.
     */
    where?: fluxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fluxes to fetch.
     */
    orderBy?: Enumerable<fluxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fluxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fluxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fluxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fluxes
    **/
    _count?: true | FluxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FluxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FluxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FluxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FluxMaxAggregateInputType
  }

  export type GetFluxAggregateType<T extends FluxAggregateArgs> = {
        [P in keyof T & keyof AggregateFlux]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlux[P]>
      : GetScalarType<T[P], AggregateFlux[P]>
  }




  export type FluxGroupByArgs = {
    where?: fluxWhereInput
    orderBy?: Enumerable<fluxOrderByWithAggregationInput>
    by: FluxScalarFieldEnum[]
    having?: fluxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FluxCountAggregateInputType | true
    _avg?: FluxAvgAggregateInputType
    _sum?: FluxSumAggregateInputType
    _min?: FluxMinAggregateInputType
    _max?: FluxMaxAggregateInputType
  }


  export type FluxGroupByOutputType = {
    id: number
    name: string
    circuit_id: number | null
    _count: FluxCountAggregateOutputType | null
    _avg: FluxAvgAggregateOutputType | null
    _sum: FluxSumAggregateOutputType | null
    _min: FluxMinAggregateOutputType | null
    _max: FluxMaxAggregateOutputType | null
  }

  type GetFluxGroupByPayload<T extends FluxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FluxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FluxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FluxGroupByOutputType[P]>
            : GetScalarType<T[P], FluxGroupByOutputType[P]>
        }
      >
    >


  export type fluxSelect = {
    id?: boolean
    name?: boolean
    circuit_id?: boolean
    container_mouvement?: boolean | flux$container_mouvementArgs
    circuit?: boolean | circuitArgs
    report?: boolean | flux$reportArgs
    team?: boolean | flux$teamArgs
    _count?: boolean | FluxCountOutputTypeArgs
  }


  export type fluxInclude = {
    container_mouvement?: boolean | flux$container_mouvementArgs
    circuit?: boolean | circuitArgs
    report?: boolean | flux$reportArgs
    team?: boolean | flux$teamArgs
    _count?: boolean | FluxCountOutputTypeArgs
  }

  export type fluxGetPayload<S extends boolean | null | undefined | fluxArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? flux :
    S extends undefined ? never :
    S extends { include: any } & (fluxArgs | fluxFindManyArgs)
    ? flux  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends 'circuit' ? circuitGetPayload<S['include'][P]> | null :
        P extends 'report' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'team' ? Array < teamGetPayload<S['include'][P]>>  :
        P extends '_count' ? FluxCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fluxArgs | fluxFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends 'circuit' ? circuitGetPayload<S['select'][P]> | null :
        P extends 'report' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'team' ? Array < teamGetPayload<S['select'][P]>>  :
        P extends '_count' ? FluxCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof flux ? flux[P] : never
  } 
      : flux


  type fluxCountArgs = 
    Omit<fluxFindManyArgs, 'select' | 'include'> & {
      select?: FluxCountAggregateInputType | true
    }

  export interface fluxDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Flux that matches the filter.
     * @param {fluxFindUniqueArgs} args - Arguments to find a Flux
     * @example
     * // Get one Flux
     * const flux = await prisma.flux.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fluxFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fluxFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'flux'> extends True ? Prisma__fluxClient<fluxGetPayload<T>> : Prisma__fluxClient<fluxGetPayload<T> | null, null>

    /**
     * Find one Flux that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fluxFindUniqueOrThrowArgs} args - Arguments to find a Flux
     * @example
     * // Get one Flux
     * const flux = await prisma.flux.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fluxFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fluxFindUniqueOrThrowArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Find the first Flux that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fluxFindFirstArgs} args - Arguments to find a Flux
     * @example
     * // Get one Flux
     * const flux = await prisma.flux.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fluxFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fluxFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'flux'> extends True ? Prisma__fluxClient<fluxGetPayload<T>> : Prisma__fluxClient<fluxGetPayload<T> | null, null>

    /**
     * Find the first Flux that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fluxFindFirstOrThrowArgs} args - Arguments to find a Flux
     * @example
     * // Get one Flux
     * const flux = await prisma.flux.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fluxFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fluxFindFirstOrThrowArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Find zero or more Fluxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fluxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fluxes
     * const fluxes = await prisma.flux.findMany()
     * 
     * // Get first 10 Fluxes
     * const fluxes = await prisma.flux.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fluxWithIdOnly = await prisma.flux.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fluxFindManyArgs>(
      args?: SelectSubset<T, fluxFindManyArgs>
    ): Prisma.PrismaPromise<Array<fluxGetPayload<T>>>

    /**
     * Create a Flux.
     * @param {fluxCreateArgs} args - Arguments to create a Flux.
     * @example
     * // Create one Flux
     * const Flux = await prisma.flux.create({
     *   data: {
     *     // ... data to create a Flux
     *   }
     * })
     * 
    **/
    create<T extends fluxCreateArgs>(
      args: SelectSubset<T, fluxCreateArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Create many Fluxes.
     *     @param {fluxCreateManyArgs} args - Arguments to create many Fluxes.
     *     @example
     *     // Create many Fluxes
     *     const flux = await prisma.flux.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fluxCreateManyArgs>(
      args?: SelectSubset<T, fluxCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flux.
     * @param {fluxDeleteArgs} args - Arguments to delete one Flux.
     * @example
     * // Delete one Flux
     * const Flux = await prisma.flux.delete({
     *   where: {
     *     // ... filter to delete one Flux
     *   }
     * })
     * 
    **/
    delete<T extends fluxDeleteArgs>(
      args: SelectSubset<T, fluxDeleteArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Update one Flux.
     * @param {fluxUpdateArgs} args - Arguments to update one Flux.
     * @example
     * // Update one Flux
     * const flux = await prisma.flux.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fluxUpdateArgs>(
      args: SelectSubset<T, fluxUpdateArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Delete zero or more Fluxes.
     * @param {fluxDeleteManyArgs} args - Arguments to filter Fluxes to delete.
     * @example
     * // Delete a few Fluxes
     * const { count } = await prisma.flux.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fluxDeleteManyArgs>(
      args?: SelectSubset<T, fluxDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fluxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fluxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fluxes
     * const flux = await prisma.flux.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fluxUpdateManyArgs>(
      args: SelectSubset<T, fluxUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flux.
     * @param {fluxUpsertArgs} args - Arguments to update or create a Flux.
     * @example
     * // Update or create a Flux
     * const flux = await prisma.flux.upsert({
     *   create: {
     *     // ... data to create a Flux
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flux we want to update
     *   }
     * })
    **/
    upsert<T extends fluxUpsertArgs>(
      args: SelectSubset<T, fluxUpsertArgs>
    ): Prisma__fluxClient<fluxGetPayload<T>>

    /**
     * Count the number of Fluxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fluxCountArgs} args - Arguments to filter Fluxes to count.
     * @example
     * // Count the number of Fluxes
     * const count = await prisma.flux.count({
     *   where: {
     *     // ... the filter for the Fluxes we want to count
     *   }
     * })
    **/
    count<T extends fluxCountArgs>(
      args?: Subset<T, fluxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FluxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flux.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FluxAggregateArgs>(args: Subset<T, FluxAggregateArgs>): Prisma.PrismaPromise<GetFluxAggregateType<T>>

    /**
     * Group by Flux.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FluxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FluxGroupByArgs['orderBy'] }
        : { orderBy?: FluxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FluxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFluxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for flux.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fluxClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends flux$container_mouvementArgs= {}>(args?: Subset<T, flux$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    circuit<T extends circuitArgs= {}>(args?: Subset<T, circuitArgs>): Prisma__circuitClient<circuitGetPayload<T> | Null>;

    report<T extends flux$reportArgs= {}>(args?: Subset<T, flux$reportArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    team<T extends flux$teamArgs= {}>(args?: Subset<T, flux$teamArgs>): Prisma.PrismaPromise<Array<teamGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * flux base type for findUnique actions
   */
  export type fluxFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter, which flux to fetch.
     */
    where: fluxWhereUniqueInput
  }

  /**
   * flux findUnique
   */
  export interface fluxFindUniqueArgs extends fluxFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * flux findUniqueOrThrow
   */
  export type fluxFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter, which flux to fetch.
     */
    where: fluxWhereUniqueInput
  }


  /**
   * flux base type for findFirst actions
   */
  export type fluxFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter, which flux to fetch.
     */
    where?: fluxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fluxes to fetch.
     */
    orderBy?: Enumerable<fluxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fluxes.
     */
    cursor?: fluxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fluxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fluxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fluxes.
     */
    distinct?: Enumerable<FluxScalarFieldEnum>
  }

  /**
   * flux findFirst
   */
  export interface fluxFindFirstArgs extends fluxFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * flux findFirstOrThrow
   */
  export type fluxFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter, which flux to fetch.
     */
    where?: fluxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fluxes to fetch.
     */
    orderBy?: Enumerable<fluxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fluxes.
     */
    cursor?: fluxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fluxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fluxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fluxes.
     */
    distinct?: Enumerable<FluxScalarFieldEnum>
  }


  /**
   * flux findMany
   */
  export type fluxFindManyArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter, which fluxes to fetch.
     */
    where?: fluxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fluxes to fetch.
     */
    orderBy?: Enumerable<fluxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fluxes.
     */
    cursor?: fluxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fluxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fluxes.
     */
    skip?: number
    distinct?: Enumerable<FluxScalarFieldEnum>
  }


  /**
   * flux create
   */
  export type fluxCreateArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * The data needed to create a flux.
     */
    data: XOR<fluxCreateInput, fluxUncheckedCreateInput>
  }


  /**
   * flux createMany
   */
  export type fluxCreateManyArgs = {
    /**
     * The data used to create many fluxes.
     */
    data: Enumerable<fluxCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * flux update
   */
  export type fluxUpdateArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * The data needed to update a flux.
     */
    data: XOR<fluxUpdateInput, fluxUncheckedUpdateInput>
    /**
     * Choose, which flux to update.
     */
    where: fluxWhereUniqueInput
  }


  /**
   * flux updateMany
   */
  export type fluxUpdateManyArgs = {
    /**
     * The data used to update fluxes.
     */
    data: XOR<fluxUpdateManyMutationInput, fluxUncheckedUpdateManyInput>
    /**
     * Filter which fluxes to update
     */
    where?: fluxWhereInput
  }


  /**
   * flux upsert
   */
  export type fluxUpsertArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * The filter to search for the flux to update in case it exists.
     */
    where: fluxWhereUniqueInput
    /**
     * In case the flux found by the `where` argument doesn't exist, create a new flux with this data.
     */
    create: XOR<fluxCreateInput, fluxUncheckedCreateInput>
    /**
     * In case the flux was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fluxUpdateInput, fluxUncheckedUpdateInput>
  }


  /**
   * flux delete
   */
  export type fluxDeleteArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
    /**
     * Filter which flux to delete.
     */
    where: fluxWhereUniqueInput
  }


  /**
   * flux deleteMany
   */
  export type fluxDeleteManyArgs = {
    /**
     * Filter which fluxes to delete
     */
    where?: fluxWhereInput
  }


  /**
   * flux.container_mouvement
   */
  export type flux$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * flux.report
   */
  export type flux$reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * flux.team
   */
  export type flux$teamArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    where?: teamWhereInput
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * flux without action
   */
  export type fluxArgs = {
    /**
     * Select specific fields to fetch from the flux
     */
    select?: fluxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fluxInclude | null
  }



  /**
   * Model messenger_messages
   */


  export type AggregateMessenger_messages = {
    _count: Messenger_messagesCountAggregateOutputType | null
    _avg: Messenger_messagesAvgAggregateOutputType | null
    _sum: Messenger_messagesSumAggregateOutputType | null
    _min: Messenger_messagesMinAggregateOutputType | null
    _max: Messenger_messagesMaxAggregateOutputType | null
  }

  export type Messenger_messagesAvgAggregateOutputType = {
    id: number | null
  }

  export type Messenger_messagesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Messenger_messagesMinAggregateOutputType = {
    id: bigint | null
    body: string | null
    headers: string | null
    queue_name: string | null
    created_at: Date | null
    available_at: Date | null
    delivered_at: Date | null
  }

  export type Messenger_messagesMaxAggregateOutputType = {
    id: bigint | null
    body: string | null
    headers: string | null
    queue_name: string | null
    created_at: Date | null
    available_at: Date | null
    delivered_at: Date | null
  }

  export type Messenger_messagesCountAggregateOutputType = {
    id: number
    body: number
    headers: number
    queue_name: number
    created_at: number
    available_at: number
    delivered_at: number
    _all: number
  }


  export type Messenger_messagesAvgAggregateInputType = {
    id?: true
  }

  export type Messenger_messagesSumAggregateInputType = {
    id?: true
  }

  export type Messenger_messagesMinAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
  }

  export type Messenger_messagesMaxAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
  }

  export type Messenger_messagesCountAggregateInputType = {
    id?: true
    body?: true
    headers?: true
    queue_name?: true
    created_at?: true
    available_at?: true
    delivered_at?: true
    _all?: true
  }

  export type Messenger_messagesAggregateArgs = {
    /**
     * Filter which messenger_messages to aggregate.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: Enumerable<messenger_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messenger_messages
    **/
    _count?: true | Messenger_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Messenger_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Messenger_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Messenger_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Messenger_messagesMaxAggregateInputType
  }

  export type GetMessenger_messagesAggregateType<T extends Messenger_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessenger_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessenger_messages[P]>
      : GetScalarType<T[P], AggregateMessenger_messages[P]>
  }




  export type Messenger_messagesGroupByArgs = {
    where?: messenger_messagesWhereInput
    orderBy?: Enumerable<messenger_messagesOrderByWithAggregationInput>
    by: Messenger_messagesScalarFieldEnum[]
    having?: messenger_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Messenger_messagesCountAggregateInputType | true
    _avg?: Messenger_messagesAvgAggregateInputType
    _sum?: Messenger_messagesSumAggregateInputType
    _min?: Messenger_messagesMinAggregateInputType
    _max?: Messenger_messagesMaxAggregateInputType
  }


  export type Messenger_messagesGroupByOutputType = {
    id: bigint
    body: string
    headers: string
    queue_name: string
    created_at: Date
    available_at: Date
    delivered_at: Date | null
    _count: Messenger_messagesCountAggregateOutputType | null
    _avg: Messenger_messagesAvgAggregateOutputType | null
    _sum: Messenger_messagesSumAggregateOutputType | null
    _min: Messenger_messagesMinAggregateOutputType | null
    _max: Messenger_messagesMaxAggregateOutputType | null
  }

  type GetMessenger_messagesGroupByPayload<T extends Messenger_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Messenger_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Messenger_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Messenger_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Messenger_messagesGroupByOutputType[P]>
        }
      >
    >


  export type messenger_messagesSelect = {
    id?: boolean
    body?: boolean
    headers?: boolean
    queue_name?: boolean
    created_at?: boolean
    available_at?: boolean
    delivered_at?: boolean
  }


  export type messenger_messagesGetPayload<S extends boolean | null | undefined | messenger_messagesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? messenger_messages :
    S extends undefined ? never :
    S extends { include: any } & (messenger_messagesArgs | messenger_messagesFindManyArgs)
    ? messenger_messages 
    : S extends { select: any } & (messenger_messagesArgs | messenger_messagesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof messenger_messages ? messenger_messages[P] : never
  } 
      : messenger_messages


  type messenger_messagesCountArgs = 
    Omit<messenger_messagesFindManyArgs, 'select' | 'include'> & {
      select?: Messenger_messagesCountAggregateInputType | true
    }

  export interface messenger_messagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Messenger_messages that matches the filter.
     * @param {messenger_messagesFindUniqueArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends messenger_messagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, messenger_messagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'messenger_messages'> extends True ? Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>> : Prisma__messenger_messagesClient<messenger_messagesGetPayload<T> | null, null>

    /**
     * Find one Messenger_messages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {messenger_messagesFindUniqueOrThrowArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends messenger_messagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, messenger_messagesFindUniqueOrThrowArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Find the first Messenger_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindFirstArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends messenger_messagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, messenger_messagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'messenger_messages'> extends True ? Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>> : Prisma__messenger_messagesClient<messenger_messagesGetPayload<T> | null, null>

    /**
     * Find the first Messenger_messages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindFirstOrThrowArgs} args - Arguments to find a Messenger_messages
     * @example
     * // Get one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends messenger_messagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, messenger_messagesFindFirstOrThrowArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Find zero or more Messenger_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findMany()
     * 
     * // Get first 10 Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messenger_messagesWithIdOnly = await prisma.messenger_messages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends messenger_messagesFindManyArgs>(
      args?: SelectSubset<T, messenger_messagesFindManyArgs>
    ): Prisma.PrismaPromise<Array<messenger_messagesGetPayload<T>>>

    /**
     * Create a Messenger_messages.
     * @param {messenger_messagesCreateArgs} args - Arguments to create a Messenger_messages.
     * @example
     * // Create one Messenger_messages
     * const Messenger_messages = await prisma.messenger_messages.create({
     *   data: {
     *     // ... data to create a Messenger_messages
     *   }
     * })
     * 
    **/
    create<T extends messenger_messagesCreateArgs>(
      args: SelectSubset<T, messenger_messagesCreateArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Create many Messenger_messages.
     *     @param {messenger_messagesCreateManyArgs} args - Arguments to create many Messenger_messages.
     *     @example
     *     // Create many Messenger_messages
     *     const messenger_messages = await prisma.messenger_messages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends messenger_messagesCreateManyArgs>(
      args?: SelectSubset<T, messenger_messagesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Messenger_messages.
     * @param {messenger_messagesDeleteArgs} args - Arguments to delete one Messenger_messages.
     * @example
     * // Delete one Messenger_messages
     * const Messenger_messages = await prisma.messenger_messages.delete({
     *   where: {
     *     // ... filter to delete one Messenger_messages
     *   }
     * })
     * 
    **/
    delete<T extends messenger_messagesDeleteArgs>(
      args: SelectSubset<T, messenger_messagesDeleteArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Update one Messenger_messages.
     * @param {messenger_messagesUpdateArgs} args - Arguments to update one Messenger_messages.
     * @example
     * // Update one Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends messenger_messagesUpdateArgs>(
      args: SelectSubset<T, messenger_messagesUpdateArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Delete zero or more Messenger_messages.
     * @param {messenger_messagesDeleteManyArgs} args - Arguments to filter Messenger_messages to delete.
     * @example
     * // Delete a few Messenger_messages
     * const { count } = await prisma.messenger_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends messenger_messagesDeleteManyArgs>(
      args?: SelectSubset<T, messenger_messagesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends messenger_messagesUpdateManyArgs>(
      args: SelectSubset<T, messenger_messagesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Messenger_messages.
     * @param {messenger_messagesUpsertArgs} args - Arguments to update or create a Messenger_messages.
     * @example
     * // Update or create a Messenger_messages
     * const messenger_messages = await prisma.messenger_messages.upsert({
     *   create: {
     *     // ... data to create a Messenger_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messenger_messages we want to update
     *   }
     * })
    **/
    upsert<T extends messenger_messagesUpsertArgs>(
      args: SelectSubset<T, messenger_messagesUpsertArgs>
    ): Prisma__messenger_messagesClient<messenger_messagesGetPayload<T>>

    /**
     * Count the number of Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messenger_messagesCountArgs} args - Arguments to filter Messenger_messages to count.
     * @example
     * // Count the number of Messenger_messages
     * const count = await prisma.messenger_messages.count({
     *   where: {
     *     // ... the filter for the Messenger_messages we want to count
     *   }
     * })
    **/
    count<T extends messenger_messagesCountArgs>(
      args?: Subset<T, messenger_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Messenger_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Messenger_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Messenger_messagesAggregateArgs>(args: Subset<T, Messenger_messagesAggregateArgs>): Prisma.PrismaPromise<GetMessenger_messagesAggregateType<T>>

    /**
     * Group by Messenger_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Messenger_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Messenger_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Messenger_messagesGroupByArgs['orderBy'] }
        : { orderBy?: Messenger_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Messenger_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessenger_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for messenger_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__messenger_messagesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * messenger_messages base type for findUnique actions
   */
  export type messenger_messagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where: messenger_messagesWhereUniqueInput
  }

  /**
   * messenger_messages findUnique
   */
  export interface messenger_messagesFindUniqueArgs extends messenger_messagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * messenger_messages findUniqueOrThrow
   */
  export type messenger_messagesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages base type for findFirst actions
   */
  export type messenger_messagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: Enumerable<messenger_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messenger_messages.
     */
    distinct?: Enumerable<Messenger_messagesScalarFieldEnum>
  }

  /**
   * messenger_messages findFirst
   */
  export interface messenger_messagesFindFirstArgs extends messenger_messagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * messenger_messages findFirstOrThrow
   */
  export type messenger_messagesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: Enumerable<messenger_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messenger_messages.
     */
    distinct?: Enumerable<Messenger_messagesScalarFieldEnum>
  }


  /**
   * messenger_messages findMany
   */
  export type messenger_messagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter, which messenger_messages to fetch.
     */
    where?: messenger_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messenger_messages to fetch.
     */
    orderBy?: Enumerable<messenger_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messenger_messages.
     */
    cursor?: messenger_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messenger_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messenger_messages.
     */
    skip?: number
    distinct?: Enumerable<Messenger_messagesScalarFieldEnum>
  }


  /**
   * messenger_messages create
   */
  export type messenger_messagesCreateArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * The data needed to create a messenger_messages.
     */
    data: XOR<messenger_messagesCreateInput, messenger_messagesUncheckedCreateInput>
  }


  /**
   * messenger_messages createMany
   */
  export type messenger_messagesCreateManyArgs = {
    /**
     * The data used to create many messenger_messages.
     */
    data: Enumerable<messenger_messagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * messenger_messages update
   */
  export type messenger_messagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * The data needed to update a messenger_messages.
     */
    data: XOR<messenger_messagesUpdateInput, messenger_messagesUncheckedUpdateInput>
    /**
     * Choose, which messenger_messages to update.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages updateMany
   */
  export type messenger_messagesUpdateManyArgs = {
    /**
     * The data used to update messenger_messages.
     */
    data: XOR<messenger_messagesUpdateManyMutationInput, messenger_messagesUncheckedUpdateManyInput>
    /**
     * Filter which messenger_messages to update
     */
    where?: messenger_messagesWhereInput
  }


  /**
   * messenger_messages upsert
   */
  export type messenger_messagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * The filter to search for the messenger_messages to update in case it exists.
     */
    where: messenger_messagesWhereUniqueInput
    /**
     * In case the messenger_messages found by the `where` argument doesn't exist, create a new messenger_messages with this data.
     */
    create: XOR<messenger_messagesCreateInput, messenger_messagesUncheckedCreateInput>
    /**
     * In case the messenger_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messenger_messagesUpdateInput, messenger_messagesUncheckedUpdateInput>
  }


  /**
   * messenger_messages delete
   */
  export type messenger_messagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
    /**
     * Filter which messenger_messages to delete.
     */
    where: messenger_messagesWhereUniqueInput
  }


  /**
   * messenger_messages deleteMany
   */
  export type messenger_messagesDeleteManyArgs = {
    /**
     * Filter which messenger_messages to delete
     */
    where?: messenger_messagesWhereInput
  }


  /**
   * messenger_messages without action
   */
  export type messenger_messagesArgs = {
    /**
     * Select specific fields to fetch from the messenger_messages
     */
    select?: messenger_messagesSelect | null
  }



  /**
   * Model operation_type
   */


  export type AggregateOperation_type = {
    _count: Operation_typeCountAggregateOutputType | null
    _avg: Operation_typeAvgAggregateOutputType | null
    _sum: Operation_typeSumAggregateOutputType | null
    _min: Operation_typeMinAggregateOutputType | null
    _max: Operation_typeMaxAggregateOutputType | null
  }

  export type Operation_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Operation_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Operation_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Operation_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Operation_typeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Operation_typeAvgAggregateInputType = {
    id?: true
  }

  export type Operation_typeSumAggregateInputType = {
    id?: true
  }

  export type Operation_typeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Operation_typeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Operation_typeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Operation_typeAggregateArgs = {
    /**
     * Filter which operation_type to aggregate.
     */
    where?: operation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operation_types to fetch.
     */
    orderBy?: Enumerable<operation_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operation_types
    **/
    _count?: true | Operation_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Operation_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Operation_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Operation_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Operation_typeMaxAggregateInputType
  }

  export type GetOperation_typeAggregateType<T extends Operation_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateOperation_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperation_type[P]>
      : GetScalarType<T[P], AggregateOperation_type[P]>
  }




  export type Operation_typeGroupByArgs = {
    where?: operation_typeWhereInput
    orderBy?: Enumerable<operation_typeOrderByWithAggregationInput>
    by: Operation_typeScalarFieldEnum[]
    having?: operation_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Operation_typeCountAggregateInputType | true
    _avg?: Operation_typeAvgAggregateInputType
    _sum?: Operation_typeSumAggregateInputType
    _min?: Operation_typeMinAggregateInputType
    _max?: Operation_typeMaxAggregateInputType
  }


  export type Operation_typeGroupByOutputType = {
    id: number
    name: string
    _count: Operation_typeCountAggregateOutputType | null
    _avg: Operation_typeAvgAggregateOutputType | null
    _sum: Operation_typeSumAggregateOutputType | null
    _min: Operation_typeMinAggregateOutputType | null
    _max: Operation_typeMaxAggregateOutputType | null
  }

  type GetOperation_typeGroupByPayload<T extends Operation_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Operation_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Operation_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Operation_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Operation_typeGroupByOutputType[P]>
        }
      >
    >


  export type operation_typeSelect = {
    id?: boolean
    name?: boolean
    container_mouvement?: boolean | operation_type$container_mouvementArgs
    _count?: boolean | Operation_typeCountOutputTypeArgs
  }


  export type operation_typeInclude = {
    container_mouvement?: boolean | operation_type$container_mouvementArgs
    _count?: boolean | Operation_typeCountOutputTypeArgs
  }

  export type operation_typeGetPayload<S extends boolean | null | undefined | operation_typeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? operation_type :
    S extends undefined ? never :
    S extends { include: any } & (operation_typeArgs | operation_typeFindManyArgs)
    ? operation_type  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends '_count' ? Operation_typeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (operation_typeArgs | operation_typeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends '_count' ? Operation_typeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof operation_type ? operation_type[P] : never
  } 
      : operation_type


  type operation_typeCountArgs = 
    Omit<operation_typeFindManyArgs, 'select' | 'include'> & {
      select?: Operation_typeCountAggregateInputType | true
    }

  export interface operation_typeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Operation_type that matches the filter.
     * @param {operation_typeFindUniqueArgs} args - Arguments to find a Operation_type
     * @example
     * // Get one Operation_type
     * const operation_type = await prisma.operation_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operation_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operation_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operation_type'> extends True ? Prisma__operation_typeClient<operation_typeGetPayload<T>> : Prisma__operation_typeClient<operation_typeGetPayload<T> | null, null>

    /**
     * Find one Operation_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operation_typeFindUniqueOrThrowArgs} args - Arguments to find a Operation_type
     * @example
     * // Get one Operation_type
     * const operation_type = await prisma.operation_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operation_typeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, operation_typeFindUniqueOrThrowArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Find the first Operation_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operation_typeFindFirstArgs} args - Arguments to find a Operation_type
     * @example
     * // Get one Operation_type
     * const operation_type = await prisma.operation_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operation_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operation_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operation_type'> extends True ? Prisma__operation_typeClient<operation_typeGetPayload<T>> : Prisma__operation_typeClient<operation_typeGetPayload<T> | null, null>

    /**
     * Find the first Operation_type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operation_typeFindFirstOrThrowArgs} args - Arguments to find a Operation_type
     * @example
     * // Get one Operation_type
     * const operation_type = await prisma.operation_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operation_typeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, operation_typeFindFirstOrThrowArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Find zero or more Operation_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operation_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operation_types
     * const operation_types = await prisma.operation_type.findMany()
     * 
     * // Get first 10 Operation_types
     * const operation_types = await prisma.operation_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operation_typeWithIdOnly = await prisma.operation_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends operation_typeFindManyArgs>(
      args?: SelectSubset<T, operation_typeFindManyArgs>
    ): Prisma.PrismaPromise<Array<operation_typeGetPayload<T>>>

    /**
     * Create a Operation_type.
     * @param {operation_typeCreateArgs} args - Arguments to create a Operation_type.
     * @example
     * // Create one Operation_type
     * const Operation_type = await prisma.operation_type.create({
     *   data: {
     *     // ... data to create a Operation_type
     *   }
     * })
     * 
    **/
    create<T extends operation_typeCreateArgs>(
      args: SelectSubset<T, operation_typeCreateArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Create many Operation_types.
     *     @param {operation_typeCreateManyArgs} args - Arguments to create many Operation_types.
     *     @example
     *     // Create many Operation_types
     *     const operation_type = await prisma.operation_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operation_typeCreateManyArgs>(
      args?: SelectSubset<T, operation_typeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operation_type.
     * @param {operation_typeDeleteArgs} args - Arguments to delete one Operation_type.
     * @example
     * // Delete one Operation_type
     * const Operation_type = await prisma.operation_type.delete({
     *   where: {
     *     // ... filter to delete one Operation_type
     *   }
     * })
     * 
    **/
    delete<T extends operation_typeDeleteArgs>(
      args: SelectSubset<T, operation_typeDeleteArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Update one Operation_type.
     * @param {operation_typeUpdateArgs} args - Arguments to update one Operation_type.
     * @example
     * // Update one Operation_type
     * const operation_type = await prisma.operation_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operation_typeUpdateArgs>(
      args: SelectSubset<T, operation_typeUpdateArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Delete zero or more Operation_types.
     * @param {operation_typeDeleteManyArgs} args - Arguments to filter Operation_types to delete.
     * @example
     * // Delete a few Operation_types
     * const { count } = await prisma.operation_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operation_typeDeleteManyArgs>(
      args?: SelectSubset<T, operation_typeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operation_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operation_types
     * const operation_type = await prisma.operation_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operation_typeUpdateManyArgs>(
      args: SelectSubset<T, operation_typeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operation_type.
     * @param {operation_typeUpsertArgs} args - Arguments to update or create a Operation_type.
     * @example
     * // Update or create a Operation_type
     * const operation_type = await prisma.operation_type.upsert({
     *   create: {
     *     // ... data to create a Operation_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operation_type we want to update
     *   }
     * })
    **/
    upsert<T extends operation_typeUpsertArgs>(
      args: SelectSubset<T, operation_typeUpsertArgs>
    ): Prisma__operation_typeClient<operation_typeGetPayload<T>>

    /**
     * Count the number of Operation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operation_typeCountArgs} args - Arguments to filter Operation_types to count.
     * @example
     * // Count the number of Operation_types
     * const count = await prisma.operation_type.count({
     *   where: {
     *     // ... the filter for the Operation_types we want to count
     *   }
     * })
    **/
    count<T extends operation_typeCountArgs>(
      args?: Subset<T, operation_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Operation_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Operation_typeAggregateArgs>(args: Subset<T, Operation_typeAggregateArgs>): Prisma.PrismaPromise<GetOperation_typeAggregateType<T>>

    /**
     * Group by Operation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Operation_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Operation_typeGroupByArgs['orderBy'] }
        : { orderBy?: Operation_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Operation_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperation_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operation_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operation_typeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends operation_type$container_mouvementArgs= {}>(args?: Subset<T, operation_type$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operation_type base type for findUnique actions
   */
  export type operation_typeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter, which operation_type to fetch.
     */
    where: operation_typeWhereUniqueInput
  }

  /**
   * operation_type findUnique
   */
  export interface operation_typeFindUniqueArgs extends operation_typeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operation_type findUniqueOrThrow
   */
  export type operation_typeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter, which operation_type to fetch.
     */
    where: operation_typeWhereUniqueInput
  }


  /**
   * operation_type base type for findFirst actions
   */
  export type operation_typeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter, which operation_type to fetch.
     */
    where?: operation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operation_types to fetch.
     */
    orderBy?: Enumerable<operation_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operation_types.
     */
    cursor?: operation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operation_types.
     */
    distinct?: Enumerable<Operation_typeScalarFieldEnum>
  }

  /**
   * operation_type findFirst
   */
  export interface operation_typeFindFirstArgs extends operation_typeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operation_type findFirstOrThrow
   */
  export type operation_typeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter, which operation_type to fetch.
     */
    where?: operation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operation_types to fetch.
     */
    orderBy?: Enumerable<operation_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operation_types.
     */
    cursor?: operation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operation_types.
     */
    distinct?: Enumerable<Operation_typeScalarFieldEnum>
  }


  /**
   * operation_type findMany
   */
  export type operation_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter, which operation_types to fetch.
     */
    where?: operation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operation_types to fetch.
     */
    orderBy?: Enumerable<operation_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operation_types.
     */
    cursor?: operation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operation_types.
     */
    skip?: number
    distinct?: Enumerable<Operation_typeScalarFieldEnum>
  }


  /**
   * operation_type create
   */
  export type operation_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * The data needed to create a operation_type.
     */
    data: XOR<operation_typeCreateInput, operation_typeUncheckedCreateInput>
  }


  /**
   * operation_type createMany
   */
  export type operation_typeCreateManyArgs = {
    /**
     * The data used to create many operation_types.
     */
    data: Enumerable<operation_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * operation_type update
   */
  export type operation_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * The data needed to update a operation_type.
     */
    data: XOR<operation_typeUpdateInput, operation_typeUncheckedUpdateInput>
    /**
     * Choose, which operation_type to update.
     */
    where: operation_typeWhereUniqueInput
  }


  /**
   * operation_type updateMany
   */
  export type operation_typeUpdateManyArgs = {
    /**
     * The data used to update operation_types.
     */
    data: XOR<operation_typeUpdateManyMutationInput, operation_typeUncheckedUpdateManyInput>
    /**
     * Filter which operation_types to update
     */
    where?: operation_typeWhereInput
  }


  /**
   * operation_type upsert
   */
  export type operation_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * The filter to search for the operation_type to update in case it exists.
     */
    where: operation_typeWhereUniqueInput
    /**
     * In case the operation_type found by the `where` argument doesn't exist, create a new operation_type with this data.
     */
    create: XOR<operation_typeCreateInput, operation_typeUncheckedCreateInput>
    /**
     * In case the operation_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operation_typeUpdateInput, operation_typeUncheckedUpdateInput>
  }


  /**
   * operation_type delete
   */
  export type operation_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
    /**
     * Filter which operation_type to delete.
     */
    where: operation_typeWhereUniqueInput
  }


  /**
   * operation_type deleteMany
   */
  export type operation_typeDeleteManyArgs = {
    /**
     * Filter which operation_types to delete
     */
    where?: operation_typeWhereInput
  }


  /**
   * operation_type.container_mouvement
   */
  export type operation_type$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * operation_type without action
   */
  export type operation_typeArgs = {
    /**
     * Select specific fields to fetch from the operation_type
     */
    select?: operation_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operation_typeInclude | null
  }



  /**
   * Model outlet
   */


  export type AggregateOutlet = {
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  export type OutletAvgAggregateOutputType = {
    id: number | null
  }

  export type OutletSumAggregateOutputType = {
    id: number | null
  }

  export type OutletMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OutletMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type OutletCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type OutletAvgAggregateInputType = {
    id?: true
  }

  export type OutletSumAggregateInputType = {
    id?: true
  }

  export type OutletMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type OutletMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type OutletCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type OutletAggregateArgs = {
    /**
     * Filter which outlet to aggregate.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: Enumerable<outletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned outlets
    **/
    _count?: true | OutletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutletMaxAggregateInputType
  }

  export type GetOutletAggregateType<T extends OutletAggregateArgs> = {
        [P in keyof T & keyof AggregateOutlet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutlet[P]>
      : GetScalarType<T[P], AggregateOutlet[P]>
  }




  export type OutletGroupByArgs = {
    where?: outletWhereInput
    orderBy?: Enumerable<outletOrderByWithAggregationInput>
    by: OutletScalarFieldEnum[]
    having?: outletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutletCountAggregateInputType | true
    _avg?: OutletAvgAggregateInputType
    _sum?: OutletSumAggregateInputType
    _min?: OutletMinAggregateInputType
    _max?: OutletMaxAggregateInputType
  }


  export type OutletGroupByOutputType = {
    id: number
    name: string
    _count: OutletCountAggregateOutputType | null
    _avg: OutletAvgAggregateOutputType | null
    _sum: OutletSumAggregateOutputType | null
    _min: OutletMinAggregateOutputType | null
    _max: OutletMaxAggregateOutputType | null
  }

  type GetOutletGroupByPayload<T extends OutletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OutletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutletGroupByOutputType[P]>
            : GetScalarType<T[P], OutletGroupByOutputType[P]>
        }
      >
    >


  export type outletSelect = {
    id?: boolean
    name?: boolean
    circuit?: boolean | outlet$circuitArgs
    container_mouvement?: boolean | outlet$container_mouvementArgs
    report_report_visited_outlet4_idTooutlet?: boolean | outlet$report_report_visited_outlet4_idTooutletArgs
    report_report_visited_outlet2_idTooutlet?: boolean | outlet$report_report_visited_outlet2_idTooutletArgs
    report_report_default_outlet_idTooutlet?: boolean | outlet$report_report_default_outlet_idTooutletArgs
    report_report_default_outlet3_idTooutlet?: boolean | outlet$report_report_default_outlet3_idTooutletArgs
    report_report_visited_outlet3_idTooutlet?: boolean | outlet$report_report_visited_outlet3_idTooutletArgs
    report_report_visited_outlet_idTooutlet?: boolean | outlet$report_report_visited_outlet_idTooutletArgs
    report_report_default_outlet2_idTooutlet?: boolean | outlet$report_report_default_outlet2_idTooutletArgs
    report_report_default_outlet4_idTooutlet?: boolean | outlet$report_report_default_outlet4_idTooutletArgs
    _count?: boolean | OutletCountOutputTypeArgs
  }


  export type outletInclude = {
    circuit?: boolean | outlet$circuitArgs
    container_mouvement?: boolean | outlet$container_mouvementArgs
    report_report_visited_outlet4_idTooutlet?: boolean | outlet$report_report_visited_outlet4_idTooutletArgs
    report_report_visited_outlet2_idTooutlet?: boolean | outlet$report_report_visited_outlet2_idTooutletArgs
    report_report_default_outlet_idTooutlet?: boolean | outlet$report_report_default_outlet_idTooutletArgs
    report_report_default_outlet3_idTooutlet?: boolean | outlet$report_report_default_outlet3_idTooutletArgs
    report_report_visited_outlet3_idTooutlet?: boolean | outlet$report_report_visited_outlet3_idTooutletArgs
    report_report_visited_outlet_idTooutlet?: boolean | outlet$report_report_visited_outlet_idTooutletArgs
    report_report_default_outlet2_idTooutlet?: boolean | outlet$report_report_default_outlet2_idTooutletArgs
    report_report_default_outlet4_idTooutlet?: boolean | outlet$report_report_default_outlet4_idTooutletArgs
    _count?: boolean | OutletCountOutputTypeArgs
  }

  export type outletGetPayload<S extends boolean | null | undefined | outletArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? outlet :
    S extends undefined ? never :
    S extends { include: any } & (outletArgs | outletFindManyArgs)
    ? outlet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'circuit' ? Array < circuitGetPayload<S['include'][P]>>  :
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends 'report_report_visited_outlet4_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_visited_outlet2_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_default_outlet_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_default_outlet3_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_visited_outlet3_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_visited_outlet_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_default_outlet2_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'report_report_default_outlet4_idTooutlet' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends '_count' ? OutletCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (outletArgs | outletFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'circuit' ? Array < circuitGetPayload<S['select'][P]>>  :
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends 'report_report_visited_outlet4_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_visited_outlet2_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_default_outlet_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_default_outlet3_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_visited_outlet3_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_visited_outlet_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_default_outlet2_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'report_report_default_outlet4_idTooutlet' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends '_count' ? OutletCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof outlet ? outlet[P] : never
  } 
      : outlet


  type outletCountArgs = 
    Omit<outletFindManyArgs, 'select' | 'include'> & {
      select?: OutletCountAggregateInputType | true
    }

  export interface outletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Outlet that matches the filter.
     * @param {outletFindUniqueArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends outletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, outletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'outlet'> extends True ? Prisma__outletClient<outletGetPayload<T>> : Prisma__outletClient<outletGetPayload<T> | null, null>

    /**
     * Find one Outlet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {outletFindUniqueOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends outletFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, outletFindUniqueOrThrowArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Find the first Outlet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindFirstArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends outletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, outletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'outlet'> extends True ? Prisma__outletClient<outletGetPayload<T>> : Prisma__outletClient<outletGetPayload<T> | null, null>

    /**
     * Find the first Outlet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindFirstOrThrowArgs} args - Arguments to find a Outlet
     * @example
     * // Get one Outlet
     * const outlet = await prisma.outlet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends outletFindFirstOrThrowArgs>(
      args?: SelectSubset<T, outletFindFirstOrThrowArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Find zero or more Outlets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outlets
     * const outlets = await prisma.outlet.findMany()
     * 
     * // Get first 10 Outlets
     * const outlets = await prisma.outlet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outletWithIdOnly = await prisma.outlet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends outletFindManyArgs>(
      args?: SelectSubset<T, outletFindManyArgs>
    ): Prisma.PrismaPromise<Array<outletGetPayload<T>>>

    /**
     * Create a Outlet.
     * @param {outletCreateArgs} args - Arguments to create a Outlet.
     * @example
     * // Create one Outlet
     * const Outlet = await prisma.outlet.create({
     *   data: {
     *     // ... data to create a Outlet
     *   }
     * })
     * 
    **/
    create<T extends outletCreateArgs>(
      args: SelectSubset<T, outletCreateArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Create many Outlets.
     *     @param {outletCreateManyArgs} args - Arguments to create many Outlets.
     *     @example
     *     // Create many Outlets
     *     const outlet = await prisma.outlet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends outletCreateManyArgs>(
      args?: SelectSubset<T, outletCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Outlet.
     * @param {outletDeleteArgs} args - Arguments to delete one Outlet.
     * @example
     * // Delete one Outlet
     * const Outlet = await prisma.outlet.delete({
     *   where: {
     *     // ... filter to delete one Outlet
     *   }
     * })
     * 
    **/
    delete<T extends outletDeleteArgs>(
      args: SelectSubset<T, outletDeleteArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Update one Outlet.
     * @param {outletUpdateArgs} args - Arguments to update one Outlet.
     * @example
     * // Update one Outlet
     * const outlet = await prisma.outlet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends outletUpdateArgs>(
      args: SelectSubset<T, outletUpdateArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Delete zero or more Outlets.
     * @param {outletDeleteManyArgs} args - Arguments to filter Outlets to delete.
     * @example
     * // Delete a few Outlets
     * const { count } = await prisma.outlet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends outletDeleteManyArgs>(
      args?: SelectSubset<T, outletDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outlets
     * const outlet = await prisma.outlet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends outletUpdateManyArgs>(
      args: SelectSubset<T, outletUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Outlet.
     * @param {outletUpsertArgs} args - Arguments to update or create a Outlet.
     * @example
     * // Update or create a Outlet
     * const outlet = await prisma.outlet.upsert({
     *   create: {
     *     // ... data to create a Outlet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outlet we want to update
     *   }
     * })
    **/
    upsert<T extends outletUpsertArgs>(
      args: SelectSubset<T, outletUpsertArgs>
    ): Prisma__outletClient<outletGetPayload<T>>

    /**
     * Count the number of Outlets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outletCountArgs} args - Arguments to filter Outlets to count.
     * @example
     * // Count the number of Outlets
     * const count = await prisma.outlet.count({
     *   where: {
     *     // ... the filter for the Outlets we want to count
     *   }
     * })
    **/
    count<T extends outletCountArgs>(
      args?: Subset<T, outletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutletAggregateArgs>(args: Subset<T, OutletAggregateArgs>): Prisma.PrismaPromise<GetOutletAggregateType<T>>

    /**
     * Group by Outlet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutletGroupByArgs['orderBy'] }
        : { orderBy?: OutletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for outlet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__outletClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    circuit<T extends outlet$circuitArgs= {}>(args?: Subset<T, outlet$circuitArgs>): Prisma.PrismaPromise<Array<circuitGetPayload<T>>| Null>;

    container_mouvement<T extends outlet$container_mouvementArgs= {}>(args?: Subset<T, outlet$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    report_report_visited_outlet4_idTooutlet<T extends outlet$report_report_visited_outlet4_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_visited_outlet4_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_visited_outlet2_idTooutlet<T extends outlet$report_report_visited_outlet2_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_visited_outlet2_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_default_outlet_idTooutlet<T extends outlet$report_report_default_outlet_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_default_outlet_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_default_outlet3_idTooutlet<T extends outlet$report_report_default_outlet3_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_default_outlet3_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_visited_outlet3_idTooutlet<T extends outlet$report_report_visited_outlet3_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_visited_outlet3_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_visited_outlet_idTooutlet<T extends outlet$report_report_visited_outlet_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_visited_outlet_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_default_outlet2_idTooutlet<T extends outlet$report_report_default_outlet2_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_default_outlet2_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    report_report_default_outlet4_idTooutlet<T extends outlet$report_report_default_outlet4_idTooutletArgs= {}>(args?: Subset<T, outlet$report_report_default_outlet4_idTooutletArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * outlet base type for findUnique actions
   */
  export type outletFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter, which outlet to fetch.
     */
    where: outletWhereUniqueInput
  }

  /**
   * outlet findUnique
   */
  export interface outletFindUniqueArgs extends outletFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * outlet findUniqueOrThrow
   */
  export type outletFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter, which outlet to fetch.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet base type for findFirst actions
   */
  export type outletFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter, which outlet to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: Enumerable<outletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outlets.
     */
    distinct?: Enumerable<OutletScalarFieldEnum>
  }

  /**
   * outlet findFirst
   */
  export interface outletFindFirstArgs extends outletFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * outlet findFirstOrThrow
   */
  export type outletFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter, which outlet to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: Enumerable<outletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outlets.
     */
    distinct?: Enumerable<OutletScalarFieldEnum>
  }


  /**
   * outlet findMany
   */
  export type outletFindManyArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter, which outlets to fetch.
     */
    where?: outletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outlets to fetch.
     */
    orderBy?: Enumerable<outletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing outlets.
     */
    cursor?: outletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outlets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outlets.
     */
    skip?: number
    distinct?: Enumerable<OutletScalarFieldEnum>
  }


  /**
   * outlet create
   */
  export type outletCreateArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * The data needed to create a outlet.
     */
    data: XOR<outletCreateInput, outletUncheckedCreateInput>
  }


  /**
   * outlet createMany
   */
  export type outletCreateManyArgs = {
    /**
     * The data used to create many outlets.
     */
    data: Enumerable<outletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * outlet update
   */
  export type outletUpdateArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * The data needed to update a outlet.
     */
    data: XOR<outletUpdateInput, outletUncheckedUpdateInput>
    /**
     * Choose, which outlet to update.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet updateMany
   */
  export type outletUpdateManyArgs = {
    /**
     * The data used to update outlets.
     */
    data: XOR<outletUpdateManyMutationInput, outletUncheckedUpdateManyInput>
    /**
     * Filter which outlets to update
     */
    where?: outletWhereInput
  }


  /**
   * outlet upsert
   */
  export type outletUpsertArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * The filter to search for the outlet to update in case it exists.
     */
    where: outletWhereUniqueInput
    /**
     * In case the outlet found by the `where` argument doesn't exist, create a new outlet with this data.
     */
    create: XOR<outletCreateInput, outletUncheckedCreateInput>
    /**
     * In case the outlet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<outletUpdateInput, outletUncheckedUpdateInput>
  }


  /**
   * outlet delete
   */
  export type outletDeleteArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
    /**
     * Filter which outlet to delete.
     */
    where: outletWhereUniqueInput
  }


  /**
   * outlet deleteMany
   */
  export type outletDeleteManyArgs = {
    /**
     * Filter which outlets to delete
     */
    where?: outletWhereInput
  }


  /**
   * outlet.circuit
   */
  export type outlet$circuitArgs = {
    /**
     * Select specific fields to fetch from the circuit
     */
    select?: circuitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: circuitInclude | null
    where?: circuitWhereInput
    orderBy?: Enumerable<circuitOrderByWithRelationInput>
    cursor?: circuitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CircuitScalarFieldEnum>
  }


  /**
   * outlet.container_mouvement
   */
  export type outlet$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * outlet.report_report_visited_outlet4_idTooutlet
   */
  export type outlet$report_report_visited_outlet4_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_visited_outlet2_idTooutlet
   */
  export type outlet$report_report_visited_outlet2_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_default_outlet_idTooutlet
   */
  export type outlet$report_report_default_outlet_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_default_outlet3_idTooutlet
   */
  export type outlet$report_report_default_outlet3_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_visited_outlet3_idTooutlet
   */
  export type outlet$report_report_visited_outlet3_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_visited_outlet_idTooutlet
   */
  export type outlet$report_report_visited_outlet_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_default_outlet2_idTooutlet
   */
  export type outlet$report_report_default_outlet2_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet.report_report_default_outlet4_idTooutlet
   */
  export type outlet$report_report_default_outlet4_idTooutletArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * outlet without action
   */
  export type outletArgs = {
    /**
     * Select specific fields to fetch from the outlet
     */
    select?: outletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outletInclude | null
  }



  /**
   * Model replacement_team
   */


  export type AggregateReplacement_team = {
    _count: Replacement_teamCountAggregateOutputType | null
    _avg: Replacement_teamAvgAggregateOutputType | null
    _sum: Replacement_teamSumAggregateOutputType | null
    _min: Replacement_teamMinAggregateOutputType | null
    _max: Replacement_teamMaxAggregateOutputType | null
  }

  export type Replacement_teamAvgAggregateOutputType = {
    id: number | null
    substitute_driver_id: number | null
    substitute_ripper1_id: number | null
    substitute_ripper2_id: number | null
  }

  export type Replacement_teamSumAggregateOutputType = {
    id: number | null
    substitute_driver_id: number | null
    substitute_ripper1_id: number | null
    substitute_ripper2_id: number | null
  }

  export type Replacement_teamMinAggregateOutputType = {
    id: number | null
    substitute_driver_id: number | null
    substitute_ripper1_id: number | null
    substitute_ripper2_id: number | null
  }

  export type Replacement_teamMaxAggregateOutputType = {
    id: number | null
    substitute_driver_id: number | null
    substitute_ripper1_id: number | null
    substitute_ripper2_id: number | null
  }

  export type Replacement_teamCountAggregateOutputType = {
    id: number
    substitute_driver_id: number
    substitute_ripper1_id: number
    substitute_ripper2_id: number
    _all: number
  }


  export type Replacement_teamAvgAggregateInputType = {
    id?: true
    substitute_driver_id?: true
    substitute_ripper1_id?: true
    substitute_ripper2_id?: true
  }

  export type Replacement_teamSumAggregateInputType = {
    id?: true
    substitute_driver_id?: true
    substitute_ripper1_id?: true
    substitute_ripper2_id?: true
  }

  export type Replacement_teamMinAggregateInputType = {
    id?: true
    substitute_driver_id?: true
    substitute_ripper1_id?: true
    substitute_ripper2_id?: true
  }

  export type Replacement_teamMaxAggregateInputType = {
    id?: true
    substitute_driver_id?: true
    substitute_ripper1_id?: true
    substitute_ripper2_id?: true
  }

  export type Replacement_teamCountAggregateInputType = {
    id?: true
    substitute_driver_id?: true
    substitute_ripper1_id?: true
    substitute_ripper2_id?: true
    _all?: true
  }

  export type Replacement_teamAggregateArgs = {
    /**
     * Filter which replacement_team to aggregate.
     */
    where?: replacement_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of replacement_teams to fetch.
     */
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: replacement_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` replacement_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` replacement_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned replacement_teams
    **/
    _count?: true | Replacement_teamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Replacement_teamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Replacement_teamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Replacement_teamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Replacement_teamMaxAggregateInputType
  }

  export type GetReplacement_teamAggregateType<T extends Replacement_teamAggregateArgs> = {
        [P in keyof T & keyof AggregateReplacement_team]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReplacement_team[P]>
      : GetScalarType<T[P], AggregateReplacement_team[P]>
  }




  export type Replacement_teamGroupByArgs = {
    where?: replacement_teamWhereInput
    orderBy?: Enumerable<replacement_teamOrderByWithAggregationInput>
    by: Replacement_teamScalarFieldEnum[]
    having?: replacement_teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Replacement_teamCountAggregateInputType | true
    _avg?: Replacement_teamAvgAggregateInputType
    _sum?: Replacement_teamSumAggregateInputType
    _min?: Replacement_teamMinAggregateInputType
    _max?: Replacement_teamMaxAggregateInputType
  }


  export type Replacement_teamGroupByOutputType = {
    id: number
    substitute_driver_id: number | null
    substitute_ripper1_id: number | null
    substitute_ripper2_id: number | null
    _count: Replacement_teamCountAggregateOutputType | null
    _avg: Replacement_teamAvgAggregateOutputType | null
    _sum: Replacement_teamSumAggregateOutputType | null
    _min: Replacement_teamMinAggregateOutputType | null
    _max: Replacement_teamMaxAggregateOutputType | null
  }

  type GetReplacement_teamGroupByPayload<T extends Replacement_teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Replacement_teamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Replacement_teamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Replacement_teamGroupByOutputType[P]>
            : GetScalarType<T[P], Replacement_teamGroupByOutputType[P]>
        }
      >
    >


  export type replacement_teamSelect = {
    id?: boolean
    substitute_driver_id?: boolean
    substitute_ripper1_id?: boolean
    substitute_ripper2_id?: boolean
    ripper_replacement_team_substitute_ripper2_idToripper?: boolean | ripperArgs
    ripper_replacement_team_substitute_ripper1_idToripper?: boolean | ripperArgs
    driver?: boolean | driverArgs
    team?: boolean | teamArgs
  }


  export type replacement_teamInclude = {
    ripper_replacement_team_substitute_ripper2_idToripper?: boolean | ripperArgs
    ripper_replacement_team_substitute_ripper1_idToripper?: boolean | ripperArgs
    driver?: boolean | driverArgs
    team?: boolean | teamArgs
  }

  export type replacement_teamGetPayload<S extends boolean | null | undefined | replacement_teamArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? replacement_team :
    S extends undefined ? never :
    S extends { include: any } & (replacement_teamArgs | replacement_teamFindManyArgs)
    ? replacement_team  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ripper_replacement_team_substitute_ripper2_idToripper' ? ripperGetPayload<S['include'][P]> | null :
        P extends 'ripper_replacement_team_substitute_ripper1_idToripper' ? ripperGetPayload<S['include'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['include'][P]> | null :
        P extends 'team' ? teamGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (replacement_teamArgs | replacement_teamFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ripper_replacement_team_substitute_ripper2_idToripper' ? ripperGetPayload<S['select'][P]> | null :
        P extends 'ripper_replacement_team_substitute_ripper1_idToripper' ? ripperGetPayload<S['select'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['select'][P]> | null :
        P extends 'team' ? teamGetPayload<S['select'][P]> | null :  P extends keyof replacement_team ? replacement_team[P] : never
  } 
      : replacement_team


  type replacement_teamCountArgs = 
    Omit<replacement_teamFindManyArgs, 'select' | 'include'> & {
      select?: Replacement_teamCountAggregateInputType | true
    }

  export interface replacement_teamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Replacement_team that matches the filter.
     * @param {replacement_teamFindUniqueArgs} args - Arguments to find a Replacement_team
     * @example
     * // Get one Replacement_team
     * const replacement_team = await prisma.replacement_team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends replacement_teamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, replacement_teamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'replacement_team'> extends True ? Prisma__replacement_teamClient<replacement_teamGetPayload<T>> : Prisma__replacement_teamClient<replacement_teamGetPayload<T> | null, null>

    /**
     * Find one Replacement_team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {replacement_teamFindUniqueOrThrowArgs} args - Arguments to find a Replacement_team
     * @example
     * // Get one Replacement_team
     * const replacement_team = await prisma.replacement_team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends replacement_teamFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, replacement_teamFindUniqueOrThrowArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Find the first Replacement_team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {replacement_teamFindFirstArgs} args - Arguments to find a Replacement_team
     * @example
     * // Get one Replacement_team
     * const replacement_team = await prisma.replacement_team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends replacement_teamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, replacement_teamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'replacement_team'> extends True ? Prisma__replacement_teamClient<replacement_teamGetPayload<T>> : Prisma__replacement_teamClient<replacement_teamGetPayload<T> | null, null>

    /**
     * Find the first Replacement_team that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {replacement_teamFindFirstOrThrowArgs} args - Arguments to find a Replacement_team
     * @example
     * // Get one Replacement_team
     * const replacement_team = await prisma.replacement_team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends replacement_teamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, replacement_teamFindFirstOrThrowArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Find zero or more Replacement_teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {replacement_teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Replacement_teams
     * const replacement_teams = await prisma.replacement_team.findMany()
     * 
     * // Get first 10 Replacement_teams
     * const replacement_teams = await prisma.replacement_team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const replacement_teamWithIdOnly = await prisma.replacement_team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends replacement_teamFindManyArgs>(
      args?: SelectSubset<T, replacement_teamFindManyArgs>
    ): Prisma.PrismaPromise<Array<replacement_teamGetPayload<T>>>

    /**
     * Create a Replacement_team.
     * @param {replacement_teamCreateArgs} args - Arguments to create a Replacement_team.
     * @example
     * // Create one Replacement_team
     * const Replacement_team = await prisma.replacement_team.create({
     *   data: {
     *     // ... data to create a Replacement_team
     *   }
     * })
     * 
    **/
    create<T extends replacement_teamCreateArgs>(
      args: SelectSubset<T, replacement_teamCreateArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Create many Replacement_teams.
     *     @param {replacement_teamCreateManyArgs} args - Arguments to create many Replacement_teams.
     *     @example
     *     // Create many Replacement_teams
     *     const replacement_team = await prisma.replacement_team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends replacement_teamCreateManyArgs>(
      args?: SelectSubset<T, replacement_teamCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Replacement_team.
     * @param {replacement_teamDeleteArgs} args - Arguments to delete one Replacement_team.
     * @example
     * // Delete one Replacement_team
     * const Replacement_team = await prisma.replacement_team.delete({
     *   where: {
     *     // ... filter to delete one Replacement_team
     *   }
     * })
     * 
    **/
    delete<T extends replacement_teamDeleteArgs>(
      args: SelectSubset<T, replacement_teamDeleteArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Update one Replacement_team.
     * @param {replacement_teamUpdateArgs} args - Arguments to update one Replacement_team.
     * @example
     * // Update one Replacement_team
     * const replacement_team = await prisma.replacement_team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends replacement_teamUpdateArgs>(
      args: SelectSubset<T, replacement_teamUpdateArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Delete zero or more Replacement_teams.
     * @param {replacement_teamDeleteManyArgs} args - Arguments to filter Replacement_teams to delete.
     * @example
     * // Delete a few Replacement_teams
     * const { count } = await prisma.replacement_team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends replacement_teamDeleteManyArgs>(
      args?: SelectSubset<T, replacement_teamDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replacement_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {replacement_teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Replacement_teams
     * const replacement_team = await prisma.replacement_team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends replacement_teamUpdateManyArgs>(
      args: SelectSubset<T, replacement_teamUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Replacement_team.
     * @param {replacement_teamUpsertArgs} args - Arguments to update or create a Replacement_team.
     * @example
     * // Update or create a Replacement_team
     * const replacement_team = await prisma.replacement_team.upsert({
     *   create: {
     *     // ... data to create a Replacement_team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Replacement_team we want to update
     *   }
     * })
    **/
    upsert<T extends replacement_teamUpsertArgs>(
      args: SelectSubset<T, replacement_teamUpsertArgs>
    ): Prisma__replacement_teamClient<replacement_teamGetPayload<T>>

    /**
     * Count the number of Replacement_teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {replacement_teamCountArgs} args - Arguments to filter Replacement_teams to count.
     * @example
     * // Count the number of Replacement_teams
     * const count = await prisma.replacement_team.count({
     *   where: {
     *     // ... the filter for the Replacement_teams we want to count
     *   }
     * })
    **/
    count<T extends replacement_teamCountArgs>(
      args?: Subset<T, replacement_teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Replacement_teamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Replacement_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Replacement_teamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Replacement_teamAggregateArgs>(args: Subset<T, Replacement_teamAggregateArgs>): Prisma.PrismaPromise<GetReplacement_teamAggregateType<T>>

    /**
     * Group by Replacement_team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Replacement_teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Replacement_teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Replacement_teamGroupByArgs['orderBy'] }
        : { orderBy?: Replacement_teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Replacement_teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplacement_teamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for replacement_team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__replacement_teamClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ripper_replacement_team_substitute_ripper2_idToripper<T extends ripperArgs= {}>(args?: Subset<T, ripperArgs>): Prisma__ripperClient<ripperGetPayload<T> | Null>;

    ripper_replacement_team_substitute_ripper1_idToripper<T extends ripperArgs= {}>(args?: Subset<T, ripperArgs>): Prisma__ripperClient<ripperGetPayload<T> | Null>;

    driver<T extends driverArgs= {}>(args?: Subset<T, driverArgs>): Prisma__driverClient<driverGetPayload<T> | Null>;

    team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * replacement_team base type for findUnique actions
   */
  export type replacement_teamFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter, which replacement_team to fetch.
     */
    where: replacement_teamWhereUniqueInput
  }

  /**
   * replacement_team findUnique
   */
  export interface replacement_teamFindUniqueArgs extends replacement_teamFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * replacement_team findUniqueOrThrow
   */
  export type replacement_teamFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter, which replacement_team to fetch.
     */
    where: replacement_teamWhereUniqueInput
  }


  /**
   * replacement_team base type for findFirst actions
   */
  export type replacement_teamFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter, which replacement_team to fetch.
     */
    where?: replacement_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of replacement_teams to fetch.
     */
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for replacement_teams.
     */
    cursor?: replacement_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` replacement_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` replacement_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of replacement_teams.
     */
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }

  /**
   * replacement_team findFirst
   */
  export interface replacement_teamFindFirstArgs extends replacement_teamFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * replacement_team findFirstOrThrow
   */
  export type replacement_teamFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter, which replacement_team to fetch.
     */
    where?: replacement_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of replacement_teams to fetch.
     */
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for replacement_teams.
     */
    cursor?: replacement_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` replacement_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` replacement_teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of replacement_teams.
     */
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }


  /**
   * replacement_team findMany
   */
  export type replacement_teamFindManyArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter, which replacement_teams to fetch.
     */
    where?: replacement_teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of replacement_teams to fetch.
     */
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing replacement_teams.
     */
    cursor?: replacement_teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` replacement_teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` replacement_teams.
     */
    skip?: number
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }


  /**
   * replacement_team create
   */
  export type replacement_teamCreateArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * The data needed to create a replacement_team.
     */
    data: XOR<replacement_teamCreateInput, replacement_teamUncheckedCreateInput>
  }


  /**
   * replacement_team createMany
   */
  export type replacement_teamCreateManyArgs = {
    /**
     * The data used to create many replacement_teams.
     */
    data: Enumerable<replacement_teamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * replacement_team update
   */
  export type replacement_teamUpdateArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * The data needed to update a replacement_team.
     */
    data: XOR<replacement_teamUpdateInput, replacement_teamUncheckedUpdateInput>
    /**
     * Choose, which replacement_team to update.
     */
    where: replacement_teamWhereUniqueInput
  }


  /**
   * replacement_team updateMany
   */
  export type replacement_teamUpdateManyArgs = {
    /**
     * The data used to update replacement_teams.
     */
    data: XOR<replacement_teamUpdateManyMutationInput, replacement_teamUncheckedUpdateManyInput>
    /**
     * Filter which replacement_teams to update
     */
    where?: replacement_teamWhereInput
  }


  /**
   * replacement_team upsert
   */
  export type replacement_teamUpsertArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * The filter to search for the replacement_team to update in case it exists.
     */
    where: replacement_teamWhereUniqueInput
    /**
     * In case the replacement_team found by the `where` argument doesn't exist, create a new replacement_team with this data.
     */
    create: XOR<replacement_teamCreateInput, replacement_teamUncheckedCreateInput>
    /**
     * In case the replacement_team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<replacement_teamUpdateInput, replacement_teamUncheckedUpdateInput>
  }


  /**
   * replacement_team delete
   */
  export type replacement_teamDeleteArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    /**
     * Filter which replacement_team to delete.
     */
    where: replacement_teamWhereUniqueInput
  }


  /**
   * replacement_team deleteMany
   */
  export type replacement_teamDeleteManyArgs = {
    /**
     * Filter which replacement_teams to delete
     */
    where?: replacement_teamWhereInput
  }


  /**
   * replacement_team without action
   */
  export type replacement_teamArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
  }



  /**
   * Model report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    visited_outlet_id: number | null
    flux_id: number | null
    truck_id: number | null
    total_bac_collected: number | null
    total_bac_rejected: number | null
    tonnage: number | null
    tonnage2: number | null
    default_outlet2_id: number | null
    visited_outlet2_id: number | null
    default_outlet3_id: number | null
    visited_outlet3_id: number | null
    default_outlet4_id: number | null
    visited_outlet4_id: number | null
    tonnage3: number | null
    tonnage4: number | null
    circuit_id: number | null
    collecte_id: number | null
    geoloc_id: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    visited_outlet_id: number | null
    flux_id: number | null
    truck_id: number | null
    total_bac_collected: number | null
    total_bac_rejected: number | null
    tonnage: number | null
    tonnage2: number | null
    default_outlet2_id: number | null
    visited_outlet2_id: number | null
    default_outlet3_id: number | null
    visited_outlet3_id: number | null
    default_outlet4_id: number | null
    visited_outlet4_id: number | null
    tonnage3: number | null
    tonnage4: number | null
    circuit_id: number | null
    collecte_id: number | null
    geoloc_id: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    visited_outlet_id: number | null
    flux_id: number | null
    truck_id: number | null
    date: Date | null
    manual_circuit: string | null
    total_bac_collected: number | null
    total_bac_rejected: number | null
    tonnage: number | null
    tonnage2: number | null
    default_outlet2_id: number | null
    visited_outlet2_id: number | null
    default_outlet3_id: number | null
    visited_outlet3_id: number | null
    default_outlet4_id: number | null
    visited_outlet4_id: number | null
    tonnage3: number | null
    tonnage4: number | null
    circuit_id: number | null
    collecte_id: number | null
    observation: string | null
    geoloc_id: number | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    default_outlet_id: number | null
    visited_outlet_id: number | null
    flux_id: number | null
    truck_id: number | null
    date: Date | null
    manual_circuit: string | null
    total_bac_collected: number | null
    total_bac_rejected: number | null
    tonnage: number | null
    tonnage2: number | null
    default_outlet2_id: number | null
    visited_outlet2_id: number | null
    default_outlet3_id: number | null
    visited_outlet3_id: number | null
    default_outlet4_id: number | null
    visited_outlet4_id: number | null
    tonnage3: number | null
    tonnage4: number | null
    circuit_id: number | null
    collecte_id: number | null
    observation: string | null
    geoloc_id: number | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    default_outlet_id: number
    visited_outlet_id: number
    flux_id: number
    truck_id: number
    date: number
    manual_circuit: number
    total_bac_collected: number
    total_bac_rejected: number
    tonnage: number
    tonnage2: number
    default_outlet2_id: number
    visited_outlet2_id: number
    default_outlet3_id: number
    visited_outlet3_id: number
    default_outlet4_id: number
    visited_outlet4_id: number
    tonnage3: number
    tonnage4: number
    circuit_id: number
    collecte_id: number
    observation: number
    geoloc_id: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    default_outlet_id?: true
    visited_outlet_id?: true
    flux_id?: true
    truck_id?: true
    total_bac_collected?: true
    total_bac_rejected?: true
    tonnage?: true
    tonnage2?: true
    default_outlet2_id?: true
    visited_outlet2_id?: true
    default_outlet3_id?: true
    visited_outlet3_id?: true
    default_outlet4_id?: true
    visited_outlet4_id?: true
    tonnage3?: true
    tonnage4?: true
    circuit_id?: true
    collecte_id?: true
    geoloc_id?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    default_outlet_id?: true
    visited_outlet_id?: true
    flux_id?: true
    truck_id?: true
    total_bac_collected?: true
    total_bac_rejected?: true
    tonnage?: true
    tonnage2?: true
    default_outlet2_id?: true
    visited_outlet2_id?: true
    default_outlet3_id?: true
    visited_outlet3_id?: true
    default_outlet4_id?: true
    visited_outlet4_id?: true
    tonnage3?: true
    tonnage4?: true
    circuit_id?: true
    collecte_id?: true
    geoloc_id?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    default_outlet_id?: true
    visited_outlet_id?: true
    flux_id?: true
    truck_id?: true
    date?: true
    manual_circuit?: true
    total_bac_collected?: true
    total_bac_rejected?: true
    tonnage?: true
    tonnage2?: true
    default_outlet2_id?: true
    visited_outlet2_id?: true
    default_outlet3_id?: true
    visited_outlet3_id?: true
    default_outlet4_id?: true
    visited_outlet4_id?: true
    tonnage3?: true
    tonnage4?: true
    circuit_id?: true
    collecte_id?: true
    observation?: true
    geoloc_id?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    default_outlet_id?: true
    visited_outlet_id?: true
    flux_id?: true
    truck_id?: true
    date?: true
    manual_circuit?: true
    total_bac_collected?: true
    total_bac_rejected?: true
    tonnage?: true
    tonnage2?: true
    default_outlet2_id?: true
    visited_outlet2_id?: true
    default_outlet3_id?: true
    visited_outlet3_id?: true
    default_outlet4_id?: true
    visited_outlet4_id?: true
    tonnage3?: true
    tonnage4?: true
    circuit_id?: true
    collecte_id?: true
    observation?: true
    geoloc_id?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    default_outlet_id?: true
    visited_outlet_id?: true
    flux_id?: true
    truck_id?: true
    date?: true
    manual_circuit?: true
    total_bac_collected?: true
    total_bac_rejected?: true
    tonnage?: true
    tonnage2?: true
    default_outlet2_id?: true
    visited_outlet2_id?: true
    default_outlet3_id?: true
    visited_outlet3_id?: true
    default_outlet4_id?: true
    visited_outlet4_id?: true
    tonnage3?: true
    tonnage4?: true
    circuit_id?: true
    collecte_id?: true
    observation?: true
    geoloc_id?: true
    _all?: true
  }

  export type ReportAggregateArgs = {
    /**
     * Filter which report to aggregate.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs = {
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithAggregationInput>
    by: ReportScalarFieldEnum[]
    having?: reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: number
    default_outlet_id: number | null
    visited_outlet_id: number | null
    flux_id: number | null
    truck_id: number | null
    date: Date
    manual_circuit: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage: number | null
    tonnage2: number | null
    default_outlet2_id: number | null
    visited_outlet2_id: number | null
    default_outlet3_id: number | null
    visited_outlet3_id: number | null
    default_outlet4_id: number | null
    visited_outlet4_id: number | null
    tonnage3: number | null
    tonnage4: number | null
    circuit_id: number | null
    collecte_id: number | null
    observation: string | null
    geoloc_id: number | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type reportSelect = {
    id?: boolean
    default_outlet_id?: boolean
    visited_outlet_id?: boolean
    flux_id?: boolean
    truck_id?: boolean
    date?: boolean
    manual_circuit?: boolean
    total_bac_collected?: boolean
    total_bac_rejected?: boolean
    tonnage?: boolean
    tonnage2?: boolean
    default_outlet2_id?: boolean
    visited_outlet2_id?: boolean
    default_outlet3_id?: boolean
    visited_outlet3_id?: boolean
    default_outlet4_id?: boolean
    visited_outlet4_id?: boolean
    tonnage3?: boolean
    tonnage4?: boolean
    circuit_id?: boolean
    collecte_id?: boolean
    observation?: boolean
    geoloc_id?: boolean
    anomaly?: boolean | report$anomalyArgs
    outlet_report_visited_outlet4_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet2_idTooutlet?: boolean | outletArgs
    outlet_report_default_outlet_idTooutlet?: boolean | outletArgs
    collecte?: boolean | collecteArgs
    outlet_report_default_outlet3_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet3_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet_idTooutlet?: boolean | outletArgs
    outlet_report_default_outlet2_idTooutlet?: boolean | outletArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    circuit?: boolean | circuitArgs
    outlet_report_default_outlet4_idTooutlet?: boolean | outletArgs
    tablet?: boolean | tabletArgs
    _count?: boolean | ReportCountOutputTypeArgs
  }


  export type reportInclude = {
    anomaly?: boolean | report$anomalyArgs
    outlet_report_visited_outlet4_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet2_idTooutlet?: boolean | outletArgs
    outlet_report_default_outlet_idTooutlet?: boolean | outletArgs
    collecte?: boolean | collecteArgs
    outlet_report_default_outlet3_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet3_idTooutlet?: boolean | outletArgs
    outlet_report_visited_outlet_idTooutlet?: boolean | outletArgs
    outlet_report_default_outlet2_idTooutlet?: boolean | outletArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    circuit?: boolean | circuitArgs
    outlet_report_default_outlet4_idTooutlet?: boolean | outletArgs
    tablet?: boolean | tabletArgs
    _count?: boolean | ReportCountOutputTypeArgs
  }

  export type reportGetPayload<S extends boolean | null | undefined | reportArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? report :
    S extends undefined ? never :
    S extends { include: any } & (reportArgs | reportFindManyArgs)
    ? report  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['include'][P]>>  :
        P extends 'outlet_report_visited_outlet4_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_visited_outlet2_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_default_outlet_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'collecte' ? collecteGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_default_outlet3_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_visited_outlet3_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_visited_outlet_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_default_outlet2_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['include'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['include'][P]> | null :
        P extends 'circuit' ? circuitGetPayload<S['include'][P]> | null :
        P extends 'outlet_report_default_outlet4_idTooutlet' ? outletGetPayload<S['include'][P]> | null :
        P extends 'tablet' ? tabletGetPayload<S['include'][P]> | null :
        P extends '_count' ? ReportCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (reportArgs | reportFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['select'][P]>>  :
        P extends 'outlet_report_visited_outlet4_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_visited_outlet2_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_default_outlet_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'collecte' ? collecteGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_default_outlet3_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_visited_outlet3_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_visited_outlet_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_default_outlet2_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['select'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['select'][P]> | null :
        P extends 'circuit' ? circuitGetPayload<S['select'][P]> | null :
        P extends 'outlet_report_default_outlet4_idTooutlet' ? outletGetPayload<S['select'][P]> | null :
        P extends 'tablet' ? tabletGetPayload<S['select'][P]> | null :
        P extends '_count' ? ReportCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof report ? report[P] : never
  } 
      : report


  type reportCountArgs = 
    Omit<reportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface reportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Report that matches the filter.
     * @param {reportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'report'> extends True ? Prisma__reportClient<reportGetPayload<T>> : Prisma__reportClient<reportGetPayload<T> | null, null>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reportFindUniqueOrThrowArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'report'> extends True ? Prisma__reportClient<reportGetPayload<T>> : Prisma__reportClient<reportGetPayload<T> | null, null>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reportFindFirstOrThrowArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reportFindManyArgs>(
      args?: SelectSubset<T, reportFindManyArgs>
    ): Prisma.PrismaPromise<Array<reportGetPayload<T>>>

    /**
     * Create a Report.
     * @param {reportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends reportCreateArgs>(
      args: SelectSubset<T, reportCreateArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Create many Reports.
     *     @param {reportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reportCreateManyArgs>(
      args?: SelectSubset<T, reportCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {reportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends reportDeleteArgs>(
      args: SelectSubset<T, reportDeleteArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Update one Report.
     * @param {reportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportUpdateArgs>(
      args: SelectSubset<T, reportUpdateArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Delete zero or more Reports.
     * @param {reportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportDeleteManyArgs>(
      args?: SelectSubset<T, reportDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportUpdateManyArgs>(
      args: SelectSubset<T, reportUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {reportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends reportUpsertArgs>(
      args: SelectSubset<T, reportUpsertArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportCountArgs>(
      args?: Subset<T, reportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reportClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    anomaly<T extends report$anomalyArgs= {}>(args?: Subset<T, report$anomalyArgs>): Prisma.PrismaPromise<Array<anomalyGetPayload<T>>| Null>;

    outlet_report_visited_outlet4_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    outlet_report_visited_outlet2_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    outlet_report_default_outlet_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    collecte<T extends collecteArgs= {}>(args?: Subset<T, collecteArgs>): Prisma__collecteClient<collecteGetPayload<T> | Null>;

    outlet_report_default_outlet3_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    outlet_report_visited_outlet3_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    outlet_report_visited_outlet_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    outlet_report_default_outlet2_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    truck<T extends truckArgs= {}>(args?: Subset<T, truckArgs>): Prisma__truckClient<truckGetPayload<T> | Null>;

    flux<T extends fluxArgs= {}>(args?: Subset<T, fluxArgs>): Prisma__fluxClient<fluxGetPayload<T> | Null>;

    circuit<T extends circuitArgs= {}>(args?: Subset<T, circuitArgs>): Prisma__circuitClient<circuitGetPayload<T> | Null>;

    outlet_report_default_outlet4_idTooutlet<T extends outletArgs= {}>(args?: Subset<T, outletArgs>): Prisma__outletClient<outletGetPayload<T> | Null>;

    tablet<T extends tabletArgs= {}>(args?: Subset<T, tabletArgs>): Prisma__tabletClient<tabletGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * report base type for findUnique actions
   */
  export type reportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findUnique
   */
  export interface reportFindUniqueArgs extends reportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report findUniqueOrThrow
   */
  export type reportFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report base type for findFirst actions
   */
  export type reportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * report findFirst
   */
  export interface reportFindFirstArgs extends reportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report findFirstOrThrow
   */
  export type reportFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * report findMany
   */
  export type reportFindManyArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * report create
   */
  export type reportCreateArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The data needed to create a report.
     */
    data: XOR<reportCreateInput, reportUncheckedCreateInput>
  }


  /**
   * report createMany
   */
  export type reportCreateManyArgs = {
    /**
     * The data used to create many reports.
     */
    data: Enumerable<reportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * report update
   */
  export type reportUpdateArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The data needed to update a report.
     */
    data: XOR<reportUpdateInput, reportUncheckedUpdateInput>
    /**
     * Choose, which report to update.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report updateMany
   */
  export type reportUpdateManyArgs = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportWhereInput
  }


  /**
   * report upsert
   */
  export type reportUpsertArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The filter to search for the report to update in case it exists.
     */
    where: reportWhereUniqueInput
    /**
     * In case the report found by the `where` argument doesn't exist, create a new report with this data.
     */
    create: XOR<reportCreateInput, reportUncheckedCreateInput>
    /**
     * In case the report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportUpdateInput, reportUncheckedUpdateInput>
  }


  /**
   * report delete
   */
  export type reportDeleteArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter which report to delete.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report deleteMany
   */
  export type reportDeleteManyArgs = {
    /**
     * Filter which reports to delete
     */
    where?: reportWhereInput
  }


  /**
   * report.anomaly
   */
  export type report$anomalyArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    where?: anomalyWhereInput
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    cursor?: anomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }


  /**
   * report without action
   */
  export type reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
  }



  /**
   * Model ripper
   */


  export type AggregateRipper = {
    _count: RipperCountAggregateOutputType | null
    _avg: RipperAvgAggregateOutputType | null
    _sum: RipperSumAggregateOutputType | null
    _min: RipperMinAggregateOutputType | null
    _max: RipperMaxAggregateOutputType | null
  }

  export type RipperAvgAggregateOutputType = {
    id: number | null
  }

  export type RipperSumAggregateOutputType = {
    id: number | null
  }

  export type RipperMinAggregateOutputType = {
    id: number | null
    last_name: string | null
    first_name: string | null
  }

  export type RipperMaxAggregateOutputType = {
    id: number | null
    last_name: string | null
    first_name: string | null
  }

  export type RipperCountAggregateOutputType = {
    id: number
    last_name: number
    first_name: number
    _all: number
  }


  export type RipperAvgAggregateInputType = {
    id?: true
  }

  export type RipperSumAggregateInputType = {
    id?: true
  }

  export type RipperMinAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
  }

  export type RipperMaxAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
  }

  export type RipperCountAggregateInputType = {
    id?: true
    last_name?: true
    first_name?: true
    _all?: true
  }

  export type RipperAggregateArgs = {
    /**
     * Filter which ripper to aggregate.
     */
    where?: ripperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rippers to fetch.
     */
    orderBy?: Enumerable<ripperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ripperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rippers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rippers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rippers
    **/
    _count?: true | RipperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RipperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RipperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RipperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RipperMaxAggregateInputType
  }

  export type GetRipperAggregateType<T extends RipperAggregateArgs> = {
        [P in keyof T & keyof AggregateRipper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRipper[P]>
      : GetScalarType<T[P], AggregateRipper[P]>
  }




  export type RipperGroupByArgs = {
    where?: ripperWhereInput
    orderBy?: Enumerable<ripperOrderByWithAggregationInput>
    by: RipperScalarFieldEnum[]
    having?: ripperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RipperCountAggregateInputType | true
    _avg?: RipperAvgAggregateInputType
    _sum?: RipperSumAggregateInputType
    _min?: RipperMinAggregateInputType
    _max?: RipperMaxAggregateInputType
  }


  export type RipperGroupByOutputType = {
    id: number
    last_name: string
    first_name: string
    _count: RipperCountAggregateOutputType | null
    _avg: RipperAvgAggregateOutputType | null
    _sum: RipperSumAggregateOutputType | null
    _min: RipperMinAggregateOutputType | null
    _max: RipperMaxAggregateOutputType | null
  }

  type GetRipperGroupByPayload<T extends RipperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RipperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RipperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RipperGroupByOutputType[P]>
            : GetScalarType<T[P], RipperGroupByOutputType[P]>
        }
      >
    >


  export type ripperSelect = {
    id?: boolean
    last_name?: boolean
    first_name?: boolean
    replacement_team_replacement_team_substitute_ripper2_idToripper?: boolean | ripper$replacement_team_replacement_team_substitute_ripper2_idToripperArgs
    replacement_team_replacement_team_substitute_ripper1_idToripper?: boolean | ripper$replacement_team_replacement_team_substitute_ripper1_idToripperArgs
    team_team_ripper1_idToripper?: boolean | teamArgs
    team_team_ripper2_idToripper?: boolean | teamArgs
    _count?: boolean | RipperCountOutputTypeArgs
  }


  export type ripperInclude = {
    replacement_team_replacement_team_substitute_ripper2_idToripper?: boolean | ripper$replacement_team_replacement_team_substitute_ripper2_idToripperArgs
    replacement_team_replacement_team_substitute_ripper1_idToripper?: boolean | ripper$replacement_team_replacement_team_substitute_ripper1_idToripperArgs
    team_team_ripper1_idToripper?: boolean | teamArgs
    team_team_ripper2_idToripper?: boolean | teamArgs
    _count?: boolean | RipperCountOutputTypeArgs
  }

  export type ripperGetPayload<S extends boolean | null | undefined | ripperArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ripper :
    S extends undefined ? never :
    S extends { include: any } & (ripperArgs | ripperFindManyArgs)
    ? ripper  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'replacement_team_replacement_team_substitute_ripper2_idToripper' ? Array < replacement_teamGetPayload<S['include'][P]>>  :
        P extends 'replacement_team_replacement_team_substitute_ripper1_idToripper' ? Array < replacement_teamGetPayload<S['include'][P]>>  :
        P extends 'team_team_ripper1_idToripper' ? teamGetPayload<S['include'][P]> | null :
        P extends 'team_team_ripper2_idToripper' ? teamGetPayload<S['include'][P]> | null :
        P extends '_count' ? RipperCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ripperArgs | ripperFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'replacement_team_replacement_team_substitute_ripper2_idToripper' ? Array < replacement_teamGetPayload<S['select'][P]>>  :
        P extends 'replacement_team_replacement_team_substitute_ripper1_idToripper' ? Array < replacement_teamGetPayload<S['select'][P]>>  :
        P extends 'team_team_ripper1_idToripper' ? teamGetPayload<S['select'][P]> | null :
        P extends 'team_team_ripper2_idToripper' ? teamGetPayload<S['select'][P]> | null :
        P extends '_count' ? RipperCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ripper ? ripper[P] : never
  } 
      : ripper


  type ripperCountArgs = 
    Omit<ripperFindManyArgs, 'select' | 'include'> & {
      select?: RipperCountAggregateInputType | true
    }

  export interface ripperDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Ripper that matches the filter.
     * @param {ripperFindUniqueArgs} args - Arguments to find a Ripper
     * @example
     * // Get one Ripper
     * const ripper = await prisma.ripper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ripperFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ripperFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ripper'> extends True ? Prisma__ripperClient<ripperGetPayload<T>> : Prisma__ripperClient<ripperGetPayload<T> | null, null>

    /**
     * Find one Ripper that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ripperFindUniqueOrThrowArgs} args - Arguments to find a Ripper
     * @example
     * // Get one Ripper
     * const ripper = await prisma.ripper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ripperFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ripperFindUniqueOrThrowArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Find the first Ripper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ripperFindFirstArgs} args - Arguments to find a Ripper
     * @example
     * // Get one Ripper
     * const ripper = await prisma.ripper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ripperFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ripperFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ripper'> extends True ? Prisma__ripperClient<ripperGetPayload<T>> : Prisma__ripperClient<ripperGetPayload<T> | null, null>

    /**
     * Find the first Ripper that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ripperFindFirstOrThrowArgs} args - Arguments to find a Ripper
     * @example
     * // Get one Ripper
     * const ripper = await prisma.ripper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ripperFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ripperFindFirstOrThrowArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Find zero or more Rippers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ripperFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rippers
     * const rippers = await prisma.ripper.findMany()
     * 
     * // Get first 10 Rippers
     * const rippers = await prisma.ripper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ripperWithIdOnly = await prisma.ripper.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ripperFindManyArgs>(
      args?: SelectSubset<T, ripperFindManyArgs>
    ): Prisma.PrismaPromise<Array<ripperGetPayload<T>>>

    /**
     * Create a Ripper.
     * @param {ripperCreateArgs} args - Arguments to create a Ripper.
     * @example
     * // Create one Ripper
     * const Ripper = await prisma.ripper.create({
     *   data: {
     *     // ... data to create a Ripper
     *   }
     * })
     * 
    **/
    create<T extends ripperCreateArgs>(
      args: SelectSubset<T, ripperCreateArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Create many Rippers.
     *     @param {ripperCreateManyArgs} args - Arguments to create many Rippers.
     *     @example
     *     // Create many Rippers
     *     const ripper = await prisma.ripper.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ripperCreateManyArgs>(
      args?: SelectSubset<T, ripperCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ripper.
     * @param {ripperDeleteArgs} args - Arguments to delete one Ripper.
     * @example
     * // Delete one Ripper
     * const Ripper = await prisma.ripper.delete({
     *   where: {
     *     // ... filter to delete one Ripper
     *   }
     * })
     * 
    **/
    delete<T extends ripperDeleteArgs>(
      args: SelectSubset<T, ripperDeleteArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Update one Ripper.
     * @param {ripperUpdateArgs} args - Arguments to update one Ripper.
     * @example
     * // Update one Ripper
     * const ripper = await prisma.ripper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ripperUpdateArgs>(
      args: SelectSubset<T, ripperUpdateArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Delete zero or more Rippers.
     * @param {ripperDeleteManyArgs} args - Arguments to filter Rippers to delete.
     * @example
     * // Delete a few Rippers
     * const { count } = await prisma.ripper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ripperDeleteManyArgs>(
      args?: SelectSubset<T, ripperDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rippers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ripperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rippers
     * const ripper = await prisma.ripper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ripperUpdateManyArgs>(
      args: SelectSubset<T, ripperUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ripper.
     * @param {ripperUpsertArgs} args - Arguments to update or create a Ripper.
     * @example
     * // Update or create a Ripper
     * const ripper = await prisma.ripper.upsert({
     *   create: {
     *     // ... data to create a Ripper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ripper we want to update
     *   }
     * })
    **/
    upsert<T extends ripperUpsertArgs>(
      args: SelectSubset<T, ripperUpsertArgs>
    ): Prisma__ripperClient<ripperGetPayload<T>>

    /**
     * Count the number of Rippers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ripperCountArgs} args - Arguments to filter Rippers to count.
     * @example
     * // Count the number of Rippers
     * const count = await prisma.ripper.count({
     *   where: {
     *     // ... the filter for the Rippers we want to count
     *   }
     * })
    **/
    count<T extends ripperCountArgs>(
      args?: Subset<T, ripperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RipperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ripper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RipperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RipperAggregateArgs>(args: Subset<T, RipperAggregateArgs>): Prisma.PrismaPromise<GetRipperAggregateType<T>>

    /**
     * Group by Ripper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RipperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RipperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RipperGroupByArgs['orderBy'] }
        : { orderBy?: RipperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RipperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRipperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ripper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ripperClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    replacement_team_replacement_team_substitute_ripper2_idToripper<T extends ripper$replacement_team_replacement_team_substitute_ripper2_idToripperArgs= {}>(args?: Subset<T, ripper$replacement_team_replacement_team_substitute_ripper2_idToripperArgs>): Prisma.PrismaPromise<Array<replacement_teamGetPayload<T>>| Null>;

    replacement_team_replacement_team_substitute_ripper1_idToripper<T extends ripper$replacement_team_replacement_team_substitute_ripper1_idToripperArgs= {}>(args?: Subset<T, ripper$replacement_team_replacement_team_substitute_ripper1_idToripperArgs>): Prisma.PrismaPromise<Array<replacement_teamGetPayload<T>>| Null>;

    team_team_ripper1_idToripper<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    team_team_ripper2_idToripper<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ripper base type for findUnique actions
   */
  export type ripperFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter, which ripper to fetch.
     */
    where: ripperWhereUniqueInput
  }

  /**
   * ripper findUnique
   */
  export interface ripperFindUniqueArgs extends ripperFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ripper findUniqueOrThrow
   */
  export type ripperFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter, which ripper to fetch.
     */
    where: ripperWhereUniqueInput
  }


  /**
   * ripper base type for findFirst actions
   */
  export type ripperFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter, which ripper to fetch.
     */
    where?: ripperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rippers to fetch.
     */
    orderBy?: Enumerable<ripperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rippers.
     */
    cursor?: ripperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rippers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rippers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rippers.
     */
    distinct?: Enumerable<RipperScalarFieldEnum>
  }

  /**
   * ripper findFirst
   */
  export interface ripperFindFirstArgs extends ripperFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ripper findFirstOrThrow
   */
  export type ripperFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter, which ripper to fetch.
     */
    where?: ripperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rippers to fetch.
     */
    orderBy?: Enumerable<ripperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rippers.
     */
    cursor?: ripperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rippers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rippers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rippers.
     */
    distinct?: Enumerable<RipperScalarFieldEnum>
  }


  /**
   * ripper findMany
   */
  export type ripperFindManyArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter, which rippers to fetch.
     */
    where?: ripperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rippers to fetch.
     */
    orderBy?: Enumerable<ripperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rippers.
     */
    cursor?: ripperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rippers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rippers.
     */
    skip?: number
    distinct?: Enumerable<RipperScalarFieldEnum>
  }


  /**
   * ripper create
   */
  export type ripperCreateArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * The data needed to create a ripper.
     */
    data: XOR<ripperCreateInput, ripperUncheckedCreateInput>
  }


  /**
   * ripper createMany
   */
  export type ripperCreateManyArgs = {
    /**
     * The data used to create many rippers.
     */
    data: Enumerable<ripperCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ripper update
   */
  export type ripperUpdateArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * The data needed to update a ripper.
     */
    data: XOR<ripperUpdateInput, ripperUncheckedUpdateInput>
    /**
     * Choose, which ripper to update.
     */
    where: ripperWhereUniqueInput
  }


  /**
   * ripper updateMany
   */
  export type ripperUpdateManyArgs = {
    /**
     * The data used to update rippers.
     */
    data: XOR<ripperUpdateManyMutationInput, ripperUncheckedUpdateManyInput>
    /**
     * Filter which rippers to update
     */
    where?: ripperWhereInput
  }


  /**
   * ripper upsert
   */
  export type ripperUpsertArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * The filter to search for the ripper to update in case it exists.
     */
    where: ripperWhereUniqueInput
    /**
     * In case the ripper found by the `where` argument doesn't exist, create a new ripper with this data.
     */
    create: XOR<ripperCreateInput, ripperUncheckedCreateInput>
    /**
     * In case the ripper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ripperUpdateInput, ripperUncheckedUpdateInput>
  }


  /**
   * ripper delete
   */
  export type ripperDeleteArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
    /**
     * Filter which ripper to delete.
     */
    where: ripperWhereUniqueInput
  }


  /**
   * ripper deleteMany
   */
  export type ripperDeleteManyArgs = {
    /**
     * Filter which rippers to delete
     */
    where?: ripperWhereInput
  }


  /**
   * ripper.replacement_team_replacement_team_substitute_ripper2_idToripper
   */
  export type ripper$replacement_team_replacement_team_substitute_ripper2_idToripperArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    where?: replacement_teamWhereInput
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    cursor?: replacement_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }


  /**
   * ripper.replacement_team_replacement_team_substitute_ripper1_idToripper
   */
  export type ripper$replacement_team_replacement_team_substitute_ripper1_idToripperArgs = {
    /**
     * Select specific fields to fetch from the replacement_team
     */
    select?: replacement_teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: replacement_teamInclude | null
    where?: replacement_teamWhereInput
    orderBy?: Enumerable<replacement_teamOrderByWithRelationInput>
    cursor?: replacement_teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Replacement_teamScalarFieldEnum>
  }


  /**
   * ripper without action
   */
  export type ripperArgs = {
    /**
     * Select specific fields to fetch from the ripper
     */
    select?: ripperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ripperInclude | null
  }



  /**
   * Model sinister
   */


  export type AggregateSinister = {
    _count: SinisterCountAggregateOutputType | null
    _avg: SinisterAvgAggregateOutputType | null
    _sum: SinisterSumAggregateOutputType | null
    _min: SinisterMinAggregateOutputType | null
    _max: SinisterMaxAggregateOutputType | null
  }

  export type SinisterAvgAggregateOutputType = {
    id: number | null
    truck_id: number | null
    driver_id: number | null
  }

  export type SinisterSumAggregateOutputType = {
    id: number | null
    truck_id: number | null
    driver_id: number | null
  }

  export type SinisterMinAggregateOutputType = {
    id: number | null
    truck_id: number | null
    driver_id: number | null
    date: Date | null
    place: string | null
    opposing_vehicule: string | null
    opposing_driver: string | null
    circumstance: string | null
    status: string | null
    observation: string | null
  }

  export type SinisterMaxAggregateOutputType = {
    id: number | null
    truck_id: number | null
    driver_id: number | null
    date: Date | null
    place: string | null
    opposing_vehicule: string | null
    opposing_driver: string | null
    circumstance: string | null
    status: string | null
    observation: string | null
  }

  export type SinisterCountAggregateOutputType = {
    id: number
    truck_id: number
    driver_id: number
    date: number
    place: number
    opposing_vehicule: number
    opposing_driver: number
    circumstance: number
    status: number
    observation: number
    _all: number
  }


  export type SinisterAvgAggregateInputType = {
    id?: true
    truck_id?: true
    driver_id?: true
  }

  export type SinisterSumAggregateInputType = {
    id?: true
    truck_id?: true
    driver_id?: true
  }

  export type SinisterMinAggregateInputType = {
    id?: true
    truck_id?: true
    driver_id?: true
    date?: true
    place?: true
    opposing_vehicule?: true
    opposing_driver?: true
    circumstance?: true
    status?: true
    observation?: true
  }

  export type SinisterMaxAggregateInputType = {
    id?: true
    truck_id?: true
    driver_id?: true
    date?: true
    place?: true
    opposing_vehicule?: true
    opposing_driver?: true
    circumstance?: true
    status?: true
    observation?: true
  }

  export type SinisterCountAggregateInputType = {
    id?: true
    truck_id?: true
    driver_id?: true
    date?: true
    place?: true
    opposing_vehicule?: true
    opposing_driver?: true
    circumstance?: true
    status?: true
    observation?: true
    _all?: true
  }

  export type SinisterAggregateArgs = {
    /**
     * Filter which sinister to aggregate.
     */
    where?: sinisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sinisters to fetch.
     */
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sinisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sinisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sinisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sinisters
    **/
    _count?: true | SinisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SinisterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SinisterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SinisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SinisterMaxAggregateInputType
  }

  export type GetSinisterAggregateType<T extends SinisterAggregateArgs> = {
        [P in keyof T & keyof AggregateSinister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSinister[P]>
      : GetScalarType<T[P], AggregateSinister[P]>
  }




  export type SinisterGroupByArgs = {
    where?: sinisterWhereInput
    orderBy?: Enumerable<sinisterOrderByWithAggregationInput>
    by: SinisterScalarFieldEnum[]
    having?: sinisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SinisterCountAggregateInputType | true
    _avg?: SinisterAvgAggregateInputType
    _sum?: SinisterSumAggregateInputType
    _min?: SinisterMinAggregateInputType
    _max?: SinisterMaxAggregateInputType
  }


  export type SinisterGroupByOutputType = {
    id: number
    truck_id: number | null
    driver_id: number | null
    date: Date
    place: string
    opposing_vehicule: string | null
    opposing_driver: string | null
    circumstance: string | null
    status: string
    observation: string | null
    _count: SinisterCountAggregateOutputType | null
    _avg: SinisterAvgAggregateOutputType | null
    _sum: SinisterSumAggregateOutputType | null
    _min: SinisterMinAggregateOutputType | null
    _max: SinisterMaxAggregateOutputType | null
  }

  type GetSinisterGroupByPayload<T extends SinisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SinisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SinisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SinisterGroupByOutputType[P]>
            : GetScalarType<T[P], SinisterGroupByOutputType[P]>
        }
      >
    >


  export type sinisterSelect = {
    id?: boolean
    truck_id?: boolean
    driver_id?: boolean
    date?: boolean
    place?: boolean
    opposing_vehicule?: boolean
    opposing_driver?: boolean
    circumstance?: boolean
    status?: boolean
    observation?: boolean
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
  }


  export type sinisterInclude = {
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
  }

  export type sinisterGetPayload<S extends boolean | null | undefined | sinisterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sinister :
    S extends undefined ? never :
    S extends { include: any } & (sinisterArgs | sinisterFindManyArgs)
    ? sinister  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'driver' ? driverGetPayload<S['include'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (sinisterArgs | sinisterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'driver' ? driverGetPayload<S['select'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['select'][P]> | null :  P extends keyof sinister ? sinister[P] : never
  } 
      : sinister


  type sinisterCountArgs = 
    Omit<sinisterFindManyArgs, 'select' | 'include'> & {
      select?: SinisterCountAggregateInputType | true
    }

  export interface sinisterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sinister that matches the filter.
     * @param {sinisterFindUniqueArgs} args - Arguments to find a Sinister
     * @example
     * // Get one Sinister
     * const sinister = await prisma.sinister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sinisterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sinisterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sinister'> extends True ? Prisma__sinisterClient<sinisterGetPayload<T>> : Prisma__sinisterClient<sinisterGetPayload<T> | null, null>

    /**
     * Find one Sinister that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sinisterFindUniqueOrThrowArgs} args - Arguments to find a Sinister
     * @example
     * // Get one Sinister
     * const sinister = await prisma.sinister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sinisterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sinisterFindUniqueOrThrowArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Find the first Sinister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sinisterFindFirstArgs} args - Arguments to find a Sinister
     * @example
     * // Get one Sinister
     * const sinister = await prisma.sinister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sinisterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sinisterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sinister'> extends True ? Prisma__sinisterClient<sinisterGetPayload<T>> : Prisma__sinisterClient<sinisterGetPayload<T> | null, null>

    /**
     * Find the first Sinister that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sinisterFindFirstOrThrowArgs} args - Arguments to find a Sinister
     * @example
     * // Get one Sinister
     * const sinister = await prisma.sinister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sinisterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sinisterFindFirstOrThrowArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Find zero or more Sinisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sinisterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sinisters
     * const sinisters = await prisma.sinister.findMany()
     * 
     * // Get first 10 Sinisters
     * const sinisters = await prisma.sinister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sinisterWithIdOnly = await prisma.sinister.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sinisterFindManyArgs>(
      args?: SelectSubset<T, sinisterFindManyArgs>
    ): Prisma.PrismaPromise<Array<sinisterGetPayload<T>>>

    /**
     * Create a Sinister.
     * @param {sinisterCreateArgs} args - Arguments to create a Sinister.
     * @example
     * // Create one Sinister
     * const Sinister = await prisma.sinister.create({
     *   data: {
     *     // ... data to create a Sinister
     *   }
     * })
     * 
    **/
    create<T extends sinisterCreateArgs>(
      args: SelectSubset<T, sinisterCreateArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Create many Sinisters.
     *     @param {sinisterCreateManyArgs} args - Arguments to create many Sinisters.
     *     @example
     *     // Create many Sinisters
     *     const sinister = await prisma.sinister.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sinisterCreateManyArgs>(
      args?: SelectSubset<T, sinisterCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sinister.
     * @param {sinisterDeleteArgs} args - Arguments to delete one Sinister.
     * @example
     * // Delete one Sinister
     * const Sinister = await prisma.sinister.delete({
     *   where: {
     *     // ... filter to delete one Sinister
     *   }
     * })
     * 
    **/
    delete<T extends sinisterDeleteArgs>(
      args: SelectSubset<T, sinisterDeleteArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Update one Sinister.
     * @param {sinisterUpdateArgs} args - Arguments to update one Sinister.
     * @example
     * // Update one Sinister
     * const sinister = await prisma.sinister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sinisterUpdateArgs>(
      args: SelectSubset<T, sinisterUpdateArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Delete zero or more Sinisters.
     * @param {sinisterDeleteManyArgs} args - Arguments to filter Sinisters to delete.
     * @example
     * // Delete a few Sinisters
     * const { count } = await prisma.sinister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sinisterDeleteManyArgs>(
      args?: SelectSubset<T, sinisterDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sinisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sinisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sinisters
     * const sinister = await prisma.sinister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sinisterUpdateManyArgs>(
      args: SelectSubset<T, sinisterUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sinister.
     * @param {sinisterUpsertArgs} args - Arguments to update or create a Sinister.
     * @example
     * // Update or create a Sinister
     * const sinister = await prisma.sinister.upsert({
     *   create: {
     *     // ... data to create a Sinister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sinister we want to update
     *   }
     * })
    **/
    upsert<T extends sinisterUpsertArgs>(
      args: SelectSubset<T, sinisterUpsertArgs>
    ): Prisma__sinisterClient<sinisterGetPayload<T>>

    /**
     * Count the number of Sinisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sinisterCountArgs} args - Arguments to filter Sinisters to count.
     * @example
     * // Count the number of Sinisters
     * const count = await prisma.sinister.count({
     *   where: {
     *     // ... the filter for the Sinisters we want to count
     *   }
     * })
    **/
    count<T extends sinisterCountArgs>(
      args?: Subset<T, sinisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SinisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sinister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SinisterAggregateArgs>(args: Subset<T, SinisterAggregateArgs>): Prisma.PrismaPromise<GetSinisterAggregateType<T>>

    /**
     * Group by Sinister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SinisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SinisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SinisterGroupByArgs['orderBy'] }
        : { orderBy?: SinisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SinisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSinisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sinister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sinisterClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    driver<T extends driverArgs= {}>(args?: Subset<T, driverArgs>): Prisma__driverClient<driverGetPayload<T> | Null>;

    truck<T extends truckArgs= {}>(args?: Subset<T, truckArgs>): Prisma__truckClient<truckGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sinister base type for findUnique actions
   */
  export type sinisterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter, which sinister to fetch.
     */
    where: sinisterWhereUniqueInput
  }

  /**
   * sinister findUnique
   */
  export interface sinisterFindUniqueArgs extends sinisterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sinister findUniqueOrThrow
   */
  export type sinisterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter, which sinister to fetch.
     */
    where: sinisterWhereUniqueInput
  }


  /**
   * sinister base type for findFirst actions
   */
  export type sinisterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter, which sinister to fetch.
     */
    where?: sinisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sinisters to fetch.
     */
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sinisters.
     */
    cursor?: sinisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sinisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sinisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sinisters.
     */
    distinct?: Enumerable<SinisterScalarFieldEnum>
  }

  /**
   * sinister findFirst
   */
  export interface sinisterFindFirstArgs extends sinisterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sinister findFirstOrThrow
   */
  export type sinisterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter, which sinister to fetch.
     */
    where?: sinisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sinisters to fetch.
     */
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sinisters.
     */
    cursor?: sinisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sinisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sinisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sinisters.
     */
    distinct?: Enumerable<SinisterScalarFieldEnum>
  }


  /**
   * sinister findMany
   */
  export type sinisterFindManyArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter, which sinisters to fetch.
     */
    where?: sinisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sinisters to fetch.
     */
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sinisters.
     */
    cursor?: sinisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sinisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sinisters.
     */
    skip?: number
    distinct?: Enumerable<SinisterScalarFieldEnum>
  }


  /**
   * sinister create
   */
  export type sinisterCreateArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * The data needed to create a sinister.
     */
    data: XOR<sinisterCreateInput, sinisterUncheckedCreateInput>
  }


  /**
   * sinister createMany
   */
  export type sinisterCreateManyArgs = {
    /**
     * The data used to create many sinisters.
     */
    data: Enumerable<sinisterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sinister update
   */
  export type sinisterUpdateArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * The data needed to update a sinister.
     */
    data: XOR<sinisterUpdateInput, sinisterUncheckedUpdateInput>
    /**
     * Choose, which sinister to update.
     */
    where: sinisterWhereUniqueInput
  }


  /**
   * sinister updateMany
   */
  export type sinisterUpdateManyArgs = {
    /**
     * The data used to update sinisters.
     */
    data: XOR<sinisterUpdateManyMutationInput, sinisterUncheckedUpdateManyInput>
    /**
     * Filter which sinisters to update
     */
    where?: sinisterWhereInput
  }


  /**
   * sinister upsert
   */
  export type sinisterUpsertArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * The filter to search for the sinister to update in case it exists.
     */
    where: sinisterWhereUniqueInput
    /**
     * In case the sinister found by the `where` argument doesn't exist, create a new sinister with this data.
     */
    create: XOR<sinisterCreateInput, sinisterUncheckedCreateInput>
    /**
     * In case the sinister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sinisterUpdateInput, sinisterUncheckedUpdateInput>
  }


  /**
   * sinister delete
   */
  export type sinisterDeleteArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    /**
     * Filter which sinister to delete.
     */
    where: sinisterWhereUniqueInput
  }


  /**
   * sinister deleteMany
   */
  export type sinisterDeleteManyArgs = {
    /**
     * Filter which sinisters to delete
     */
    where?: sinisterWhereInput
  }


  /**
   * sinister without action
   */
  export type sinisterArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
  }



  /**
   * Model tablet
   */


  export type AggregateTablet = {
    _count: TabletCountAggregateOutputType | null
    _avg: TabletAvgAggregateOutputType | null
    _sum: TabletSumAggregateOutputType | null
    _min: TabletMinAggregateOutputType | null
    _max: TabletMaxAggregateOutputType | null
  }

  export type TabletAvgAggregateOutputType = {
    id: number | null
  }

  export type TabletSumAggregateOutputType = {
    id: number | null
  }

  export type TabletMinAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type TabletMaxAggregateOutputType = {
    id: number | null
    label: string | null
  }

  export type TabletCountAggregateOutputType = {
    id: number
    label: number
    _all: number
  }


  export type TabletAvgAggregateInputType = {
    id?: true
  }

  export type TabletSumAggregateInputType = {
    id?: true
  }

  export type TabletMinAggregateInputType = {
    id?: true
    label?: true
  }

  export type TabletMaxAggregateInputType = {
    id?: true
    label?: true
  }

  export type TabletCountAggregateInputType = {
    id?: true
    label?: true
    _all?: true
  }

  export type TabletAggregateArgs = {
    /**
     * Filter which tablet to aggregate.
     */
    where?: tabletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablets to fetch.
     */
    orderBy?: Enumerable<tabletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tabletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tablets
    **/
    _count?: true | TabletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TabletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TabletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TabletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TabletMaxAggregateInputType
  }

  export type GetTabletAggregateType<T extends TabletAggregateArgs> = {
        [P in keyof T & keyof AggregateTablet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTablet[P]>
      : GetScalarType<T[P], AggregateTablet[P]>
  }




  export type TabletGroupByArgs = {
    where?: tabletWhereInput
    orderBy?: Enumerable<tabletOrderByWithAggregationInput>
    by: TabletScalarFieldEnum[]
    having?: tabletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TabletCountAggregateInputType | true
    _avg?: TabletAvgAggregateInputType
    _sum?: TabletSumAggregateInputType
    _min?: TabletMinAggregateInputType
    _max?: TabletMaxAggregateInputType
  }


  export type TabletGroupByOutputType = {
    id: number
    label: string
    _count: TabletCountAggregateOutputType | null
    _avg: TabletAvgAggregateOutputType | null
    _sum: TabletSumAggregateOutputType | null
    _min: TabletMinAggregateOutputType | null
    _max: TabletMaxAggregateOutputType | null
  }

  type GetTabletGroupByPayload<T extends TabletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TabletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TabletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TabletGroupByOutputType[P]>
            : GetScalarType<T[P], TabletGroupByOutputType[P]>
        }
      >
    >


  export type tabletSelect = {
    id?: boolean
    label?: boolean
    report?: boolean | tablet$reportArgs
    _count?: boolean | TabletCountOutputTypeArgs
  }


  export type tabletInclude = {
    report?: boolean | tablet$reportArgs
    _count?: boolean | TabletCountOutputTypeArgs
  }

  export type tabletGetPayload<S extends boolean | null | undefined | tabletArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tablet :
    S extends undefined ? never :
    S extends { include: any } & (tabletArgs | tabletFindManyArgs)
    ? tablet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'report' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends '_count' ? TabletCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tabletArgs | tabletFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'report' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends '_count' ? TabletCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tablet ? tablet[P] : never
  } 
      : tablet


  type tabletCountArgs = 
    Omit<tabletFindManyArgs, 'select' | 'include'> & {
      select?: TabletCountAggregateInputType | true
    }

  export interface tabletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tablet that matches the filter.
     * @param {tabletFindUniqueArgs} args - Arguments to find a Tablet
     * @example
     * // Get one Tablet
     * const tablet = await prisma.tablet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tabletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tabletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tablet'> extends True ? Prisma__tabletClient<tabletGetPayload<T>> : Prisma__tabletClient<tabletGetPayload<T> | null, null>

    /**
     * Find one Tablet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tabletFindUniqueOrThrowArgs} args - Arguments to find a Tablet
     * @example
     * // Get one Tablet
     * const tablet = await prisma.tablet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tabletFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tabletFindUniqueOrThrowArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Find the first Tablet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tabletFindFirstArgs} args - Arguments to find a Tablet
     * @example
     * // Get one Tablet
     * const tablet = await prisma.tablet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tabletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tabletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tablet'> extends True ? Prisma__tabletClient<tabletGetPayload<T>> : Prisma__tabletClient<tabletGetPayload<T> | null, null>

    /**
     * Find the first Tablet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tabletFindFirstOrThrowArgs} args - Arguments to find a Tablet
     * @example
     * // Get one Tablet
     * const tablet = await prisma.tablet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tabletFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tabletFindFirstOrThrowArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Find zero or more Tablets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tabletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tablets
     * const tablets = await prisma.tablet.findMany()
     * 
     * // Get first 10 Tablets
     * const tablets = await prisma.tablet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tabletWithIdOnly = await prisma.tablet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tabletFindManyArgs>(
      args?: SelectSubset<T, tabletFindManyArgs>
    ): Prisma.PrismaPromise<Array<tabletGetPayload<T>>>

    /**
     * Create a Tablet.
     * @param {tabletCreateArgs} args - Arguments to create a Tablet.
     * @example
     * // Create one Tablet
     * const Tablet = await prisma.tablet.create({
     *   data: {
     *     // ... data to create a Tablet
     *   }
     * })
     * 
    **/
    create<T extends tabletCreateArgs>(
      args: SelectSubset<T, tabletCreateArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Create many Tablets.
     *     @param {tabletCreateManyArgs} args - Arguments to create many Tablets.
     *     @example
     *     // Create many Tablets
     *     const tablet = await prisma.tablet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tabletCreateManyArgs>(
      args?: SelectSubset<T, tabletCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tablet.
     * @param {tabletDeleteArgs} args - Arguments to delete one Tablet.
     * @example
     * // Delete one Tablet
     * const Tablet = await prisma.tablet.delete({
     *   where: {
     *     // ... filter to delete one Tablet
     *   }
     * })
     * 
    **/
    delete<T extends tabletDeleteArgs>(
      args: SelectSubset<T, tabletDeleteArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Update one Tablet.
     * @param {tabletUpdateArgs} args - Arguments to update one Tablet.
     * @example
     * // Update one Tablet
     * const tablet = await prisma.tablet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tabletUpdateArgs>(
      args: SelectSubset<T, tabletUpdateArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Delete zero or more Tablets.
     * @param {tabletDeleteManyArgs} args - Arguments to filter Tablets to delete.
     * @example
     * // Delete a few Tablets
     * const { count } = await prisma.tablet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tabletDeleteManyArgs>(
      args?: SelectSubset<T, tabletDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tablets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tabletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tablets
     * const tablet = await prisma.tablet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tabletUpdateManyArgs>(
      args: SelectSubset<T, tabletUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tablet.
     * @param {tabletUpsertArgs} args - Arguments to update or create a Tablet.
     * @example
     * // Update or create a Tablet
     * const tablet = await prisma.tablet.upsert({
     *   create: {
     *     // ... data to create a Tablet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tablet we want to update
     *   }
     * })
    **/
    upsert<T extends tabletUpsertArgs>(
      args: SelectSubset<T, tabletUpsertArgs>
    ): Prisma__tabletClient<tabletGetPayload<T>>

    /**
     * Count the number of Tablets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tabletCountArgs} args - Arguments to filter Tablets to count.
     * @example
     * // Count the number of Tablets
     * const count = await prisma.tablet.count({
     *   where: {
     *     // ... the filter for the Tablets we want to count
     *   }
     * })
    **/
    count<T extends tabletCountArgs>(
      args?: Subset<T, tabletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TabletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tablet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TabletAggregateArgs>(args: Subset<T, TabletAggregateArgs>): Prisma.PrismaPromise<GetTabletAggregateType<T>>

    /**
     * Group by Tablet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TabletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TabletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TabletGroupByArgs['orderBy'] }
        : { orderBy?: TabletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TabletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTabletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tablet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tabletClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    report<T extends tablet$reportArgs= {}>(args?: Subset<T, tablet$reportArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tablet base type for findUnique actions
   */
  export type tabletFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter, which tablet to fetch.
     */
    where: tabletWhereUniqueInput
  }

  /**
   * tablet findUnique
   */
  export interface tabletFindUniqueArgs extends tabletFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablet findUniqueOrThrow
   */
  export type tabletFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter, which tablet to fetch.
     */
    where: tabletWhereUniqueInput
  }


  /**
   * tablet base type for findFirst actions
   */
  export type tabletFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter, which tablet to fetch.
     */
    where?: tabletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablets to fetch.
     */
    orderBy?: Enumerable<tabletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablets.
     */
    cursor?: tabletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablets.
     */
    distinct?: Enumerable<TabletScalarFieldEnum>
  }

  /**
   * tablet findFirst
   */
  export interface tabletFindFirstArgs extends tabletFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tablet findFirstOrThrow
   */
  export type tabletFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter, which tablet to fetch.
     */
    where?: tabletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablets to fetch.
     */
    orderBy?: Enumerable<tabletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tablets.
     */
    cursor?: tabletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tablets.
     */
    distinct?: Enumerable<TabletScalarFieldEnum>
  }


  /**
   * tablet findMany
   */
  export type tabletFindManyArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter, which tablets to fetch.
     */
    where?: tabletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tablets to fetch.
     */
    orderBy?: Enumerable<tabletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tablets.
     */
    cursor?: tabletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tablets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tablets.
     */
    skip?: number
    distinct?: Enumerable<TabletScalarFieldEnum>
  }


  /**
   * tablet create
   */
  export type tabletCreateArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * The data needed to create a tablet.
     */
    data: XOR<tabletCreateInput, tabletUncheckedCreateInput>
  }


  /**
   * tablet createMany
   */
  export type tabletCreateManyArgs = {
    /**
     * The data used to create many tablets.
     */
    data: Enumerable<tabletCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tablet update
   */
  export type tabletUpdateArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * The data needed to update a tablet.
     */
    data: XOR<tabletUpdateInput, tabletUncheckedUpdateInput>
    /**
     * Choose, which tablet to update.
     */
    where: tabletWhereUniqueInput
  }


  /**
   * tablet updateMany
   */
  export type tabletUpdateManyArgs = {
    /**
     * The data used to update tablets.
     */
    data: XOR<tabletUpdateManyMutationInput, tabletUncheckedUpdateManyInput>
    /**
     * Filter which tablets to update
     */
    where?: tabletWhereInput
  }


  /**
   * tablet upsert
   */
  export type tabletUpsertArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * The filter to search for the tablet to update in case it exists.
     */
    where: tabletWhereUniqueInput
    /**
     * In case the tablet found by the `where` argument doesn't exist, create a new tablet with this data.
     */
    create: XOR<tabletCreateInput, tabletUncheckedCreateInput>
    /**
     * In case the tablet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tabletUpdateInput, tabletUncheckedUpdateInput>
  }


  /**
   * tablet delete
   */
  export type tabletDeleteArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
    /**
     * Filter which tablet to delete.
     */
    where: tabletWhereUniqueInput
  }


  /**
   * tablet deleteMany
   */
  export type tabletDeleteManyArgs = {
    /**
     * Filter which tablets to delete
     */
    where?: tabletWhereInput
  }


  /**
   * tablet.report
   */
  export type tablet$reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * tablet without action
   */
  export type tabletArgs = {
    /**
     * Select specific fields to fetch from the tablet
     */
    select?: tabletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tabletInclude | null
  }



  /**
   * Model team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    driver_id: number | null
    flux_id: number | null
    ripper1_id: number | null
    ripper2_id: number | null
    truck_id: number | null
    replacement_team_id: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    driver_id: number | null
    flux_id: number | null
    ripper1_id: number | null
    ripper2_id: number | null
    truck_id: number | null
    replacement_team_id: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    driver_id: number | null
    flux_id: number | null
    ripper1_id: number | null
    ripper2_id: number | null
    truck_id: number | null
    replacement_team_id: number | null
    name: string | null
    manual_circuit: string | null
    manual_tablet: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    driver_id: number | null
    flux_id: number | null
    ripper1_id: number | null
    ripper2_id: number | null
    truck_id: number | null
    replacement_team_id: number | null
    name: string | null
    manual_circuit: string | null
    manual_tablet: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    driver_id: number
    flux_id: number
    ripper1_id: number
    ripper2_id: number
    truck_id: number
    replacement_team_id: number
    name: number
    manual_circuit: number
    manual_tablet: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    driver_id?: true
    flux_id?: true
    ripper1_id?: true
    ripper2_id?: true
    truck_id?: true
    replacement_team_id?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    driver_id?: true
    flux_id?: true
    ripper1_id?: true
    ripper2_id?: true
    truck_id?: true
    replacement_team_id?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    driver_id?: true
    flux_id?: true
    ripper1_id?: true
    ripper2_id?: true
    truck_id?: true
    replacement_team_id?: true
    name?: true
    manual_circuit?: true
    manual_tablet?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    driver_id?: true
    flux_id?: true
    ripper1_id?: true
    ripper2_id?: true
    truck_id?: true
    replacement_team_id?: true
    name?: true
    manual_circuit?: true
    manual_tablet?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    driver_id?: true
    flux_id?: true
    ripper1_id?: true
    ripper2_id?: true
    truck_id?: true
    replacement_team_id?: true
    name?: true
    manual_circuit?: true
    manual_tablet?: true
    _all?: true
  }

  export type TeamAggregateArgs = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs = {
    where?: teamWhereInput
    orderBy?: Enumerable<teamOrderByWithAggregationInput>
    by: TeamScalarFieldEnum[]
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: number
    driver_id: number | null
    flux_id: number | null
    ripper1_id: number | null
    ripper2_id: number | null
    truck_id: number | null
    replacement_team_id: number | null
    name: string
    manual_circuit: string | null
    manual_tablet: string | null
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect = {
    id?: boolean
    driver_id?: boolean
    flux_id?: boolean
    ripper1_id?: boolean
    ripper2_id?: boolean
    truck_id?: boolean
    replacement_team_id?: boolean
    name?: boolean
    manual_circuit?: boolean
    manual_tablet?: boolean
    ripper_team_ripper1_idToripper?: boolean | ripperArgs
    ripper_team_ripper2_idToripper?: boolean | ripperArgs
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    replacement_team?: boolean | replacement_teamArgs
  }


  export type teamInclude = {
    ripper_team_ripper1_idToripper?: boolean | ripperArgs
    ripper_team_ripper2_idToripper?: boolean | ripperArgs
    driver?: boolean | driverArgs
    truck?: boolean | truckArgs
    flux?: boolean | fluxArgs
    replacement_team?: boolean | replacement_teamArgs
  }

  export type teamGetPayload<S extends boolean | null | undefined | teamArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? team :
    S extends undefined ? never :
    S extends { include: any } & (teamArgs | teamFindManyArgs)
    ? team  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ripper_team_ripper1_idToripper' ? ripperGetPayload<S['include'][P]> | null :
        P extends 'ripper_team_ripper2_idToripper' ? ripperGetPayload<S['include'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['include'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['include'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['include'][P]> | null :
        P extends 'replacement_team' ? replacement_teamGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (teamArgs | teamFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ripper_team_ripper1_idToripper' ? ripperGetPayload<S['select'][P]> | null :
        P extends 'ripper_team_ripper2_idToripper' ? ripperGetPayload<S['select'][P]> | null :
        P extends 'driver' ? driverGetPayload<S['select'][P]> | null :
        P extends 'truck' ? truckGetPayload<S['select'][P]> | null :
        P extends 'flux' ? fluxGetPayload<S['select'][P]> | null :
        P extends 'replacement_team' ? replacement_teamGetPayload<S['select'][P]> | null :  P extends keyof team ? team[P] : never
  } 
      : team


  type teamCountArgs = 
    Omit<teamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, teamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'team'> extends True ? Prisma__teamClient<teamGetPayload<T>> : Prisma__teamClient<teamGetPayload<T> | null, null>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, teamFindUniqueOrThrowArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, teamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'team'> extends True ? Prisma__teamClient<teamGetPayload<T>> : Prisma__teamClient<teamGetPayload<T> | null, null>

    /**
     * Find the first Team that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, teamFindFirstOrThrowArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends teamFindManyArgs>(
      args?: SelectSubset<T, teamFindManyArgs>
    ): Prisma.PrismaPromise<Array<teamGetPayload<T>>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends teamCreateArgs>(
      args: SelectSubset<T, teamCreateArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Create many Teams.
     *     @param {teamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teamCreateManyArgs>(
      args?: SelectSubset<T, teamCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends teamDeleteArgs>(
      args: SelectSubset<T, teamDeleteArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teamUpdateArgs>(
      args: SelectSubset<T, teamUpdateArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teamDeleteManyArgs>(
      args?: SelectSubset<T, teamDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teamUpdateManyArgs>(
      args: SelectSubset<T, teamUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends teamUpsertArgs>(
      args: SelectSubset<T, teamUpsertArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__teamClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ripper_team_ripper1_idToripper<T extends ripperArgs= {}>(args?: Subset<T, ripperArgs>): Prisma__ripperClient<ripperGetPayload<T> | Null>;

    ripper_team_ripper2_idToripper<T extends ripperArgs= {}>(args?: Subset<T, ripperArgs>): Prisma__ripperClient<ripperGetPayload<T> | Null>;

    driver<T extends driverArgs= {}>(args?: Subset<T, driverArgs>): Prisma__driverClient<driverGetPayload<T> | Null>;

    truck<T extends truckArgs= {}>(args?: Subset<T, truckArgs>): Prisma__truckClient<truckGetPayload<T> | Null>;

    flux<T extends fluxArgs= {}>(args?: Subset<T, fluxArgs>): Prisma__fluxClient<fluxGetPayload<T> | Null>;

    replacement_team<T extends replacement_teamArgs= {}>(args?: Subset<T, replacement_teamArgs>): Prisma__replacement_teamClient<replacement_teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * team base type for findUnique actions
   */
  export type teamFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findUnique
   */
  export interface teamFindUniqueArgs extends teamFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team base type for findFirst actions
   */
  export type teamFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }

  /**
   * team findFirst
   */
  export interface teamFindFirstArgs extends teamFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * team findMany
   */
  export type teamFindManyArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * team create
   */
  export type teamCreateArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }


  /**
   * team createMany
   */
  export type teamCreateManyArgs = {
    /**
     * The data used to create many teams.
     */
    data: Enumerable<teamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * team update
   */
  export type teamUpdateArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team updateMany
   */
  export type teamUpdateManyArgs = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }


  /**
   * team upsert
   */
  export type teamUpsertArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }


  /**
   * team delete
   */
  export type teamDeleteArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }


  /**
   * team without action
   */
  export type teamArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
  }



  /**
   * Model town
   */


  export type AggregateTown = {
    _count: TownCountAggregateOutputType | null
    _avg: TownAvgAggregateOutputType | null
    _sum: TownSumAggregateOutputType | null
    _min: TownMinAggregateOutputType | null
    _max: TownMaxAggregateOutputType | null
  }

  export type TownAvgAggregateOutputType = {
    id: number | null
    circuit_id: number | null
    postal_code: number | null
  }

  export type TownSumAggregateOutputType = {
    id: number | null
    circuit_id: number | null
    postal_code: number | null
  }

  export type TownMinAggregateOutputType = {
    id: number | null
    circuit_id: number | null
    name: string | null
    postal_code: number | null
  }

  export type TownMaxAggregateOutputType = {
    id: number | null
    circuit_id: number | null
    name: string | null
    postal_code: number | null
  }

  export type TownCountAggregateOutputType = {
    id: number
    circuit_id: number
    name: number
    postal_code: number
    _all: number
  }


  export type TownAvgAggregateInputType = {
    id?: true
    circuit_id?: true
    postal_code?: true
  }

  export type TownSumAggregateInputType = {
    id?: true
    circuit_id?: true
    postal_code?: true
  }

  export type TownMinAggregateInputType = {
    id?: true
    circuit_id?: true
    name?: true
    postal_code?: true
  }

  export type TownMaxAggregateInputType = {
    id?: true
    circuit_id?: true
    name?: true
    postal_code?: true
  }

  export type TownCountAggregateInputType = {
    id?: true
    circuit_id?: true
    name?: true
    postal_code?: true
    _all?: true
  }

  export type TownAggregateArgs = {
    /**
     * Filter which town to aggregate.
     */
    where?: townWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: townWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned towns
    **/
    _count?: true | TownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TownMaxAggregateInputType
  }

  export type GetTownAggregateType<T extends TownAggregateArgs> = {
        [P in keyof T & keyof AggregateTown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTown[P]>
      : GetScalarType<T[P], AggregateTown[P]>
  }




  export type TownGroupByArgs = {
    where?: townWhereInput
    orderBy?: Enumerable<townOrderByWithAggregationInput>
    by: TownScalarFieldEnum[]
    having?: townScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TownCountAggregateInputType | true
    _avg?: TownAvgAggregateInputType
    _sum?: TownSumAggregateInputType
    _min?: TownMinAggregateInputType
    _max?: TownMaxAggregateInputType
  }


  export type TownGroupByOutputType = {
    id: number
    circuit_id: number | null
    name: string
    postal_code: number
    _count: TownCountAggregateOutputType | null
    _avg: TownAvgAggregateOutputType | null
    _sum: TownSumAggregateOutputType | null
    _min: TownMinAggregateOutputType | null
    _max: TownMaxAggregateOutputType | null
  }

  type GetTownGroupByPayload<T extends TownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TownGroupByOutputType[P]>
            : GetScalarType<T[P], TownGroupByOutputType[P]>
        }
      >
    >


  export type townSelect = {
    id?: boolean
    circuit_id?: boolean
    name?: boolean
    postal_code?: boolean
    circuit?: boolean | circuitArgs
    way?: boolean | town$wayArgs
    worksite?: boolean | town$worksiteArgs
    _count?: boolean | TownCountOutputTypeArgs
  }


  export type townInclude = {
    circuit?: boolean | circuitArgs
    way?: boolean | town$wayArgs
    worksite?: boolean | town$worksiteArgs
    _count?: boolean | TownCountOutputTypeArgs
  }

  export type townGetPayload<S extends boolean | null | undefined | townArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? town :
    S extends undefined ? never :
    S extends { include: any } & (townArgs | townFindManyArgs)
    ? town  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'circuit' ? circuitGetPayload<S['include'][P]> | null :
        P extends 'way' ? Array < wayGetPayload<S['include'][P]>>  :
        P extends 'worksite' ? Array < worksiteGetPayload<S['include'][P]>>  :
        P extends '_count' ? TownCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (townArgs | townFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'circuit' ? circuitGetPayload<S['select'][P]> | null :
        P extends 'way' ? Array < wayGetPayload<S['select'][P]>>  :
        P extends 'worksite' ? Array < worksiteGetPayload<S['select'][P]>>  :
        P extends '_count' ? TownCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof town ? town[P] : never
  } 
      : town


  type townCountArgs = 
    Omit<townFindManyArgs, 'select' | 'include'> & {
      select?: TownCountAggregateInputType | true
    }

  export interface townDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Town that matches the filter.
     * @param {townFindUniqueArgs} args - Arguments to find a Town
     * @example
     * // Get one Town
     * const town = await prisma.town.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends townFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, townFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'town'> extends True ? Prisma__townClient<townGetPayload<T>> : Prisma__townClient<townGetPayload<T> | null, null>

    /**
     * Find one Town that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {townFindUniqueOrThrowArgs} args - Arguments to find a Town
     * @example
     * // Get one Town
     * const town = await prisma.town.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends townFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, townFindUniqueOrThrowArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Find the first Town that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townFindFirstArgs} args - Arguments to find a Town
     * @example
     * // Get one Town
     * const town = await prisma.town.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends townFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, townFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'town'> extends True ? Prisma__townClient<townGetPayload<T>> : Prisma__townClient<townGetPayload<T> | null, null>

    /**
     * Find the first Town that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townFindFirstOrThrowArgs} args - Arguments to find a Town
     * @example
     * // Get one Town
     * const town = await prisma.town.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends townFindFirstOrThrowArgs>(
      args?: SelectSubset<T, townFindFirstOrThrowArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Find zero or more Towns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Towns
     * const towns = await prisma.town.findMany()
     * 
     * // Get first 10 Towns
     * const towns = await prisma.town.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const townWithIdOnly = await prisma.town.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends townFindManyArgs>(
      args?: SelectSubset<T, townFindManyArgs>
    ): Prisma.PrismaPromise<Array<townGetPayload<T>>>

    /**
     * Create a Town.
     * @param {townCreateArgs} args - Arguments to create a Town.
     * @example
     * // Create one Town
     * const Town = await prisma.town.create({
     *   data: {
     *     // ... data to create a Town
     *   }
     * })
     * 
    **/
    create<T extends townCreateArgs>(
      args: SelectSubset<T, townCreateArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Create many Towns.
     *     @param {townCreateManyArgs} args - Arguments to create many Towns.
     *     @example
     *     // Create many Towns
     *     const town = await prisma.town.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends townCreateManyArgs>(
      args?: SelectSubset<T, townCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Town.
     * @param {townDeleteArgs} args - Arguments to delete one Town.
     * @example
     * // Delete one Town
     * const Town = await prisma.town.delete({
     *   where: {
     *     // ... filter to delete one Town
     *   }
     * })
     * 
    **/
    delete<T extends townDeleteArgs>(
      args: SelectSubset<T, townDeleteArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Update one Town.
     * @param {townUpdateArgs} args - Arguments to update one Town.
     * @example
     * // Update one Town
     * const town = await prisma.town.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends townUpdateArgs>(
      args: SelectSubset<T, townUpdateArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Delete zero or more Towns.
     * @param {townDeleteManyArgs} args - Arguments to filter Towns to delete.
     * @example
     * // Delete a few Towns
     * const { count } = await prisma.town.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends townDeleteManyArgs>(
      args?: SelectSubset<T, townDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Towns
     * const town = await prisma.town.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends townUpdateManyArgs>(
      args: SelectSubset<T, townUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Town.
     * @param {townUpsertArgs} args - Arguments to update or create a Town.
     * @example
     * // Update or create a Town
     * const town = await prisma.town.upsert({
     *   create: {
     *     // ... data to create a Town
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Town we want to update
     *   }
     * })
    **/
    upsert<T extends townUpsertArgs>(
      args: SelectSubset<T, townUpsertArgs>
    ): Prisma__townClient<townGetPayload<T>>

    /**
     * Count the number of Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townCountArgs} args - Arguments to filter Towns to count.
     * @example
     * // Count the number of Towns
     * const count = await prisma.town.count({
     *   where: {
     *     // ... the filter for the Towns we want to count
     *   }
     * })
    **/
    count<T extends townCountArgs>(
      args?: Subset<T, townCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Town.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TownAggregateArgs>(args: Subset<T, TownAggregateArgs>): Prisma.PrismaPromise<GetTownAggregateType<T>>

    /**
     * Group by Town.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TownGroupByArgs['orderBy'] }
        : { orderBy?: TownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for town.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__townClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    circuit<T extends circuitArgs= {}>(args?: Subset<T, circuitArgs>): Prisma__circuitClient<circuitGetPayload<T> | Null>;

    way<T extends town$wayArgs= {}>(args?: Subset<T, town$wayArgs>): Prisma.PrismaPromise<Array<wayGetPayload<T>>| Null>;

    worksite<T extends town$worksiteArgs= {}>(args?: Subset<T, town$worksiteArgs>): Prisma.PrismaPromise<Array<worksiteGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * town base type for findUnique actions
   */
  export type townFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter, which town to fetch.
     */
    where: townWhereUniqueInput
  }

  /**
   * town findUnique
   */
  export interface townFindUniqueArgs extends townFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * town findUniqueOrThrow
   */
  export type townFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter, which town to fetch.
     */
    where: townWhereUniqueInput
  }


  /**
   * town base type for findFirst actions
   */
  export type townFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter, which town to fetch.
     */
    where?: townWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for towns.
     */
    cursor?: townWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of towns.
     */
    distinct?: Enumerable<TownScalarFieldEnum>
  }

  /**
   * town findFirst
   */
  export interface townFindFirstArgs extends townFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * town findFirstOrThrow
   */
  export type townFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter, which town to fetch.
     */
    where?: townWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for towns.
     */
    cursor?: townWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of towns.
     */
    distinct?: Enumerable<TownScalarFieldEnum>
  }


  /**
   * town findMany
   */
  export type townFindManyArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter, which towns to fetch.
     */
    where?: townWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing towns.
     */
    cursor?: townWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    distinct?: Enumerable<TownScalarFieldEnum>
  }


  /**
   * town create
   */
  export type townCreateArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * The data needed to create a town.
     */
    data: XOR<townCreateInput, townUncheckedCreateInput>
  }


  /**
   * town createMany
   */
  export type townCreateManyArgs = {
    /**
     * The data used to create many towns.
     */
    data: Enumerable<townCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * town update
   */
  export type townUpdateArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * The data needed to update a town.
     */
    data: XOR<townUpdateInput, townUncheckedUpdateInput>
    /**
     * Choose, which town to update.
     */
    where: townWhereUniqueInput
  }


  /**
   * town updateMany
   */
  export type townUpdateManyArgs = {
    /**
     * The data used to update towns.
     */
    data: XOR<townUpdateManyMutationInput, townUncheckedUpdateManyInput>
    /**
     * Filter which towns to update
     */
    where?: townWhereInput
  }


  /**
   * town upsert
   */
  export type townUpsertArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * The filter to search for the town to update in case it exists.
     */
    where: townWhereUniqueInput
    /**
     * In case the town found by the `where` argument doesn't exist, create a new town with this data.
     */
    create: XOR<townCreateInput, townUncheckedCreateInput>
    /**
     * In case the town was found with the provided `where` argument, update it with this data.
     */
    update: XOR<townUpdateInput, townUncheckedUpdateInput>
  }


  /**
   * town delete
   */
  export type townDeleteArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
    /**
     * Filter which town to delete.
     */
    where: townWhereUniqueInput
  }


  /**
   * town deleteMany
   */
  export type townDeleteManyArgs = {
    /**
     * Filter which towns to delete
     */
    where?: townWhereInput
  }


  /**
   * town.way
   */
  export type town$wayArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    where?: wayWhereInput
    orderBy?: Enumerable<wayOrderByWithRelationInput>
    cursor?: wayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WayScalarFieldEnum>
  }


  /**
   * town.worksite
   */
  export type town$worksiteArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    where?: worksiteWhereInput
    orderBy?: Enumerable<worksiteOrderByWithRelationInput>
    cursor?: worksiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorksiteScalarFieldEnum>
  }


  /**
   * town without action
   */
  export type townArgs = {
    /**
     * Select specific fields to fetch from the town
     */
    select?: townSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: townInclude | null
  }



  /**
   * Model truck
   */


  export type AggregateTruck = {
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  export type TruckAvgAggregateOutputType = {
    id: number | null
  }

  export type TruckSumAggregateOutputType = {
    id: number | null
  }

  export type TruckMinAggregateOutputType = {
    id: number | null
    registration: string | null
    type: string | null
  }

  export type TruckMaxAggregateOutputType = {
    id: number | null
    registration: string | null
    type: string | null
  }

  export type TruckCountAggregateOutputType = {
    id: number
    registration: number
    type: number
    _all: number
  }


  export type TruckAvgAggregateInputType = {
    id?: true
  }

  export type TruckSumAggregateInputType = {
    id?: true
  }

  export type TruckMinAggregateInputType = {
    id?: true
    registration?: true
    type?: true
  }

  export type TruckMaxAggregateInputType = {
    id?: true
    registration?: true
    type?: true
  }

  export type TruckCountAggregateInputType = {
    id?: true
    registration?: true
    type?: true
    _all?: true
  }

  export type TruckAggregateArgs = {
    /**
     * Filter which truck to aggregate.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: Enumerable<truckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trucks
    **/
    _count?: true | TruckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TruckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TruckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckMaxAggregateInputType
  }

  export type GetTruckAggregateType<T extends TruckAggregateArgs> = {
        [P in keyof T & keyof AggregateTruck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruck[P]>
      : GetScalarType<T[P], AggregateTruck[P]>
  }




  export type TruckGroupByArgs = {
    where?: truckWhereInput
    orderBy?: Enumerable<truckOrderByWithAggregationInput>
    by: TruckScalarFieldEnum[]
    having?: truckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckCountAggregateInputType | true
    _avg?: TruckAvgAggregateInputType
    _sum?: TruckSumAggregateInputType
    _min?: TruckMinAggregateInputType
    _max?: TruckMaxAggregateInputType
  }


  export type TruckGroupByOutputType = {
    id: number
    registration: string
    type: string | null
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  type GetTruckGroupByPayload<T extends TruckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TruckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckGroupByOutputType[P]>
            : GetScalarType<T[P], TruckGroupByOutputType[P]>
        }
      >
    >


  export type truckSelect = {
    id?: boolean
    registration?: boolean
    type?: boolean
    container_mouvement?: boolean | truck$container_mouvementArgs
    report?: boolean | truck$reportArgs
    sinister?: boolean | truck$sinisterArgs
    team?: boolean | truck$teamArgs
    _count?: boolean | TruckCountOutputTypeArgs
  }


  export type truckInclude = {
    container_mouvement?: boolean | truck$container_mouvementArgs
    report?: boolean | truck$reportArgs
    sinister?: boolean | truck$sinisterArgs
    team?: boolean | truck$teamArgs
    _count?: boolean | TruckCountOutputTypeArgs
  }

  export type truckGetPayload<S extends boolean | null | undefined | truckArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? truck :
    S extends undefined ? never :
    S extends { include: any } & (truckArgs | truckFindManyArgs)
    ? truck  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'sinister' ? Array < sinisterGetPayload<S['include'][P]>>  :
        P extends 'team' ? Array < teamGetPayload<S['include'][P]>>  :
        P extends '_count' ? TruckCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (truckArgs | truckFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends 'report' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'sinister' ? Array < sinisterGetPayload<S['select'][P]>>  :
        P extends 'team' ? Array < teamGetPayload<S['select'][P]>>  :
        P extends '_count' ? TruckCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof truck ? truck[P] : never
  } 
      : truck


  type truckCountArgs = 
    Omit<truckFindManyArgs, 'select' | 'include'> & {
      select?: TruckCountAggregateInputType | true
    }

  export interface truckDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Truck that matches the filter.
     * @param {truckFindUniqueArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends truckFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, truckFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'truck'> extends True ? Prisma__truckClient<truckGetPayload<T>> : Prisma__truckClient<truckGetPayload<T> | null, null>

    /**
     * Find one Truck that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {truckFindUniqueOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends truckFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, truckFindUniqueOrThrowArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Find the first Truck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindFirstArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends truckFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, truckFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'truck'> extends True ? Prisma__truckClient<truckGetPayload<T>> : Prisma__truckClient<truckGetPayload<T> | null, null>

    /**
     * Find the first Truck that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindFirstOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends truckFindFirstOrThrowArgs>(
      args?: SelectSubset<T, truckFindFirstOrThrowArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.truck.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.truck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const truckWithIdOnly = await prisma.truck.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends truckFindManyArgs>(
      args?: SelectSubset<T, truckFindManyArgs>
    ): Prisma.PrismaPromise<Array<truckGetPayload<T>>>

    /**
     * Create a Truck.
     * @param {truckCreateArgs} args - Arguments to create a Truck.
     * @example
     * // Create one Truck
     * const Truck = await prisma.truck.create({
     *   data: {
     *     // ... data to create a Truck
     *   }
     * })
     * 
    **/
    create<T extends truckCreateArgs>(
      args: SelectSubset<T, truckCreateArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Create many Trucks.
     *     @param {truckCreateManyArgs} args - Arguments to create many Trucks.
     *     @example
     *     // Create many Trucks
     *     const truck = await prisma.truck.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends truckCreateManyArgs>(
      args?: SelectSubset<T, truckCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Truck.
     * @param {truckDeleteArgs} args - Arguments to delete one Truck.
     * @example
     * // Delete one Truck
     * const Truck = await prisma.truck.delete({
     *   where: {
     *     // ... filter to delete one Truck
     *   }
     * })
     * 
    **/
    delete<T extends truckDeleteArgs>(
      args: SelectSubset<T, truckDeleteArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Update one Truck.
     * @param {truckUpdateArgs} args - Arguments to update one Truck.
     * @example
     * // Update one Truck
     * const truck = await prisma.truck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends truckUpdateArgs>(
      args: SelectSubset<T, truckUpdateArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Delete zero or more Trucks.
     * @param {truckDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.truck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends truckDeleteManyArgs>(
      args?: SelectSubset<T, truckDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const truck = await prisma.truck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends truckUpdateManyArgs>(
      args: SelectSubset<T, truckUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Truck.
     * @param {truckUpsertArgs} args - Arguments to update or create a Truck.
     * @example
     * // Update or create a Truck
     * const truck = await prisma.truck.upsert({
     *   create: {
     *     // ... data to create a Truck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Truck we want to update
     *   }
     * })
    **/
    upsert<T extends truckUpsertArgs>(
      args: SelectSubset<T, truckUpsertArgs>
    ): Prisma__truckClient<truckGetPayload<T>>

    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.truck.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends truckCountArgs>(
      args?: Subset<T, truckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckAggregateArgs>(args: Subset<T, TruckAggregateArgs>): Prisma.PrismaPromise<GetTruckAggregateType<T>>

    /**
     * Group by Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TruckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TruckGroupByArgs['orderBy'] }
        : { orderBy?: TruckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TruckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for truck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__truckClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends truck$container_mouvementArgs= {}>(args?: Subset<T, truck$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    report<T extends truck$reportArgs= {}>(args?: Subset<T, truck$reportArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    sinister<T extends truck$sinisterArgs= {}>(args?: Subset<T, truck$sinisterArgs>): Prisma.PrismaPromise<Array<sinisterGetPayload<T>>| Null>;

    team<T extends truck$teamArgs= {}>(args?: Subset<T, truck$teamArgs>): Prisma.PrismaPromise<Array<teamGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * truck base type for findUnique actions
   */
  export type truckFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter, which truck to fetch.
     */
    where: truckWhereUniqueInput
  }

  /**
   * truck findUnique
   */
  export interface truckFindUniqueArgs extends truckFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * truck findUniqueOrThrow
   */
  export type truckFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter, which truck to fetch.
     */
    where: truckWhereUniqueInput
  }


  /**
   * truck base type for findFirst actions
   */
  export type truckFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter, which truck to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: Enumerable<truckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: Enumerable<TruckScalarFieldEnum>
  }

  /**
   * truck findFirst
   */
  export interface truckFindFirstArgs extends truckFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * truck findFirstOrThrow
   */
  export type truckFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter, which truck to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: Enumerable<truckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: Enumerable<TruckScalarFieldEnum>
  }


  /**
   * truck findMany
   */
  export type truckFindManyArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter, which trucks to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: Enumerable<truckOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    distinct?: Enumerable<TruckScalarFieldEnum>
  }


  /**
   * truck create
   */
  export type truckCreateArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * The data needed to create a truck.
     */
    data: XOR<truckCreateInput, truckUncheckedCreateInput>
  }


  /**
   * truck createMany
   */
  export type truckCreateManyArgs = {
    /**
     * The data used to create many trucks.
     */
    data: Enumerable<truckCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * truck update
   */
  export type truckUpdateArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * The data needed to update a truck.
     */
    data: XOR<truckUpdateInput, truckUncheckedUpdateInput>
    /**
     * Choose, which truck to update.
     */
    where: truckWhereUniqueInput
  }


  /**
   * truck updateMany
   */
  export type truckUpdateManyArgs = {
    /**
     * The data used to update trucks.
     */
    data: XOR<truckUpdateManyMutationInput, truckUncheckedUpdateManyInput>
    /**
     * Filter which trucks to update
     */
    where?: truckWhereInput
  }


  /**
   * truck upsert
   */
  export type truckUpsertArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * The filter to search for the truck to update in case it exists.
     */
    where: truckWhereUniqueInput
    /**
     * In case the truck found by the `where` argument doesn't exist, create a new truck with this data.
     */
    create: XOR<truckCreateInput, truckUncheckedCreateInput>
    /**
     * In case the truck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<truckUpdateInput, truckUncheckedUpdateInput>
  }


  /**
   * truck delete
   */
  export type truckDeleteArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
    /**
     * Filter which truck to delete.
     */
    where: truckWhereUniqueInput
  }


  /**
   * truck deleteMany
   */
  export type truckDeleteManyArgs = {
    /**
     * Filter which trucks to delete
     */
    where?: truckWhereInput
  }


  /**
   * truck.container_mouvement
   */
  export type truck$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * truck.report
   */
  export type truck$reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * truck.sinister
   */
  export type truck$sinisterArgs = {
    /**
     * Select specific fields to fetch from the sinister
     */
    select?: sinisterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sinisterInclude | null
    where?: sinisterWhereInput
    orderBy?: Enumerable<sinisterOrderByWithRelationInput>
    cursor?: sinisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SinisterScalarFieldEnum>
  }


  /**
   * truck.team
   */
  export type truck$teamArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    where?: teamWhereInput
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * truck without action
   */
  export type truckArgs = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: truckInclude | null
  }



  /**
   * Model type_anomaly
   */


  export type AggregateType_anomaly = {
    _count: Type_anomalyCountAggregateOutputType | null
    _avg: Type_anomalyAvgAggregateOutputType | null
    _sum: Type_anomalySumAggregateOutputType | null
    _min: Type_anomalyMinAggregateOutputType | null
    _max: Type_anomalyMaxAggregateOutputType | null
  }

  export type Type_anomalyAvgAggregateOutputType = {
    id: number | null
  }

  export type Type_anomalySumAggregateOutputType = {
    id: number | null
  }

  export type Type_anomalyMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_anomalyMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_anomalyCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Type_anomalyAvgAggregateInputType = {
    id?: true
  }

  export type Type_anomalySumAggregateInputType = {
    id?: true
  }

  export type Type_anomalyMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_anomalyMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_anomalyCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Type_anomalyAggregateArgs = {
    /**
     * Filter which type_anomaly to aggregate.
     */
    where?: type_anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_anomalies to fetch.
     */
    orderBy?: Enumerable<type_anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_anomalies
    **/
    _count?: true | Type_anomalyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Type_anomalyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Type_anomalySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_anomalyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_anomalyMaxAggregateInputType
  }

  export type GetType_anomalyAggregateType<T extends Type_anomalyAggregateArgs> = {
        [P in keyof T & keyof AggregateType_anomaly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_anomaly[P]>
      : GetScalarType<T[P], AggregateType_anomaly[P]>
  }




  export type Type_anomalyGroupByArgs = {
    where?: type_anomalyWhereInput
    orderBy?: Enumerable<type_anomalyOrderByWithAggregationInput>
    by: Type_anomalyScalarFieldEnum[]
    having?: type_anomalyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_anomalyCountAggregateInputType | true
    _avg?: Type_anomalyAvgAggregateInputType
    _sum?: Type_anomalySumAggregateInputType
    _min?: Type_anomalyMinAggregateInputType
    _max?: Type_anomalyMaxAggregateInputType
  }


  export type Type_anomalyGroupByOutputType = {
    id: number
    name: string
    _count: Type_anomalyCountAggregateOutputType | null
    _avg: Type_anomalyAvgAggregateOutputType | null
    _sum: Type_anomalySumAggregateOutputType | null
    _min: Type_anomalyMinAggregateOutputType | null
    _max: Type_anomalyMaxAggregateOutputType | null
  }

  type GetType_anomalyGroupByPayload<T extends Type_anomalyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Type_anomalyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_anomalyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_anomalyGroupByOutputType[P]>
            : GetScalarType<T[P], Type_anomalyGroupByOutputType[P]>
        }
      >
    >


  export type type_anomalySelect = {
    id?: boolean
    name?: boolean
    anomaly?: boolean | type_anomaly$anomalyArgs
    _count?: boolean | Type_anomalyCountOutputTypeArgs
  }


  export type type_anomalyInclude = {
    anomaly?: boolean | type_anomaly$anomalyArgs
    _count?: boolean | Type_anomalyCountOutputTypeArgs
  }

  export type type_anomalyGetPayload<S extends boolean | null | undefined | type_anomalyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? type_anomaly :
    S extends undefined ? never :
    S extends { include: any } & (type_anomalyArgs | type_anomalyFindManyArgs)
    ? type_anomaly  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['include'][P]>>  :
        P extends '_count' ? Type_anomalyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (type_anomalyArgs | type_anomalyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['select'][P]>>  :
        P extends '_count' ? Type_anomalyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof type_anomaly ? type_anomaly[P] : never
  } 
      : type_anomaly


  type type_anomalyCountArgs = 
    Omit<type_anomalyFindManyArgs, 'select' | 'include'> & {
      select?: Type_anomalyCountAggregateInputType | true
    }

  export interface type_anomalyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Type_anomaly that matches the filter.
     * @param {type_anomalyFindUniqueArgs} args - Arguments to find a Type_anomaly
     * @example
     * // Get one Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends type_anomalyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, type_anomalyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'type_anomaly'> extends True ? Prisma__type_anomalyClient<type_anomalyGetPayload<T>> : Prisma__type_anomalyClient<type_anomalyGetPayload<T> | null, null>

    /**
     * Find one Type_anomaly that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {type_anomalyFindUniqueOrThrowArgs} args - Arguments to find a Type_anomaly
     * @example
     * // Get one Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends type_anomalyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, type_anomalyFindUniqueOrThrowArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Find the first Type_anomaly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_anomalyFindFirstArgs} args - Arguments to find a Type_anomaly
     * @example
     * // Get one Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends type_anomalyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, type_anomalyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'type_anomaly'> extends True ? Prisma__type_anomalyClient<type_anomalyGetPayload<T>> : Prisma__type_anomalyClient<type_anomalyGetPayload<T> | null, null>

    /**
     * Find the first Type_anomaly that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_anomalyFindFirstOrThrowArgs} args - Arguments to find a Type_anomaly
     * @example
     * // Get one Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends type_anomalyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, type_anomalyFindFirstOrThrowArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Find zero or more Type_anomalies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_anomalyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_anomalies
     * const type_anomalies = await prisma.type_anomaly.findMany()
     * 
     * // Get first 10 Type_anomalies
     * const type_anomalies = await prisma.type_anomaly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const type_anomalyWithIdOnly = await prisma.type_anomaly.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends type_anomalyFindManyArgs>(
      args?: SelectSubset<T, type_anomalyFindManyArgs>
    ): Prisma.PrismaPromise<Array<type_anomalyGetPayload<T>>>

    /**
     * Create a Type_anomaly.
     * @param {type_anomalyCreateArgs} args - Arguments to create a Type_anomaly.
     * @example
     * // Create one Type_anomaly
     * const Type_anomaly = await prisma.type_anomaly.create({
     *   data: {
     *     // ... data to create a Type_anomaly
     *   }
     * })
     * 
    **/
    create<T extends type_anomalyCreateArgs>(
      args: SelectSubset<T, type_anomalyCreateArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Create many Type_anomalies.
     *     @param {type_anomalyCreateManyArgs} args - Arguments to create many Type_anomalies.
     *     @example
     *     // Create many Type_anomalies
     *     const type_anomaly = await prisma.type_anomaly.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends type_anomalyCreateManyArgs>(
      args?: SelectSubset<T, type_anomalyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type_anomaly.
     * @param {type_anomalyDeleteArgs} args - Arguments to delete one Type_anomaly.
     * @example
     * // Delete one Type_anomaly
     * const Type_anomaly = await prisma.type_anomaly.delete({
     *   where: {
     *     // ... filter to delete one Type_anomaly
     *   }
     * })
     * 
    **/
    delete<T extends type_anomalyDeleteArgs>(
      args: SelectSubset<T, type_anomalyDeleteArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Update one Type_anomaly.
     * @param {type_anomalyUpdateArgs} args - Arguments to update one Type_anomaly.
     * @example
     * // Update one Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends type_anomalyUpdateArgs>(
      args: SelectSubset<T, type_anomalyUpdateArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Delete zero or more Type_anomalies.
     * @param {type_anomalyDeleteManyArgs} args - Arguments to filter Type_anomalies to delete.
     * @example
     * // Delete a few Type_anomalies
     * const { count } = await prisma.type_anomaly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends type_anomalyDeleteManyArgs>(
      args?: SelectSubset<T, type_anomalyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_anomalyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_anomalies
     * const type_anomaly = await prisma.type_anomaly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends type_anomalyUpdateManyArgs>(
      args: SelectSubset<T, type_anomalyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type_anomaly.
     * @param {type_anomalyUpsertArgs} args - Arguments to update or create a Type_anomaly.
     * @example
     * // Update or create a Type_anomaly
     * const type_anomaly = await prisma.type_anomaly.upsert({
     *   create: {
     *     // ... data to create a Type_anomaly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_anomaly we want to update
     *   }
     * })
    **/
    upsert<T extends type_anomalyUpsertArgs>(
      args: SelectSubset<T, type_anomalyUpsertArgs>
    ): Prisma__type_anomalyClient<type_anomalyGetPayload<T>>

    /**
     * Count the number of Type_anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_anomalyCountArgs} args - Arguments to filter Type_anomalies to count.
     * @example
     * // Count the number of Type_anomalies
     * const count = await prisma.type_anomaly.count({
     *   where: {
     *     // ... the filter for the Type_anomalies we want to count
     *   }
     * })
    **/
    count<T extends type_anomalyCountArgs>(
      args?: Subset<T, type_anomalyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_anomalyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_anomalyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_anomalyAggregateArgs>(args: Subset<T, Type_anomalyAggregateArgs>): Prisma.PrismaPromise<GetType_anomalyAggregateType<T>>

    /**
     * Group by Type_anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_anomalyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Type_anomalyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Type_anomalyGroupByArgs['orderBy'] }
        : { orderBy?: Type_anomalyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Type_anomalyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_anomalyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for type_anomaly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__type_anomalyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    anomaly<T extends type_anomaly$anomalyArgs= {}>(args?: Subset<T, type_anomaly$anomalyArgs>): Prisma.PrismaPromise<Array<anomalyGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * type_anomaly base type for findUnique actions
   */
  export type type_anomalyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter, which type_anomaly to fetch.
     */
    where: type_anomalyWhereUniqueInput
  }

  /**
   * type_anomaly findUnique
   */
  export interface type_anomalyFindUniqueArgs extends type_anomalyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * type_anomaly findUniqueOrThrow
   */
  export type type_anomalyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter, which type_anomaly to fetch.
     */
    where: type_anomalyWhereUniqueInput
  }


  /**
   * type_anomaly base type for findFirst actions
   */
  export type type_anomalyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter, which type_anomaly to fetch.
     */
    where?: type_anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_anomalies to fetch.
     */
    orderBy?: Enumerable<type_anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_anomalies.
     */
    cursor?: type_anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_anomalies.
     */
    distinct?: Enumerable<Type_anomalyScalarFieldEnum>
  }

  /**
   * type_anomaly findFirst
   */
  export interface type_anomalyFindFirstArgs extends type_anomalyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * type_anomaly findFirstOrThrow
   */
  export type type_anomalyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter, which type_anomaly to fetch.
     */
    where?: type_anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_anomalies to fetch.
     */
    orderBy?: Enumerable<type_anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_anomalies.
     */
    cursor?: type_anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_anomalies.
     */
    distinct?: Enumerable<Type_anomalyScalarFieldEnum>
  }


  /**
   * type_anomaly findMany
   */
  export type type_anomalyFindManyArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter, which type_anomalies to fetch.
     */
    where?: type_anomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_anomalies to fetch.
     */
    orderBy?: Enumerable<type_anomalyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_anomalies.
     */
    cursor?: type_anomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_anomalies.
     */
    skip?: number
    distinct?: Enumerable<Type_anomalyScalarFieldEnum>
  }


  /**
   * type_anomaly create
   */
  export type type_anomalyCreateArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * The data needed to create a type_anomaly.
     */
    data: XOR<type_anomalyCreateInput, type_anomalyUncheckedCreateInput>
  }


  /**
   * type_anomaly createMany
   */
  export type type_anomalyCreateManyArgs = {
    /**
     * The data used to create many type_anomalies.
     */
    data: Enumerable<type_anomalyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * type_anomaly update
   */
  export type type_anomalyUpdateArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * The data needed to update a type_anomaly.
     */
    data: XOR<type_anomalyUpdateInput, type_anomalyUncheckedUpdateInput>
    /**
     * Choose, which type_anomaly to update.
     */
    where: type_anomalyWhereUniqueInput
  }


  /**
   * type_anomaly updateMany
   */
  export type type_anomalyUpdateManyArgs = {
    /**
     * The data used to update type_anomalies.
     */
    data: XOR<type_anomalyUpdateManyMutationInput, type_anomalyUncheckedUpdateManyInput>
    /**
     * Filter which type_anomalies to update
     */
    where?: type_anomalyWhereInput
  }


  /**
   * type_anomaly upsert
   */
  export type type_anomalyUpsertArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * The filter to search for the type_anomaly to update in case it exists.
     */
    where: type_anomalyWhereUniqueInput
    /**
     * In case the type_anomaly found by the `where` argument doesn't exist, create a new type_anomaly with this data.
     */
    create: XOR<type_anomalyCreateInput, type_anomalyUncheckedCreateInput>
    /**
     * In case the type_anomaly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_anomalyUpdateInput, type_anomalyUncheckedUpdateInput>
  }


  /**
   * type_anomaly delete
   */
  export type type_anomalyDeleteArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
    /**
     * Filter which type_anomaly to delete.
     */
    where: type_anomalyWhereUniqueInput
  }


  /**
   * type_anomaly deleteMany
   */
  export type type_anomalyDeleteManyArgs = {
    /**
     * Filter which type_anomalies to delete
     */
    where?: type_anomalyWhereInput
  }


  /**
   * type_anomaly.anomaly
   */
  export type type_anomaly$anomalyArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    where?: anomalyWhereInput
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    cursor?: anomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }


  /**
   * type_anomaly without action
   */
  export type type_anomalyArgs = {
    /**
     * Select specific fields to fetch from the type_anomaly
     */
    select?: type_anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_anomalyInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    refresh_token: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    refresh_token: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    roles: number
    password: number
    refresh_token: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    refresh_token?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    refresh_token?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    roles?: true
    password?: true
    refresh_token?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    roles: JsonValue
    password: string
    refresh_token: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect = {
    id?: boolean
    email?: boolean
    roles?: boolean
    password?: boolean
    refresh_token?: boolean
  }


  export type userGetPayload<S extends boolean | null | undefined | userArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user :
    S extends undefined ? never :
    S extends { include: any } & (userArgs | userFindManyArgs)
    ? user 
    : S extends { select: any } & (userArgs | userFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof user ? user[P] : never
  } 
      : user


  type userCountArgs = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): Prisma.PrismaPromise<Array<userGetPayload<T>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs>(
      args?: SelectSubset<T, userCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUnique
   */
  export interface userFindUniqueArgs extends userFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user findFirst
   */
  export interface userFindFirstArgs extends userFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
  }



  /**
   * Model way
   */


  export type AggregateWay = {
    _count: WayCountAggregateOutputType | null
    _avg: WayAvgAggregateOutputType | null
    _sum: WaySumAggregateOutputType | null
    _min: WayMinAggregateOutputType | null
    _max: WayMaxAggregateOutputType | null
  }

  export type WayAvgAggregateOutputType = {
    id: number | null
    town_id: number | null
  }

  export type WaySumAggregateOutputType = {
    id: number | null
    town_id: number | null
  }

  export type WayMinAggregateOutputType = {
    id: number | null
    town_id: number | null
    name: string | null
    type: string | null
  }

  export type WayMaxAggregateOutputType = {
    id: number | null
    town_id: number | null
    name: string | null
    type: string | null
  }

  export type WayCountAggregateOutputType = {
    id: number
    town_id: number
    name: number
    type: number
    _all: number
  }


  export type WayAvgAggregateInputType = {
    id?: true
    town_id?: true
  }

  export type WaySumAggregateInputType = {
    id?: true
    town_id?: true
  }

  export type WayMinAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    type?: true
  }

  export type WayMaxAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    type?: true
  }

  export type WayCountAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    type?: true
    _all?: true
  }

  export type WayAggregateArgs = {
    /**
     * Filter which way to aggregate.
     */
    where?: wayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ways to fetch.
     */
    orderBy?: Enumerable<wayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ways
    **/
    _count?: true | WayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WayMaxAggregateInputType
  }

  export type GetWayAggregateType<T extends WayAggregateArgs> = {
        [P in keyof T & keyof AggregateWay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWay[P]>
      : GetScalarType<T[P], AggregateWay[P]>
  }




  export type WayGroupByArgs = {
    where?: wayWhereInput
    orderBy?: Enumerable<wayOrderByWithAggregationInput>
    by: WayScalarFieldEnum[]
    having?: wayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WayCountAggregateInputType | true
    _avg?: WayAvgAggregateInputType
    _sum?: WaySumAggregateInputType
    _min?: WayMinAggregateInputType
    _max?: WayMaxAggregateInputType
  }


  export type WayGroupByOutputType = {
    id: number
    town_id: number | null
    name: string
    type: string | null
    _count: WayCountAggregateOutputType | null
    _avg: WayAvgAggregateOutputType | null
    _sum: WaySumAggregateOutputType | null
    _min: WayMinAggregateOutputType | null
    _max: WayMaxAggregateOutputType | null
  }

  type GetWayGroupByPayload<T extends WayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WayGroupByOutputType[P]>
            : GetScalarType<T[P], WayGroupByOutputType[P]>
        }
      >
    >


  export type waySelect = {
    id?: boolean
    town_id?: boolean
    name?: boolean
    type?: boolean
    anomaly?: boolean | way$anomalyArgs
    town?: boolean | townArgs
    _count?: boolean | WayCountOutputTypeArgs
  }


  export type wayInclude = {
    anomaly?: boolean | way$anomalyArgs
    town?: boolean | townArgs
    _count?: boolean | WayCountOutputTypeArgs
  }

  export type wayGetPayload<S extends boolean | null | undefined | wayArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? way :
    S extends undefined ? never :
    S extends { include: any } & (wayArgs | wayFindManyArgs)
    ? way  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['include'][P]>>  :
        P extends 'town' ? townGetPayload<S['include'][P]> | null :
        P extends '_count' ? WayCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (wayArgs | wayFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'anomaly' ? Array < anomalyGetPayload<S['select'][P]>>  :
        P extends 'town' ? townGetPayload<S['select'][P]> | null :
        P extends '_count' ? WayCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof way ? way[P] : never
  } 
      : way


  type wayCountArgs = 
    Omit<wayFindManyArgs, 'select' | 'include'> & {
      select?: WayCountAggregateInputType | true
    }

  export interface wayDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Way that matches the filter.
     * @param {wayFindUniqueArgs} args - Arguments to find a Way
     * @example
     * // Get one Way
     * const way = await prisma.way.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, wayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'way'> extends True ? Prisma__wayClient<wayGetPayload<T>> : Prisma__wayClient<wayGetPayload<T> | null, null>

    /**
     * Find one Way that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {wayFindUniqueOrThrowArgs} args - Arguments to find a Way
     * @example
     * // Get one Way
     * const way = await prisma.way.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends wayFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, wayFindUniqueOrThrowArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Find the first Way that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wayFindFirstArgs} args - Arguments to find a Way
     * @example
     * // Get one Way
     * const way = await prisma.way.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, wayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'way'> extends True ? Prisma__wayClient<wayGetPayload<T>> : Prisma__wayClient<wayGetPayload<T> | null, null>

    /**
     * Find the first Way that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wayFindFirstOrThrowArgs} args - Arguments to find a Way
     * @example
     * // Get one Way
     * const way = await prisma.way.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends wayFindFirstOrThrowArgs>(
      args?: SelectSubset<T, wayFindFirstOrThrowArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Find zero or more Ways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ways
     * const ways = await prisma.way.findMany()
     * 
     * // Get first 10 Ways
     * const ways = await prisma.way.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wayWithIdOnly = await prisma.way.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wayFindManyArgs>(
      args?: SelectSubset<T, wayFindManyArgs>
    ): Prisma.PrismaPromise<Array<wayGetPayload<T>>>

    /**
     * Create a Way.
     * @param {wayCreateArgs} args - Arguments to create a Way.
     * @example
     * // Create one Way
     * const Way = await prisma.way.create({
     *   data: {
     *     // ... data to create a Way
     *   }
     * })
     * 
    **/
    create<T extends wayCreateArgs>(
      args: SelectSubset<T, wayCreateArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Create many Ways.
     *     @param {wayCreateManyArgs} args - Arguments to create many Ways.
     *     @example
     *     // Create many Ways
     *     const way = await prisma.way.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends wayCreateManyArgs>(
      args?: SelectSubset<T, wayCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Way.
     * @param {wayDeleteArgs} args - Arguments to delete one Way.
     * @example
     * // Delete one Way
     * const Way = await prisma.way.delete({
     *   where: {
     *     // ... filter to delete one Way
     *   }
     * })
     * 
    **/
    delete<T extends wayDeleteArgs>(
      args: SelectSubset<T, wayDeleteArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Update one Way.
     * @param {wayUpdateArgs} args - Arguments to update one Way.
     * @example
     * // Update one Way
     * const way = await prisma.way.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wayUpdateArgs>(
      args: SelectSubset<T, wayUpdateArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Delete zero or more Ways.
     * @param {wayDeleteManyArgs} args - Arguments to filter Ways to delete.
     * @example
     * // Delete a few Ways
     * const { count } = await prisma.way.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wayDeleteManyArgs>(
      args?: SelectSubset<T, wayDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ways
     * const way = await prisma.way.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wayUpdateManyArgs>(
      args: SelectSubset<T, wayUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Way.
     * @param {wayUpsertArgs} args - Arguments to update or create a Way.
     * @example
     * // Update or create a Way
     * const way = await prisma.way.upsert({
     *   create: {
     *     // ... data to create a Way
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Way we want to update
     *   }
     * })
    **/
    upsert<T extends wayUpsertArgs>(
      args: SelectSubset<T, wayUpsertArgs>
    ): Prisma__wayClient<wayGetPayload<T>>

    /**
     * Count the number of Ways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wayCountArgs} args - Arguments to filter Ways to count.
     * @example
     * // Count the number of Ways
     * const count = await prisma.way.count({
     *   where: {
     *     // ... the filter for the Ways we want to count
     *   }
     * })
    **/
    count<T extends wayCountArgs>(
      args?: Subset<T, wayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Way.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WayAggregateArgs>(args: Subset<T, WayAggregateArgs>): Prisma.PrismaPromise<GetWayAggregateType<T>>

    /**
     * Group by Way.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WayGroupByArgs['orderBy'] }
        : { orderBy?: WayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for way.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wayClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    anomaly<T extends way$anomalyArgs= {}>(args?: Subset<T, way$anomalyArgs>): Prisma.PrismaPromise<Array<anomalyGetPayload<T>>| Null>;

    town<T extends townArgs= {}>(args?: Subset<T, townArgs>): Prisma__townClient<townGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * way base type for findUnique actions
   */
  export type wayFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter, which way to fetch.
     */
    where: wayWhereUniqueInput
  }

  /**
   * way findUnique
   */
  export interface wayFindUniqueArgs extends wayFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * way findUniqueOrThrow
   */
  export type wayFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter, which way to fetch.
     */
    where: wayWhereUniqueInput
  }


  /**
   * way base type for findFirst actions
   */
  export type wayFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter, which way to fetch.
     */
    where?: wayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ways to fetch.
     */
    orderBy?: Enumerable<wayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ways.
     */
    cursor?: wayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ways.
     */
    distinct?: Enumerable<WayScalarFieldEnum>
  }

  /**
   * way findFirst
   */
  export interface wayFindFirstArgs extends wayFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * way findFirstOrThrow
   */
  export type wayFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter, which way to fetch.
     */
    where?: wayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ways to fetch.
     */
    orderBy?: Enumerable<wayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ways.
     */
    cursor?: wayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ways.
     */
    distinct?: Enumerable<WayScalarFieldEnum>
  }


  /**
   * way findMany
   */
  export type wayFindManyArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter, which ways to fetch.
     */
    where?: wayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ways to fetch.
     */
    orderBy?: Enumerable<wayOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ways.
     */
    cursor?: wayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ways.
     */
    skip?: number
    distinct?: Enumerable<WayScalarFieldEnum>
  }


  /**
   * way create
   */
  export type wayCreateArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * The data needed to create a way.
     */
    data: XOR<wayCreateInput, wayUncheckedCreateInput>
  }


  /**
   * way createMany
   */
  export type wayCreateManyArgs = {
    /**
     * The data used to create many ways.
     */
    data: Enumerable<wayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * way update
   */
  export type wayUpdateArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * The data needed to update a way.
     */
    data: XOR<wayUpdateInput, wayUncheckedUpdateInput>
    /**
     * Choose, which way to update.
     */
    where: wayWhereUniqueInput
  }


  /**
   * way updateMany
   */
  export type wayUpdateManyArgs = {
    /**
     * The data used to update ways.
     */
    data: XOR<wayUpdateManyMutationInput, wayUncheckedUpdateManyInput>
    /**
     * Filter which ways to update
     */
    where?: wayWhereInput
  }


  /**
   * way upsert
   */
  export type wayUpsertArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * The filter to search for the way to update in case it exists.
     */
    where: wayWhereUniqueInput
    /**
     * In case the way found by the `where` argument doesn't exist, create a new way with this data.
     */
    create: XOR<wayCreateInput, wayUncheckedCreateInput>
    /**
     * In case the way was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wayUpdateInput, wayUncheckedUpdateInput>
  }


  /**
   * way delete
   */
  export type wayDeleteArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
    /**
     * Filter which way to delete.
     */
    where: wayWhereUniqueInput
  }


  /**
   * way deleteMany
   */
  export type wayDeleteManyArgs = {
    /**
     * Filter which ways to delete
     */
    where?: wayWhereInput
  }


  /**
   * way.anomaly
   */
  export type way$anomalyArgs = {
    /**
     * Select specific fields to fetch from the anomaly
     */
    select?: anomalySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: anomalyInclude | null
    where?: anomalyWhereInput
    orderBy?: Enumerable<anomalyOrderByWithRelationInput>
    cursor?: anomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnomalyScalarFieldEnum>
  }


  /**
   * way without action
   */
  export type wayArgs = {
    /**
     * Select specific fields to fetch from the way
     */
    select?: waySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: wayInclude | null
  }



  /**
   * Model worksite
   */


  export type AggregateWorksite = {
    _count: WorksiteCountAggregateOutputType | null
    _avg: WorksiteAvgAggregateOutputType | null
    _sum: WorksiteSumAggregateOutputType | null
    _min: WorksiteMinAggregateOutputType | null
    _max: WorksiteMaxAggregateOutputType | null
  }

  export type WorksiteAvgAggregateOutputType = {
    id: number | null
    town_id: number | null
  }

  export type WorksiteSumAggregateOutputType = {
    id: number | null
    town_id: number | null
  }

  export type WorksiteMinAggregateOutputType = {
    id: number | null
    town_id: number | null
    name: string | null
    adress: string | null
  }

  export type WorksiteMaxAggregateOutputType = {
    id: number | null
    town_id: number | null
    name: string | null
    adress: string | null
  }

  export type WorksiteCountAggregateOutputType = {
    id: number
    town_id: number
    name: number
    adress: number
    _all: number
  }


  export type WorksiteAvgAggregateInputType = {
    id?: true
    town_id?: true
  }

  export type WorksiteSumAggregateInputType = {
    id?: true
    town_id?: true
  }

  export type WorksiteMinAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    adress?: true
  }

  export type WorksiteMaxAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    adress?: true
  }

  export type WorksiteCountAggregateInputType = {
    id?: true
    town_id?: true
    name?: true
    adress?: true
    _all?: true
  }

  export type WorksiteAggregateArgs = {
    /**
     * Filter which worksite to aggregate.
     */
    where?: worksiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of worksites to fetch.
     */
    orderBy?: Enumerable<worksiteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: worksiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` worksites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` worksites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned worksites
    **/
    _count?: true | WorksiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorksiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorksiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorksiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorksiteMaxAggregateInputType
  }

  export type GetWorksiteAggregateType<T extends WorksiteAggregateArgs> = {
        [P in keyof T & keyof AggregateWorksite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorksite[P]>
      : GetScalarType<T[P], AggregateWorksite[P]>
  }




  export type WorksiteGroupByArgs = {
    where?: worksiteWhereInput
    orderBy?: Enumerable<worksiteOrderByWithAggregationInput>
    by: WorksiteScalarFieldEnum[]
    having?: worksiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorksiteCountAggregateInputType | true
    _avg?: WorksiteAvgAggregateInputType
    _sum?: WorksiteSumAggregateInputType
    _min?: WorksiteMinAggregateInputType
    _max?: WorksiteMaxAggregateInputType
  }


  export type WorksiteGroupByOutputType = {
    id: number
    town_id: number | null
    name: string
    adress: string | null
    _count: WorksiteCountAggregateOutputType | null
    _avg: WorksiteAvgAggregateOutputType | null
    _sum: WorksiteSumAggregateOutputType | null
    _min: WorksiteMinAggregateOutputType | null
    _max: WorksiteMaxAggregateOutputType | null
  }

  type GetWorksiteGroupByPayload<T extends WorksiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorksiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorksiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorksiteGroupByOutputType[P]>
            : GetScalarType<T[P], WorksiteGroupByOutputType[P]>
        }
      >
    >


  export type worksiteSelect = {
    id?: boolean
    town_id?: boolean
    name?: boolean
    adress?: boolean
    container_mouvement?: boolean | worksite$container_mouvementArgs
    town?: boolean | townArgs
    _count?: boolean | WorksiteCountOutputTypeArgs
  }


  export type worksiteInclude = {
    container_mouvement?: boolean | worksite$container_mouvementArgs
    town?: boolean | townArgs
    _count?: boolean | WorksiteCountOutputTypeArgs
  }

  export type worksiteGetPayload<S extends boolean | null | undefined | worksiteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? worksite :
    S extends undefined ? never :
    S extends { include: any } & (worksiteArgs | worksiteFindManyArgs)
    ? worksite  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['include'][P]>>  :
        P extends 'town' ? townGetPayload<S['include'][P]> | null :
        P extends '_count' ? WorksiteCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (worksiteArgs | worksiteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'container_mouvement' ? Array < container_mouvementGetPayload<S['select'][P]>>  :
        P extends 'town' ? townGetPayload<S['select'][P]> | null :
        P extends '_count' ? WorksiteCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof worksite ? worksite[P] : never
  } 
      : worksite


  type worksiteCountArgs = 
    Omit<worksiteFindManyArgs, 'select' | 'include'> & {
      select?: WorksiteCountAggregateInputType | true
    }

  export interface worksiteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Worksite that matches the filter.
     * @param {worksiteFindUniqueArgs} args - Arguments to find a Worksite
     * @example
     * // Get one Worksite
     * const worksite = await prisma.worksite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends worksiteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, worksiteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'worksite'> extends True ? Prisma__worksiteClient<worksiteGetPayload<T>> : Prisma__worksiteClient<worksiteGetPayload<T> | null, null>

    /**
     * Find one Worksite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {worksiteFindUniqueOrThrowArgs} args - Arguments to find a Worksite
     * @example
     * // Get one Worksite
     * const worksite = await prisma.worksite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends worksiteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, worksiteFindUniqueOrThrowArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Find the first Worksite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {worksiteFindFirstArgs} args - Arguments to find a Worksite
     * @example
     * // Get one Worksite
     * const worksite = await prisma.worksite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends worksiteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, worksiteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'worksite'> extends True ? Prisma__worksiteClient<worksiteGetPayload<T>> : Prisma__worksiteClient<worksiteGetPayload<T> | null, null>

    /**
     * Find the first Worksite that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {worksiteFindFirstOrThrowArgs} args - Arguments to find a Worksite
     * @example
     * // Get one Worksite
     * const worksite = await prisma.worksite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends worksiteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, worksiteFindFirstOrThrowArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Find zero or more Worksites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {worksiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Worksites
     * const worksites = await prisma.worksite.findMany()
     * 
     * // Get first 10 Worksites
     * const worksites = await prisma.worksite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worksiteWithIdOnly = await prisma.worksite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends worksiteFindManyArgs>(
      args?: SelectSubset<T, worksiteFindManyArgs>
    ): Prisma.PrismaPromise<Array<worksiteGetPayload<T>>>

    /**
     * Create a Worksite.
     * @param {worksiteCreateArgs} args - Arguments to create a Worksite.
     * @example
     * // Create one Worksite
     * const Worksite = await prisma.worksite.create({
     *   data: {
     *     // ... data to create a Worksite
     *   }
     * })
     * 
    **/
    create<T extends worksiteCreateArgs>(
      args: SelectSubset<T, worksiteCreateArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Create many Worksites.
     *     @param {worksiteCreateManyArgs} args - Arguments to create many Worksites.
     *     @example
     *     // Create many Worksites
     *     const worksite = await prisma.worksite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends worksiteCreateManyArgs>(
      args?: SelectSubset<T, worksiteCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Worksite.
     * @param {worksiteDeleteArgs} args - Arguments to delete one Worksite.
     * @example
     * // Delete one Worksite
     * const Worksite = await prisma.worksite.delete({
     *   where: {
     *     // ... filter to delete one Worksite
     *   }
     * })
     * 
    **/
    delete<T extends worksiteDeleteArgs>(
      args: SelectSubset<T, worksiteDeleteArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Update one Worksite.
     * @param {worksiteUpdateArgs} args - Arguments to update one Worksite.
     * @example
     * // Update one Worksite
     * const worksite = await prisma.worksite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends worksiteUpdateArgs>(
      args: SelectSubset<T, worksiteUpdateArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Delete zero or more Worksites.
     * @param {worksiteDeleteManyArgs} args - Arguments to filter Worksites to delete.
     * @example
     * // Delete a few Worksites
     * const { count } = await prisma.worksite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends worksiteDeleteManyArgs>(
      args?: SelectSubset<T, worksiteDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Worksites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {worksiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Worksites
     * const worksite = await prisma.worksite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends worksiteUpdateManyArgs>(
      args: SelectSubset<T, worksiteUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Worksite.
     * @param {worksiteUpsertArgs} args - Arguments to update or create a Worksite.
     * @example
     * // Update or create a Worksite
     * const worksite = await prisma.worksite.upsert({
     *   create: {
     *     // ... data to create a Worksite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worksite we want to update
     *   }
     * })
    **/
    upsert<T extends worksiteUpsertArgs>(
      args: SelectSubset<T, worksiteUpsertArgs>
    ): Prisma__worksiteClient<worksiteGetPayload<T>>

    /**
     * Count the number of Worksites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {worksiteCountArgs} args - Arguments to filter Worksites to count.
     * @example
     * // Count the number of Worksites
     * const count = await prisma.worksite.count({
     *   where: {
     *     // ... the filter for the Worksites we want to count
     *   }
     * })
    **/
    count<T extends worksiteCountArgs>(
      args?: Subset<T, worksiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorksiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worksite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorksiteAggregateArgs>(args: Subset<T, WorksiteAggregateArgs>): Prisma.PrismaPromise<GetWorksiteAggregateType<T>>

    /**
     * Group by Worksite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorksiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorksiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorksiteGroupByArgs['orderBy'] }
        : { orderBy?: WorksiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorksiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorksiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for worksite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__worksiteClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    container_mouvement<T extends worksite$container_mouvementArgs= {}>(args?: Subset<T, worksite$container_mouvementArgs>): Prisma.PrismaPromise<Array<container_mouvementGetPayload<T>>| Null>;

    town<T extends townArgs= {}>(args?: Subset<T, townArgs>): Prisma__townClient<townGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * worksite base type for findUnique actions
   */
  export type worksiteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter, which worksite to fetch.
     */
    where: worksiteWhereUniqueInput
  }

  /**
   * worksite findUnique
   */
  export interface worksiteFindUniqueArgs extends worksiteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * worksite findUniqueOrThrow
   */
  export type worksiteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter, which worksite to fetch.
     */
    where: worksiteWhereUniqueInput
  }


  /**
   * worksite base type for findFirst actions
   */
  export type worksiteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter, which worksite to fetch.
     */
    where?: worksiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of worksites to fetch.
     */
    orderBy?: Enumerable<worksiteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for worksites.
     */
    cursor?: worksiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` worksites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` worksites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of worksites.
     */
    distinct?: Enumerable<WorksiteScalarFieldEnum>
  }

  /**
   * worksite findFirst
   */
  export interface worksiteFindFirstArgs extends worksiteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * worksite findFirstOrThrow
   */
  export type worksiteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter, which worksite to fetch.
     */
    where?: worksiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of worksites to fetch.
     */
    orderBy?: Enumerable<worksiteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for worksites.
     */
    cursor?: worksiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` worksites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` worksites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of worksites.
     */
    distinct?: Enumerable<WorksiteScalarFieldEnum>
  }


  /**
   * worksite findMany
   */
  export type worksiteFindManyArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter, which worksites to fetch.
     */
    where?: worksiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of worksites to fetch.
     */
    orderBy?: Enumerable<worksiteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing worksites.
     */
    cursor?: worksiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` worksites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` worksites.
     */
    skip?: number
    distinct?: Enumerable<WorksiteScalarFieldEnum>
  }


  /**
   * worksite create
   */
  export type worksiteCreateArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * The data needed to create a worksite.
     */
    data: XOR<worksiteCreateInput, worksiteUncheckedCreateInput>
  }


  /**
   * worksite createMany
   */
  export type worksiteCreateManyArgs = {
    /**
     * The data used to create many worksites.
     */
    data: Enumerable<worksiteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * worksite update
   */
  export type worksiteUpdateArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * The data needed to update a worksite.
     */
    data: XOR<worksiteUpdateInput, worksiteUncheckedUpdateInput>
    /**
     * Choose, which worksite to update.
     */
    where: worksiteWhereUniqueInput
  }


  /**
   * worksite updateMany
   */
  export type worksiteUpdateManyArgs = {
    /**
     * The data used to update worksites.
     */
    data: XOR<worksiteUpdateManyMutationInput, worksiteUncheckedUpdateManyInput>
    /**
     * Filter which worksites to update
     */
    where?: worksiteWhereInput
  }


  /**
   * worksite upsert
   */
  export type worksiteUpsertArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * The filter to search for the worksite to update in case it exists.
     */
    where: worksiteWhereUniqueInput
    /**
     * In case the worksite found by the `where` argument doesn't exist, create a new worksite with this data.
     */
    create: XOR<worksiteCreateInput, worksiteUncheckedCreateInput>
    /**
     * In case the worksite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<worksiteUpdateInput, worksiteUncheckedUpdateInput>
  }


  /**
   * worksite delete
   */
  export type worksiteDeleteArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
    /**
     * Filter which worksite to delete.
     */
    where: worksiteWhereUniqueInput
  }


  /**
   * worksite deleteMany
   */
  export type worksiteDeleteManyArgs = {
    /**
     * Filter which worksites to delete
     */
    where?: worksiteWhereInput
  }


  /**
   * worksite.container_mouvement
   */
  export type worksite$container_mouvementArgs = {
    /**
     * Select specific fields to fetch from the container_mouvement
     */
    select?: container_mouvementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: container_mouvementInclude | null
    where?: container_mouvementWhereInput
    orderBy?: Enumerable<container_mouvementOrderByWithRelationInput>
    cursor?: container_mouvementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Container_mouvementScalarFieldEnum>
  }


  /**
   * worksite without action
   */
  export type worksiteArgs = {
    /**
     * Select specific fields to fetch from the worksite
     */
    select?: worksiteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: worksiteInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AnomalyScalarFieldEnum: {
    id: 'id',
    way_id: 'way_id',
    date: 'date',
    type: 'type',
    is_collected: 'is_collected',
    regularization_date: 'regularization_date',
    description: 'description',
    report_id: 'report_id',
    manual_town: 'manual_town',
    manual_way: 'manual_way',
    manual_flux: 'manual_flux',
    manual_truck: 'manual_truck',
    type_anomaly_id: 'type_anomaly_id'
  };

  export type AnomalyScalarFieldEnum = (typeof AnomalyScalarFieldEnum)[keyof typeof AnomalyScalarFieldEnum]


  export const CircuitScalarFieldEnum: {
    id: 'id',
    default_outlet_id: 'default_outlet_id',
    name: 'name'
  };

  export type CircuitScalarFieldEnum = (typeof CircuitScalarFieldEnum)[keyof typeof CircuitScalarFieldEnum]


  export const CollecteScalarFieldEnum: {
    id: 'id',
    date: 'date',
    observation: 'observation',
    is_valid: 'is_valid'
  };

  export type CollecteScalarFieldEnum = (typeof CollecteScalarFieldEnum)[keyof typeof CollecteScalarFieldEnum]


  export const Collecte_observationScalarFieldEnum: {
    id: 'id',
    collecte_id: 'collecte_id',
    description: 'description'
  };

  export type Collecte_observationScalarFieldEnum = (typeof Collecte_observationScalarFieldEnum)[keyof typeof Collecte_observationScalarFieldEnum]


  export const Container_mouvementScalarFieldEnum: {
    id: 'id',
    worksite_id: 'worksite_id',
    driver_id: 'driver_id',
    truck_id: 'truck_id',
    flux_id: 'flux_id',
    outlet_id: 'outlet_id',
    description: 'description',
    tonnage: 'tonnage',
    operation_type_id: 'operation_type_id',
    container_type_id: 'container_type_id',
    date: 'date'
  };

  export type Container_mouvementScalarFieldEnum = (typeof Container_mouvementScalarFieldEnum)[keyof typeof Container_mouvementScalarFieldEnum]


  export const Container_typeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Container_typeScalarFieldEnum = (typeof Container_typeScalarFieldEnum)[keyof typeof Container_typeScalarFieldEnum]


  export const Doctrine_migration_versionsScalarFieldEnum: {
    version: 'version',
    executed_at: 'executed_at',
    execution_time: 'execution_time'
  };

  export type Doctrine_migration_versionsScalarFieldEnum = (typeof Doctrine_migration_versionsScalarFieldEnum)[keyof typeof Doctrine_migration_versionsScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    last_name: 'last_name',
    first_name: 'first_name',
    type: 'type'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const FluxScalarFieldEnum: {
    id: 'id',
    name: 'name',
    circuit_id: 'circuit_id'
  };

  export type FluxScalarFieldEnum = (typeof FluxScalarFieldEnum)[keyof typeof FluxScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const Messenger_messagesScalarFieldEnum: {
    id: 'id',
    body: 'body',
    headers: 'headers',
    queue_name: 'queue_name',
    created_at: 'created_at',
    available_at: 'available_at',
    delivered_at: 'delivered_at'
  };

  export type Messenger_messagesScalarFieldEnum = (typeof Messenger_messagesScalarFieldEnum)[keyof typeof Messenger_messagesScalarFieldEnum]


  export const Operation_typeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Operation_typeScalarFieldEnum = (typeof Operation_typeScalarFieldEnum)[keyof typeof Operation_typeScalarFieldEnum]


  export const OutletScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type OutletScalarFieldEnum = (typeof OutletScalarFieldEnum)[keyof typeof OutletScalarFieldEnum]


  export const Replacement_teamScalarFieldEnum: {
    id: 'id',
    substitute_driver_id: 'substitute_driver_id',
    substitute_ripper1_id: 'substitute_ripper1_id',
    substitute_ripper2_id: 'substitute_ripper2_id'
  };

  export type Replacement_teamScalarFieldEnum = (typeof Replacement_teamScalarFieldEnum)[keyof typeof Replacement_teamScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    default_outlet_id: 'default_outlet_id',
    visited_outlet_id: 'visited_outlet_id',
    flux_id: 'flux_id',
    truck_id: 'truck_id',
    date: 'date',
    manual_circuit: 'manual_circuit',
    total_bac_collected: 'total_bac_collected',
    total_bac_rejected: 'total_bac_rejected',
    tonnage: 'tonnage',
    tonnage2: 'tonnage2',
    default_outlet2_id: 'default_outlet2_id',
    visited_outlet2_id: 'visited_outlet2_id',
    default_outlet3_id: 'default_outlet3_id',
    visited_outlet3_id: 'visited_outlet3_id',
    default_outlet4_id: 'default_outlet4_id',
    visited_outlet4_id: 'visited_outlet4_id',
    tonnage3: 'tonnage3',
    tonnage4: 'tonnage4',
    circuit_id: 'circuit_id',
    collecte_id: 'collecte_id',
    observation: 'observation',
    geoloc_id: 'geoloc_id'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const RipperScalarFieldEnum: {
    id: 'id',
    last_name: 'last_name',
    first_name: 'first_name'
  };

  export type RipperScalarFieldEnum = (typeof RipperScalarFieldEnum)[keyof typeof RipperScalarFieldEnum]


  export const SinisterScalarFieldEnum: {
    id: 'id',
    truck_id: 'truck_id',
    driver_id: 'driver_id',
    date: 'date',
    place: 'place',
    opposing_vehicule: 'opposing_vehicule',
    opposing_driver: 'opposing_driver',
    circumstance: 'circumstance',
    status: 'status',
    observation: 'observation'
  };

  export type SinisterScalarFieldEnum = (typeof SinisterScalarFieldEnum)[keyof typeof SinisterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TabletScalarFieldEnum: {
    id: 'id',
    label: 'label'
  };

  export type TabletScalarFieldEnum = (typeof TabletScalarFieldEnum)[keyof typeof TabletScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    driver_id: 'driver_id',
    flux_id: 'flux_id',
    ripper1_id: 'ripper1_id',
    ripper2_id: 'ripper2_id',
    truck_id: 'truck_id',
    replacement_team_id: 'replacement_team_id',
    name: 'name',
    manual_circuit: 'manual_circuit',
    manual_tablet: 'manual_tablet'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TownScalarFieldEnum: {
    id: 'id',
    circuit_id: 'circuit_id',
    name: 'name',
    postal_code: 'postal_code'
  };

  export type TownScalarFieldEnum = (typeof TownScalarFieldEnum)[keyof typeof TownScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TruckScalarFieldEnum: {
    id: 'id',
    registration: 'registration',
    type: 'type'
  };

  export type TruckScalarFieldEnum = (typeof TruckScalarFieldEnum)[keyof typeof TruckScalarFieldEnum]


  export const Type_anomalyScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Type_anomalyScalarFieldEnum = (typeof Type_anomalyScalarFieldEnum)[keyof typeof Type_anomalyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    roles: 'roles',
    password: 'password',
    refresh_token: 'refresh_token'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WayScalarFieldEnum: {
    id: 'id',
    town_id: 'town_id',
    name: 'name',
    type: 'type'
  };

  export type WayScalarFieldEnum = (typeof WayScalarFieldEnum)[keyof typeof WayScalarFieldEnum]


  export const WorksiteScalarFieldEnum: {
    id: 'id',
    town_id: 'town_id',
    name: 'name',
    adress: 'adress'
  };

  export type WorksiteScalarFieldEnum = (typeof WorksiteScalarFieldEnum)[keyof typeof WorksiteScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type anomalyWhereInput = {
    AND?: Enumerable<anomalyWhereInput>
    OR?: Enumerable<anomalyWhereInput>
    NOT?: Enumerable<anomalyWhereInput>
    id?: IntFilter | number
    way_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    type?: StringNullableFilter | string | null
    is_collected?: StringFilter | string
    regularization_date?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    report_id?: IntNullableFilter | number | null
    manual_town?: StringNullableFilter | string | null
    manual_way?: StringNullableFilter | string | null
    manual_flux?: StringNullableFilter | string | null
    manual_truck?: StringNullableFilter | string | null
    type_anomaly_id?: IntNullableFilter | number | null
    report?: XOR<ReportRelationFilter, reportWhereInput> | null
    way?: XOR<WayRelationFilter, wayWhereInput> | null
    type_anomaly?: XOR<Type_anomalyRelationFilter, type_anomalyWhereInput> | null
  }

  export type anomalyOrderByWithRelationInput = {
    id?: SortOrder
    way_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    is_collected?: SortOrder
    regularization_date?: SortOrder
    description?: SortOrder
    report_id?: SortOrder
    manual_town?: SortOrder
    manual_way?: SortOrder
    manual_flux?: SortOrder
    manual_truck?: SortOrder
    type_anomaly_id?: SortOrder
    report?: reportOrderByWithRelationInput
    way?: wayOrderByWithRelationInput
    type_anomaly?: type_anomalyOrderByWithRelationInput
  }

  export type anomalyWhereUniqueInput = {
    id?: number
  }

  export type anomalyOrderByWithAggregationInput = {
    id?: SortOrder
    way_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    is_collected?: SortOrder
    regularization_date?: SortOrder
    description?: SortOrder
    report_id?: SortOrder
    manual_town?: SortOrder
    manual_way?: SortOrder
    manual_flux?: SortOrder
    manual_truck?: SortOrder
    type_anomaly_id?: SortOrder
    _count?: anomalyCountOrderByAggregateInput
    _avg?: anomalyAvgOrderByAggregateInput
    _max?: anomalyMaxOrderByAggregateInput
    _min?: anomalyMinOrderByAggregateInput
    _sum?: anomalySumOrderByAggregateInput
  }

  export type anomalyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<anomalyScalarWhereWithAggregatesInput>
    OR?: Enumerable<anomalyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<anomalyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    way_id?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
    type?: StringNullableWithAggregatesFilter | string | null
    is_collected?: StringWithAggregatesFilter | string
    regularization_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    report_id?: IntNullableWithAggregatesFilter | number | null
    manual_town?: StringNullableWithAggregatesFilter | string | null
    manual_way?: StringNullableWithAggregatesFilter | string | null
    manual_flux?: StringNullableWithAggregatesFilter | string | null
    manual_truck?: StringNullableWithAggregatesFilter | string | null
    type_anomaly_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type circuitWhereInput = {
    AND?: Enumerable<circuitWhereInput>
    OR?: Enumerable<circuitWhereInput>
    NOT?: Enumerable<circuitWhereInput>
    id?: IntFilter | number
    default_outlet_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    outlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    flux?: FluxListRelationFilter
    report?: ReportListRelationFilter
    town?: TownListRelationFilter
  }

  export type circuitOrderByWithRelationInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    name?: SortOrder
    outlet?: outletOrderByWithRelationInput
    flux?: fluxOrderByRelationAggregateInput
    report?: reportOrderByRelationAggregateInput
    town?: townOrderByRelationAggregateInput
  }

  export type circuitWhereUniqueInput = {
    id?: number
  }

  export type circuitOrderByWithAggregationInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    name?: SortOrder
    _count?: circuitCountOrderByAggregateInput
    _avg?: circuitAvgOrderByAggregateInput
    _max?: circuitMaxOrderByAggregateInput
    _min?: circuitMinOrderByAggregateInput
    _sum?: circuitSumOrderByAggregateInput
  }

  export type circuitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<circuitScalarWhereWithAggregatesInput>
    OR?: Enumerable<circuitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<circuitScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    default_outlet_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
  }

  export type collecteWhereInput = {
    AND?: Enumerable<collecteWhereInput>
    OR?: Enumerable<collecteWhereInput>
    NOT?: Enumerable<collecteWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    observation?: StringFilter | string
    is_valid?: BoolFilter | boolean
    collecte_observation?: Collecte_observationListRelationFilter
    report?: ReportListRelationFilter
  }

  export type collecteOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    observation?: SortOrder
    is_valid?: SortOrder
    collecte_observation?: collecte_observationOrderByRelationAggregateInput
    report?: reportOrderByRelationAggregateInput
  }

  export type collecteWhereUniqueInput = {
    id?: number
  }

  export type collecteOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    observation?: SortOrder
    is_valid?: SortOrder
    _count?: collecteCountOrderByAggregateInput
    _avg?: collecteAvgOrderByAggregateInput
    _max?: collecteMaxOrderByAggregateInput
    _min?: collecteMinOrderByAggregateInput
    _sum?: collecteSumOrderByAggregateInput
  }

  export type collecteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<collecteScalarWhereWithAggregatesInput>
    OR?: Enumerable<collecteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<collecteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    observation?: StringWithAggregatesFilter | string
    is_valid?: BoolWithAggregatesFilter | boolean
  }

  export type collecte_observationWhereInput = {
    AND?: Enumerable<collecte_observationWhereInput>
    OR?: Enumerable<collecte_observationWhereInput>
    NOT?: Enumerable<collecte_observationWhereInput>
    id?: IntFilter | number
    collecte_id?: IntNullableFilter | number | null
    description?: StringFilter | string
    collecte?: XOR<CollecteRelationFilter, collecteWhereInput> | null
  }

  export type collecte_observationOrderByWithRelationInput = {
    id?: SortOrder
    collecte_id?: SortOrder
    description?: SortOrder
    collecte?: collecteOrderByWithRelationInput
  }

  export type collecte_observationWhereUniqueInput = {
    id?: number
  }

  export type collecte_observationOrderByWithAggregationInput = {
    id?: SortOrder
    collecte_id?: SortOrder
    description?: SortOrder
    _count?: collecte_observationCountOrderByAggregateInput
    _avg?: collecte_observationAvgOrderByAggregateInput
    _max?: collecte_observationMaxOrderByAggregateInput
    _min?: collecte_observationMinOrderByAggregateInput
    _sum?: collecte_observationSumOrderByAggregateInput
  }

  export type collecte_observationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<collecte_observationScalarWhereWithAggregatesInput>
    OR?: Enumerable<collecte_observationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<collecte_observationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    collecte_id?: IntNullableWithAggregatesFilter | number | null
    description?: StringWithAggregatesFilter | string
  }

  export type container_mouvementWhereInput = {
    AND?: Enumerable<container_mouvementWhereInput>
    OR?: Enumerable<container_mouvementWhereInput>
    NOT?: Enumerable<container_mouvementWhereInput>
    id?: IntFilter | number
    worksite_id?: IntNullableFilter | number | null
    driver_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    outlet_id?: IntNullableFilter | number | null
    description?: StringFilter | string
    tonnage?: FloatFilter | number
    operation_type_id?: IntNullableFilter | number | null
    container_type_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    container_type?: XOR<Container_typeRelationFilter, container_typeWhereInput> | null
    operation_type?: XOR<Operation_typeRelationFilter, operation_typeWhereInput> | null
    worksite?: XOR<WorksiteRelationFilter, worksiteWhereInput> | null
    driver?: XOR<DriverRelationFilter, driverWhereInput> | null
    truck?: XOR<TruckRelationFilter, truckWhereInput> | null
    flux?: XOR<FluxRelationFilter, fluxWhereInput> | null
    outlet?: XOR<OutletRelationFilter, outletWhereInput> | null
  }

  export type container_mouvementOrderByWithRelationInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    description?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
    date?: SortOrder
    container_type?: container_typeOrderByWithRelationInput
    operation_type?: operation_typeOrderByWithRelationInput
    worksite?: worksiteOrderByWithRelationInput
    driver?: driverOrderByWithRelationInput
    truck?: truckOrderByWithRelationInput
    flux?: fluxOrderByWithRelationInput
    outlet?: outletOrderByWithRelationInput
  }

  export type container_mouvementWhereUniqueInput = {
    id?: number
  }

  export type container_mouvementOrderByWithAggregationInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    description?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
    date?: SortOrder
    _count?: container_mouvementCountOrderByAggregateInput
    _avg?: container_mouvementAvgOrderByAggregateInput
    _max?: container_mouvementMaxOrderByAggregateInput
    _min?: container_mouvementMinOrderByAggregateInput
    _sum?: container_mouvementSumOrderByAggregateInput
  }

  export type container_mouvementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<container_mouvementScalarWhereWithAggregatesInput>
    OR?: Enumerable<container_mouvementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<container_mouvementScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    worksite_id?: IntNullableWithAggregatesFilter | number | null
    driver_id?: IntNullableWithAggregatesFilter | number | null
    truck_id?: IntNullableWithAggregatesFilter | number | null
    flux_id?: IntNullableWithAggregatesFilter | number | null
    outlet_id?: IntNullableWithAggregatesFilter | number | null
    description?: StringWithAggregatesFilter | string
    tonnage?: FloatWithAggregatesFilter | number
    operation_type_id?: IntNullableWithAggregatesFilter | number | null
    container_type_id?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type container_typeWhereInput = {
    AND?: Enumerable<container_typeWhereInput>
    OR?: Enumerable<container_typeWhereInput>
    NOT?: Enumerable<container_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    container_mouvement?: Container_mouvementListRelationFilter
  }

  export type container_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
  }

  export type container_typeWhereUniqueInput = {
    id?: number
  }

  export type container_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: container_typeCountOrderByAggregateInput
    _avg?: container_typeAvgOrderByAggregateInput
    _max?: container_typeMaxOrderByAggregateInput
    _min?: container_typeMinOrderByAggregateInput
    _sum?: container_typeSumOrderByAggregateInput
  }

  export type container_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<container_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<container_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<container_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type doctrine_migration_versionsWhereInput = {
    AND?: Enumerable<doctrine_migration_versionsWhereInput>
    OR?: Enumerable<doctrine_migration_versionsWhereInput>
    NOT?: Enumerable<doctrine_migration_versionsWhereInput>
    version?: StringFilter | string
    executed_at?: DateTimeNullableFilter | Date | string | null
    execution_time?: IntNullableFilter | number | null
  }

  export type doctrine_migration_versionsOrderByWithRelationInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsWhereUniqueInput = {
    version?: string
  }

  export type doctrine_migration_versionsOrderByWithAggregationInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
    _count?: doctrine_migration_versionsCountOrderByAggregateInput
    _avg?: doctrine_migration_versionsAvgOrderByAggregateInput
    _max?: doctrine_migration_versionsMaxOrderByAggregateInput
    _min?: doctrine_migration_versionsMinOrderByAggregateInput
    _sum?: doctrine_migration_versionsSumOrderByAggregateInput
  }

  export type doctrine_migration_versionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<doctrine_migration_versionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<doctrine_migration_versionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<doctrine_migration_versionsScalarWhereWithAggregatesInput>
    version?: StringWithAggregatesFilter | string
    executed_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    execution_time?: IntNullableWithAggregatesFilter | number | null
  }

  export type driverWhereInput = {
    AND?: Enumerable<driverWhereInput>
    OR?: Enumerable<driverWhereInput>
    NOT?: Enumerable<driverWhereInput>
    id?: IntFilter | number
    last_name?: StringFilter | string
    first_name?: StringFilter | string
    type?: StringNullableFilter | string | null
    container_mouvement?: Container_mouvementListRelationFilter
    replacement_team?: Replacement_teamListRelationFilter
    sinister?: SinisterListRelationFilter
    team?: XOR<TeamRelationFilter, teamWhereInput> | null
  }

  export type driverOrderByWithRelationInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    type?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
    replacement_team?: replacement_teamOrderByRelationAggregateInput
    sinister?: sinisterOrderByRelationAggregateInput
    team?: teamOrderByWithRelationInput
  }

  export type driverWhereUniqueInput = {
    id?: number
  }

  export type driverOrderByWithAggregationInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    type?: SortOrder
    _count?: driverCountOrderByAggregateInput
    _avg?: driverAvgOrderByAggregateInput
    _max?: driverMaxOrderByAggregateInput
    _min?: driverMinOrderByAggregateInput
    _sum?: driverSumOrderByAggregateInput
  }

  export type driverScalarWhereWithAggregatesInput = {
    AND?: Enumerable<driverScalarWhereWithAggregatesInput>
    OR?: Enumerable<driverScalarWhereWithAggregatesInput>
    NOT?: Enumerable<driverScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    last_name?: StringWithAggregatesFilter | string
    first_name?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
  }

  export type fluxWhereInput = {
    AND?: Enumerable<fluxWhereInput>
    OR?: Enumerable<fluxWhereInput>
    NOT?: Enumerable<fluxWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    circuit_id?: IntNullableFilter | number | null
    container_mouvement?: Container_mouvementListRelationFilter
    circuit?: XOR<CircuitRelationFilter, circuitWhereInput> | null
    report?: ReportListRelationFilter
    team?: TeamListRelationFilter
  }

  export type fluxOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    circuit_id?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
    circuit?: circuitOrderByWithRelationInput
    report?: reportOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
  }

  export type fluxWhereUniqueInput = {
    id?: number
  }

  export type fluxOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    circuit_id?: SortOrder
    _count?: fluxCountOrderByAggregateInput
    _avg?: fluxAvgOrderByAggregateInput
    _max?: fluxMaxOrderByAggregateInput
    _min?: fluxMinOrderByAggregateInput
    _sum?: fluxSumOrderByAggregateInput
  }

  export type fluxScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fluxScalarWhereWithAggregatesInput>
    OR?: Enumerable<fluxScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fluxScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    circuit_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type messenger_messagesWhereInput = {
    AND?: Enumerable<messenger_messagesWhereInput>
    OR?: Enumerable<messenger_messagesWhereInput>
    NOT?: Enumerable<messenger_messagesWhereInput>
    id?: BigIntFilter | bigint | number
    body?: StringFilter | string
    headers?: StringFilter | string
    queue_name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    available_at?: DateTimeFilter | Date | string
    delivered_at?: DateTimeNullableFilter | Date | string | null
  }

  export type messenger_messagesOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesWhereUniqueInput = {
    id?: bigint | number
  }

  export type messenger_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
    _count?: messenger_messagesCountOrderByAggregateInput
    _avg?: messenger_messagesAvgOrderByAggregateInput
    _max?: messenger_messagesMaxOrderByAggregateInput
    _min?: messenger_messagesMinOrderByAggregateInput
    _sum?: messenger_messagesSumOrderByAggregateInput
  }

  export type messenger_messagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<messenger_messagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<messenger_messagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<messenger_messagesScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    body?: StringWithAggregatesFilter | string
    headers?: StringWithAggregatesFilter | string
    queue_name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    available_at?: DateTimeWithAggregatesFilter | Date | string
    delivered_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type operation_typeWhereInput = {
    AND?: Enumerable<operation_typeWhereInput>
    OR?: Enumerable<operation_typeWhereInput>
    NOT?: Enumerable<operation_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    container_mouvement?: Container_mouvementListRelationFilter
  }

  export type operation_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
  }

  export type operation_typeWhereUniqueInput = {
    id?: number
  }

  export type operation_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: operation_typeCountOrderByAggregateInput
    _avg?: operation_typeAvgOrderByAggregateInput
    _max?: operation_typeMaxOrderByAggregateInput
    _min?: operation_typeMinOrderByAggregateInput
    _sum?: operation_typeSumOrderByAggregateInput
  }

  export type operation_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<operation_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<operation_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<operation_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type outletWhereInput = {
    AND?: Enumerable<outletWhereInput>
    OR?: Enumerable<outletWhereInput>
    NOT?: Enumerable<outletWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    circuit?: CircuitListRelationFilter
    container_mouvement?: Container_mouvementListRelationFilter
    report_report_visited_outlet4_idTooutlet?: ReportListRelationFilter
    report_report_visited_outlet2_idTooutlet?: ReportListRelationFilter
    report_report_default_outlet_idTooutlet?: ReportListRelationFilter
    report_report_default_outlet3_idTooutlet?: ReportListRelationFilter
    report_report_visited_outlet3_idTooutlet?: ReportListRelationFilter
    report_report_visited_outlet_idTooutlet?: ReportListRelationFilter
    report_report_default_outlet2_idTooutlet?: ReportListRelationFilter
    report_report_default_outlet4_idTooutlet?: ReportListRelationFilter
  }

  export type outletOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    circuit?: circuitOrderByRelationAggregateInput
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
    report_report_visited_outlet4_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_visited_outlet2_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_default_outlet_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_default_outlet3_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_visited_outlet3_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_visited_outlet_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_default_outlet2_idTooutlet?: reportOrderByRelationAggregateInput
    report_report_default_outlet4_idTooutlet?: reportOrderByRelationAggregateInput
  }

  export type outletWhereUniqueInput = {
    id?: number
  }

  export type outletOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: outletCountOrderByAggregateInput
    _avg?: outletAvgOrderByAggregateInput
    _max?: outletMaxOrderByAggregateInput
    _min?: outletMinOrderByAggregateInput
    _sum?: outletSumOrderByAggregateInput
  }

  export type outletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<outletScalarWhereWithAggregatesInput>
    OR?: Enumerable<outletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<outletScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type replacement_teamWhereInput = {
    AND?: Enumerable<replacement_teamWhereInput>
    OR?: Enumerable<replacement_teamWhereInput>
    NOT?: Enumerable<replacement_teamWhereInput>
    id?: IntFilter | number
    substitute_driver_id?: IntNullableFilter | number | null
    substitute_ripper1_id?: IntNullableFilter | number | null
    substitute_ripper2_id?: IntNullableFilter | number | null
    ripper_replacement_team_substitute_ripper2_idToripper?: XOR<RipperRelationFilter, ripperWhereInput> | null
    ripper_replacement_team_substitute_ripper1_idToripper?: XOR<RipperRelationFilter, ripperWhereInput> | null
    driver?: XOR<DriverRelationFilter, driverWhereInput> | null
    team?: XOR<TeamRelationFilter, teamWhereInput> | null
  }

  export type replacement_teamOrderByWithRelationInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperOrderByWithRelationInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperOrderByWithRelationInput
    driver?: driverOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type replacement_teamWhereUniqueInput = {
    id?: number
  }

  export type replacement_teamOrderByWithAggregationInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
    _count?: replacement_teamCountOrderByAggregateInput
    _avg?: replacement_teamAvgOrderByAggregateInput
    _max?: replacement_teamMaxOrderByAggregateInput
    _min?: replacement_teamMinOrderByAggregateInput
    _sum?: replacement_teamSumOrderByAggregateInput
  }

  export type replacement_teamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<replacement_teamScalarWhereWithAggregatesInput>
    OR?: Enumerable<replacement_teamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<replacement_teamScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    substitute_driver_id?: IntNullableWithAggregatesFilter | number | null
    substitute_ripper1_id?: IntNullableWithAggregatesFilter | number | null
    substitute_ripper2_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type reportWhereInput = {
    AND?: Enumerable<reportWhereInput>
    OR?: Enumerable<reportWhereInput>
    NOT?: Enumerable<reportWhereInput>
    id?: IntFilter | number
    default_outlet_id?: IntNullableFilter | number | null
    visited_outlet_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    manual_circuit?: StringNullableFilter | string | null
    total_bac_collected?: IntFilter | number
    total_bac_rejected?: IntFilter | number
    tonnage?: FloatNullableFilter | number | null
    tonnage2?: FloatNullableFilter | number | null
    default_outlet2_id?: IntNullableFilter | number | null
    visited_outlet2_id?: IntNullableFilter | number | null
    default_outlet3_id?: IntNullableFilter | number | null
    visited_outlet3_id?: IntNullableFilter | number | null
    default_outlet4_id?: IntNullableFilter | number | null
    visited_outlet4_id?: IntNullableFilter | number | null
    tonnage3?: FloatNullableFilter | number | null
    tonnage4?: FloatNullableFilter | number | null
    circuit_id?: IntNullableFilter | number | null
    collecte_id?: IntNullableFilter | number | null
    observation?: StringNullableFilter | string | null
    geoloc_id?: IntNullableFilter | number | null
    anomaly?: AnomalyListRelationFilter
    outlet_report_visited_outlet4_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    outlet_report_visited_outlet2_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    outlet_report_default_outlet_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    collecte?: XOR<CollecteRelationFilter, collecteWhereInput> | null
    outlet_report_default_outlet3_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    outlet_report_visited_outlet3_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    outlet_report_visited_outlet_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    outlet_report_default_outlet2_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    truck?: XOR<TruckRelationFilter, truckWhereInput> | null
    flux?: XOR<FluxRelationFilter, fluxWhereInput> | null
    circuit?: XOR<CircuitRelationFilter, circuitWhereInput> | null
    outlet_report_default_outlet4_idTooutlet?: XOR<OutletRelationFilter, outletWhereInput> | null
    tablet?: XOR<TabletRelationFilter, tabletWhereInput> | null
  }

  export type reportOrderByWithRelationInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    date?: SortOrder
    manual_circuit?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    observation?: SortOrder
    geoloc_id?: SortOrder
    anomaly?: anomalyOrderByRelationAggregateInput
    outlet_report_visited_outlet4_idTooutlet?: outletOrderByWithRelationInput
    outlet_report_visited_outlet2_idTooutlet?: outletOrderByWithRelationInput
    outlet_report_default_outlet_idTooutlet?: outletOrderByWithRelationInput
    collecte?: collecteOrderByWithRelationInput
    outlet_report_default_outlet3_idTooutlet?: outletOrderByWithRelationInput
    outlet_report_visited_outlet3_idTooutlet?: outletOrderByWithRelationInput
    outlet_report_visited_outlet_idTooutlet?: outletOrderByWithRelationInput
    outlet_report_default_outlet2_idTooutlet?: outletOrderByWithRelationInput
    truck?: truckOrderByWithRelationInput
    flux?: fluxOrderByWithRelationInput
    circuit?: circuitOrderByWithRelationInput
    outlet_report_default_outlet4_idTooutlet?: outletOrderByWithRelationInput
    tablet?: tabletOrderByWithRelationInput
  }

  export type reportWhereUniqueInput = {
    id?: number
  }

  export type reportOrderByWithAggregationInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    date?: SortOrder
    manual_circuit?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    observation?: SortOrder
    geoloc_id?: SortOrder
    _count?: reportCountOrderByAggregateInput
    _avg?: reportAvgOrderByAggregateInput
    _max?: reportMaxOrderByAggregateInput
    _min?: reportMinOrderByAggregateInput
    _sum?: reportSumOrderByAggregateInput
  }

  export type reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reportScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    default_outlet_id?: IntNullableWithAggregatesFilter | number | null
    visited_outlet_id?: IntNullableWithAggregatesFilter | number | null
    flux_id?: IntNullableWithAggregatesFilter | number | null
    truck_id?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
    manual_circuit?: StringNullableWithAggregatesFilter | string | null
    total_bac_collected?: IntWithAggregatesFilter | number
    total_bac_rejected?: IntWithAggregatesFilter | number
    tonnage?: FloatNullableWithAggregatesFilter | number | null
    tonnage2?: FloatNullableWithAggregatesFilter | number | null
    default_outlet2_id?: IntNullableWithAggregatesFilter | number | null
    visited_outlet2_id?: IntNullableWithAggregatesFilter | number | null
    default_outlet3_id?: IntNullableWithAggregatesFilter | number | null
    visited_outlet3_id?: IntNullableWithAggregatesFilter | number | null
    default_outlet4_id?: IntNullableWithAggregatesFilter | number | null
    visited_outlet4_id?: IntNullableWithAggregatesFilter | number | null
    tonnage3?: FloatNullableWithAggregatesFilter | number | null
    tonnage4?: FloatNullableWithAggregatesFilter | number | null
    circuit_id?: IntNullableWithAggregatesFilter | number | null
    collecte_id?: IntNullableWithAggregatesFilter | number | null
    observation?: StringNullableWithAggregatesFilter | string | null
    geoloc_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type ripperWhereInput = {
    AND?: Enumerable<ripperWhereInput>
    OR?: Enumerable<ripperWhereInput>
    NOT?: Enumerable<ripperWhereInput>
    id?: IntFilter | number
    last_name?: StringFilter | string
    first_name?: StringFilter | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: Replacement_teamListRelationFilter
    replacement_team_replacement_team_substitute_ripper1_idToripper?: Replacement_teamListRelationFilter
    team_team_ripper1_idToripper?: XOR<TeamRelationFilter, teamWhereInput> | null
    team_team_ripper2_idToripper?: XOR<TeamRelationFilter, teamWhereInput> | null
  }

  export type ripperOrderByWithRelationInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamOrderByRelationAggregateInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamOrderByRelationAggregateInput
    team_team_ripper1_idToripper?: teamOrderByWithRelationInput
    team_team_ripper2_idToripper?: teamOrderByWithRelationInput
  }

  export type ripperWhereUniqueInput = {
    id?: number
  }

  export type ripperOrderByWithAggregationInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    _count?: ripperCountOrderByAggregateInput
    _avg?: ripperAvgOrderByAggregateInput
    _max?: ripperMaxOrderByAggregateInput
    _min?: ripperMinOrderByAggregateInput
    _sum?: ripperSumOrderByAggregateInput
  }

  export type ripperScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ripperScalarWhereWithAggregatesInput>
    OR?: Enumerable<ripperScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ripperScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    last_name?: StringWithAggregatesFilter | string
    first_name?: StringWithAggregatesFilter | string
  }

  export type sinisterWhereInput = {
    AND?: Enumerable<sinisterWhereInput>
    OR?: Enumerable<sinisterWhereInput>
    NOT?: Enumerable<sinisterWhereInput>
    id?: IntFilter | number
    truck_id?: IntNullableFilter | number | null
    driver_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    place?: StringFilter | string
    opposing_vehicule?: StringNullableFilter | string | null
    opposing_driver?: StringNullableFilter | string | null
    circumstance?: StringNullableFilter | string | null
    status?: StringFilter | string
    observation?: StringNullableFilter | string | null
    driver?: XOR<DriverRelationFilter, driverWhereInput> | null
    truck?: XOR<TruckRelationFilter, truckWhereInput> | null
  }

  export type sinisterOrderByWithRelationInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
    date?: SortOrder
    place?: SortOrder
    opposing_vehicule?: SortOrder
    opposing_driver?: SortOrder
    circumstance?: SortOrder
    status?: SortOrder
    observation?: SortOrder
    driver?: driverOrderByWithRelationInput
    truck?: truckOrderByWithRelationInput
  }

  export type sinisterWhereUniqueInput = {
    id?: number
  }

  export type sinisterOrderByWithAggregationInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
    date?: SortOrder
    place?: SortOrder
    opposing_vehicule?: SortOrder
    opposing_driver?: SortOrder
    circumstance?: SortOrder
    status?: SortOrder
    observation?: SortOrder
    _count?: sinisterCountOrderByAggregateInput
    _avg?: sinisterAvgOrderByAggregateInput
    _max?: sinisterMaxOrderByAggregateInput
    _min?: sinisterMinOrderByAggregateInput
    _sum?: sinisterSumOrderByAggregateInput
  }

  export type sinisterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sinisterScalarWhereWithAggregatesInput>
    OR?: Enumerable<sinisterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sinisterScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    truck_id?: IntNullableWithAggregatesFilter | number | null
    driver_id?: IntNullableWithAggregatesFilter | number | null
    date?: DateTimeWithAggregatesFilter | Date | string
    place?: StringWithAggregatesFilter | string
    opposing_vehicule?: StringNullableWithAggregatesFilter | string | null
    opposing_driver?: StringNullableWithAggregatesFilter | string | null
    circumstance?: StringNullableWithAggregatesFilter | string | null
    status?: StringWithAggregatesFilter | string
    observation?: StringNullableWithAggregatesFilter | string | null
  }

  export type tabletWhereInput = {
    AND?: Enumerable<tabletWhereInput>
    OR?: Enumerable<tabletWhereInput>
    NOT?: Enumerable<tabletWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    report?: ReportListRelationFilter
  }

  export type tabletOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    report?: reportOrderByRelationAggregateInput
  }

  export type tabletWhereUniqueInput = {
    id?: number
  }

  export type tabletOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    _count?: tabletCountOrderByAggregateInput
    _avg?: tabletAvgOrderByAggregateInput
    _max?: tabletMaxOrderByAggregateInput
    _min?: tabletMinOrderByAggregateInput
    _sum?: tabletSumOrderByAggregateInput
  }

  export type tabletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tabletScalarWhereWithAggregatesInput>
    OR?: Enumerable<tabletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tabletScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
  }

  export type teamWhereInput = {
    AND?: Enumerable<teamWhereInput>
    OR?: Enumerable<teamWhereInput>
    NOT?: Enumerable<teamWhereInput>
    id?: IntFilter | number
    driver_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    ripper1_id?: IntNullableFilter | number | null
    ripper2_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    replacement_team_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    manual_circuit?: StringNullableFilter | string | null
    manual_tablet?: StringNullableFilter | string | null
    ripper_team_ripper1_idToripper?: XOR<RipperRelationFilter, ripperWhereInput> | null
    ripper_team_ripper2_idToripper?: XOR<RipperRelationFilter, ripperWhereInput> | null
    driver?: XOR<DriverRelationFilter, driverWhereInput> | null
    truck?: XOR<TruckRelationFilter, truckWhereInput> | null
    flux?: XOR<FluxRelationFilter, fluxWhereInput> | null
    replacement_team?: XOR<Replacement_teamRelationFilter, replacement_teamWhereInput> | null
  }

  export type teamOrderByWithRelationInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
    name?: SortOrder
    manual_circuit?: SortOrder
    manual_tablet?: SortOrder
    ripper_team_ripper1_idToripper?: ripperOrderByWithRelationInput
    ripper_team_ripper2_idToripper?: ripperOrderByWithRelationInput
    driver?: driverOrderByWithRelationInput
    truck?: truckOrderByWithRelationInput
    flux?: fluxOrderByWithRelationInput
    replacement_team?: replacement_teamOrderByWithRelationInput
  }

  export type teamWhereUniqueInput = {
    id?: number
    driver_id?: number
    ripper1_id?: number
    ripper2_id?: number
    replacement_team_id?: number
  }

  export type teamOrderByWithAggregationInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
    name?: SortOrder
    manual_circuit?: SortOrder
    manual_tablet?: SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<teamScalarWhereWithAggregatesInput>
    OR?: Enumerable<teamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<teamScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    driver_id?: IntNullableWithAggregatesFilter | number | null
    flux_id?: IntNullableWithAggregatesFilter | number | null
    ripper1_id?: IntNullableWithAggregatesFilter | number | null
    ripper2_id?: IntNullableWithAggregatesFilter | number | null
    truck_id?: IntNullableWithAggregatesFilter | number | null
    replacement_team_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    manual_circuit?: StringNullableWithAggregatesFilter | string | null
    manual_tablet?: StringNullableWithAggregatesFilter | string | null
  }

  export type townWhereInput = {
    AND?: Enumerable<townWhereInput>
    OR?: Enumerable<townWhereInput>
    NOT?: Enumerable<townWhereInput>
    id?: IntFilter | number
    circuit_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    postal_code?: IntFilter | number
    circuit?: XOR<CircuitRelationFilter, circuitWhereInput> | null
    way?: WayListRelationFilter
    worksite?: WorksiteListRelationFilter
  }

  export type townOrderByWithRelationInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    circuit?: circuitOrderByWithRelationInput
    way?: wayOrderByRelationAggregateInput
    worksite?: worksiteOrderByRelationAggregateInput
  }

  export type townWhereUniqueInput = {
    id?: number
  }

  export type townOrderByWithAggregationInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
    _count?: townCountOrderByAggregateInput
    _avg?: townAvgOrderByAggregateInput
    _max?: townMaxOrderByAggregateInput
    _min?: townMinOrderByAggregateInput
    _sum?: townSumOrderByAggregateInput
  }

  export type townScalarWhereWithAggregatesInput = {
    AND?: Enumerable<townScalarWhereWithAggregatesInput>
    OR?: Enumerable<townScalarWhereWithAggregatesInput>
    NOT?: Enumerable<townScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    circuit_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    postal_code?: IntWithAggregatesFilter | number
  }

  export type truckWhereInput = {
    AND?: Enumerable<truckWhereInput>
    OR?: Enumerable<truckWhereInput>
    NOT?: Enumerable<truckWhereInput>
    id?: IntFilter | number
    registration?: StringFilter | string
    type?: StringNullableFilter | string | null
    container_mouvement?: Container_mouvementListRelationFilter
    report?: ReportListRelationFilter
    sinister?: SinisterListRelationFilter
    team?: TeamListRelationFilter
  }

  export type truckOrderByWithRelationInput = {
    id?: SortOrder
    registration?: SortOrder
    type?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
    report?: reportOrderByRelationAggregateInput
    sinister?: sinisterOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
  }

  export type truckWhereUniqueInput = {
    id?: number
  }

  export type truckOrderByWithAggregationInput = {
    id?: SortOrder
    registration?: SortOrder
    type?: SortOrder
    _count?: truckCountOrderByAggregateInput
    _avg?: truckAvgOrderByAggregateInput
    _max?: truckMaxOrderByAggregateInput
    _min?: truckMinOrderByAggregateInput
    _sum?: truckSumOrderByAggregateInput
  }

  export type truckScalarWhereWithAggregatesInput = {
    AND?: Enumerable<truckScalarWhereWithAggregatesInput>
    OR?: Enumerable<truckScalarWhereWithAggregatesInput>
    NOT?: Enumerable<truckScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    registration?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
  }

  export type type_anomalyWhereInput = {
    AND?: Enumerable<type_anomalyWhereInput>
    OR?: Enumerable<type_anomalyWhereInput>
    NOT?: Enumerable<type_anomalyWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    anomaly?: AnomalyListRelationFilter
  }

  export type type_anomalyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    anomaly?: anomalyOrderByRelationAggregateInput
  }

  export type type_anomalyWhereUniqueInput = {
    id?: number
  }

  export type type_anomalyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: type_anomalyCountOrderByAggregateInput
    _avg?: type_anomalyAvgOrderByAggregateInput
    _max?: type_anomalyMaxOrderByAggregateInput
    _min?: type_anomalyMinOrderByAggregateInput
    _sum?: type_anomalySumOrderByAggregateInput
  }

  export type type_anomalyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<type_anomalyScalarWhereWithAggregatesInput>
    OR?: Enumerable<type_anomalyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<type_anomalyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    roles?: JsonFilter
    password?: StringFilter | string
    refresh_token?: StringFilter | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type userWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    roles?: JsonWithAggregatesFilter
    password?: StringWithAggregatesFilter | string
    refresh_token?: StringWithAggregatesFilter | string
  }

  export type wayWhereInput = {
    AND?: Enumerable<wayWhereInput>
    OR?: Enumerable<wayWhereInput>
    NOT?: Enumerable<wayWhereInput>
    id?: IntFilter | number
    town_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    type?: StringNullableFilter | string | null
    anomaly?: AnomalyListRelationFilter
    town?: XOR<TownRelationFilter, townWhereInput> | null
  }

  export type wayOrderByWithRelationInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    anomaly?: anomalyOrderByRelationAggregateInput
    town?: townOrderByWithRelationInput
  }

  export type wayWhereUniqueInput = {
    id?: number
  }

  export type wayOrderByWithAggregationInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: wayCountOrderByAggregateInput
    _avg?: wayAvgOrderByAggregateInput
    _max?: wayMaxOrderByAggregateInput
    _min?: wayMinOrderByAggregateInput
    _sum?: waySumOrderByAggregateInput
  }

  export type wayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<wayScalarWhereWithAggregatesInput>
    OR?: Enumerable<wayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<wayScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    town_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
  }

  export type worksiteWhereInput = {
    AND?: Enumerable<worksiteWhereInput>
    OR?: Enumerable<worksiteWhereInput>
    NOT?: Enumerable<worksiteWhereInput>
    id?: IntFilter | number
    town_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    adress?: StringNullableFilter | string | null
    container_mouvement?: Container_mouvementListRelationFilter
    town?: XOR<TownRelationFilter, townWhereInput> | null
  }

  export type worksiteOrderByWithRelationInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    adress?: SortOrder
    container_mouvement?: container_mouvementOrderByRelationAggregateInput
    town?: townOrderByWithRelationInput
  }

  export type worksiteWhereUniqueInput = {
    id?: number
  }

  export type worksiteOrderByWithAggregationInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    adress?: SortOrder
    _count?: worksiteCountOrderByAggregateInput
    _avg?: worksiteAvgOrderByAggregateInput
    _max?: worksiteMaxOrderByAggregateInput
    _min?: worksiteMinOrderByAggregateInput
    _sum?: worksiteSumOrderByAggregateInput
  }

  export type worksiteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<worksiteScalarWhereWithAggregatesInput>
    OR?: Enumerable<worksiteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<worksiteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    town_id?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    adress?: StringNullableWithAggregatesFilter | string | null
  }

  export type anomalyCreateInput = {
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    report?: reportCreateNestedOneWithoutAnomalyInput
    way?: wayCreateNestedOneWithoutAnomalyInput
    type_anomaly?: type_anomalyCreateNestedOneWithoutAnomalyInput
  }

  export type anomalyUncheckedCreateInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportUpdateOneWithoutAnomalyNestedInput
    way?: wayUpdateOneWithoutAnomalyNestedInput
    type_anomaly?: type_anomalyUpdateOneWithoutAnomalyNestedInput
  }

  export type anomalyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    way_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    report_id?: NullableIntFieldUpdateOperationsInput | number | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    type_anomaly_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type anomalyCreateManyInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type anomalyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    way_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    report_id?: NullableIntFieldUpdateOperationsInput | number | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    type_anomaly_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type circuitCreateInput = {
    name: string
    outlet?: outletCreateNestedOneWithoutCircuitInput
    flux?: fluxCreateNestedManyWithoutCircuitInput
    report?: reportCreateNestedManyWithoutCircuitInput
    town?: townCreateNestedManyWithoutCircuitInput
  }

  export type circuitUncheckedCreateInput = {
    id?: number
    default_outlet_id?: number | null
    name: string
    flux?: fluxUncheckedCreateNestedManyWithoutCircuitInput
    report?: reportUncheckedCreateNestedManyWithoutCircuitInput
    town?: townUncheckedCreateNestedManyWithoutCircuitInput
  }

  export type circuitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneWithoutCircuitNestedInput
    flux?: fluxUpdateManyWithoutCircuitNestedInput
    report?: reportUpdateManyWithoutCircuitNestedInput
    town?: townUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    flux?: fluxUncheckedUpdateManyWithoutCircuitNestedInput
    report?: reportUncheckedUpdateManyWithoutCircuitNestedInput
    town?: townUncheckedUpdateManyWithoutCircuitNestedInput
  }

  export type circuitCreateManyInput = {
    id?: number
    default_outlet_id?: number | null
    name: string
  }

  export type circuitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type circuitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type collecteCreateInput = {
    date: Date | string
    observation: string
    is_valid: boolean
    collecte_observation?: collecte_observationCreateNestedManyWithoutCollecteInput
    report?: reportCreateNestedManyWithoutCollecteInput
  }

  export type collecteUncheckedCreateInput = {
    id?: number
    date: Date | string
    observation: string
    is_valid: boolean
    collecte_observation?: collecte_observationUncheckedCreateNestedManyWithoutCollecteInput
    report?: reportUncheckedCreateNestedManyWithoutCollecteInput
  }

  export type collecteUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    collecte_observation?: collecte_observationUpdateManyWithoutCollecteNestedInput
    report?: reportUpdateManyWithoutCollecteNestedInput
  }

  export type collecteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    collecte_observation?: collecte_observationUncheckedUpdateManyWithoutCollecteNestedInput
    report?: reportUncheckedUpdateManyWithoutCollecteNestedInput
  }

  export type collecteCreateManyInput = {
    id?: number
    date: Date | string
    observation: string
    is_valid: boolean
  }

  export type collecteUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collecteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type collecte_observationCreateInput = {
    description: string
    collecte?: collecteCreateNestedOneWithoutCollecte_observationInput
  }

  export type collecte_observationUncheckedCreateInput = {
    id?: number
    collecte_id?: number | null
    description: string
  }

  export type collecte_observationUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    collecte?: collecteUpdateOneWithoutCollecte_observationNestedInput
  }

  export type collecte_observationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type collecte_observationCreateManyInput = {
    id?: number
    collecte_id?: number | null
    description: string
  }

  export type collecte_observationUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type collecte_observationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type container_mouvementCreateInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type container_mouvementCreateManyInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type container_mouvementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type container_typeCreateInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutContainer_typeInput
  }

  export type container_typeUncheckedCreateInput = {
    id?: number
    name: string
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutContainer_typeInput
  }

  export type container_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutContainer_typeNestedInput
  }

  export type container_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutContainer_typeNestedInput
  }

  export type container_typeCreateManyInput = {
    id?: number
    name: string
  }

  export type container_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type container_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type doctrine_migration_versionsCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUncheckedCreateInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsCreateManyInput = {
    version: string
    executed_at?: Date | string | null
    execution_time?: number | null
  }

  export type doctrine_migration_versionsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type doctrine_migration_versionsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    executed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    execution_time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type driverCreateInput = {
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamCreateNestedManyWithoutDriverInput
    sinister?: sinisterCreateNestedManyWithoutDriverInput
    team?: teamCreateNestedOneWithoutDriverInput
  }

  export type driverUncheckedCreateInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamUncheckedCreateNestedManyWithoutDriverInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutDriverInput
    team?: teamUncheckedCreateNestedOneWithoutDriverInput
  }

  export type driverUpdateInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUpdateManyWithoutDriverNestedInput
    team?: teamUpdateOneWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUncheckedUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutDriverNestedInput
    team?: teamUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type driverCreateManyInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
  }

  export type driverUpdateManyMutationInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fluxCreateInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutFluxInput
    circuit?: circuitCreateNestedOneWithoutFluxInput
    report?: reportCreateNestedManyWithoutFluxInput
    team?: teamCreateNestedManyWithoutFluxInput
  }

  export type fluxUncheckedCreateInput = {
    id?: number
    name: string
    circuit_id?: number | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutFluxInput
    report?: reportUncheckedCreateNestedManyWithoutFluxInput
    team?: teamUncheckedCreateNestedManyWithoutFluxInput
  }

  export type fluxUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutFluxNestedInput
    circuit?: circuitUpdateOneWithoutFluxNestedInput
    report?: reportUpdateManyWithoutFluxNestedInput
    team?: teamUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutFluxNestedInput
    report?: reportUncheckedUpdateManyWithoutFluxNestedInput
    team?: teamUncheckedUpdateManyWithoutFluxNestedInput
  }

  export type fluxCreateManyInput = {
    id?: number
    name: string
    circuit_id?: number | null
  }

  export type fluxUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type fluxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type messenger_messagesCreateInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUncheckedCreateInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesCreateManyInput = {
    id?: bigint | number
    body: string
    headers: string
    queue_name: string
    created_at: Date | string
    available_at: Date | string
    delivered_at?: Date | string | null
  }

  export type messenger_messagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type messenger_messagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    body?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    queue_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_at?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type operation_typeCreateInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutOperation_typeInput
  }

  export type operation_typeUncheckedCreateInput = {
    id?: number
    name: string
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOperation_typeInput
  }

  export type operation_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutOperation_typeNestedInput
  }

  export type operation_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOperation_typeNestedInput
  }

  export type operation_typeCreateManyInput = {
    id?: number
    name: string
  }

  export type operation_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type operation_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type outletCreateInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletCreateManyInput = {
    id?: number
    name: string
  }

  export type outletUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type outletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type replacement_teamCreateInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    driver?: driverCreateNestedOneWithoutReplacement_teamInput
    team?: teamCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUncheckedCreateInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper1_id?: number | null
    substitute_ripper2_id?: number | null
    team?: teamUncheckedCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUpdateInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperNestedInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperNestedInput
    driver?: driverUpdateOneWithoutReplacement_teamNestedInput
    team?: teamUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    team?: teamUncheckedUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamCreateManyInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper1_id?: number | null
    substitute_ripper2_id?: number | null
  }

  export type replacement_teamUpdateManyMutationInput = {

  }

  export type replacement_teamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportCreateInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportCreateManyInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ripperCreateInput = {
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperUncheckedCreateInput = {
    id?: number
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperUpdateInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperCreateManyInput = {
    id?: number
    last_name: string
    first_name: string
  }

  export type ripperUpdateManyMutationInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
  }

  export type ripperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
  }

  export type sinisterCreateInput = {
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
    driver?: driverCreateNestedOneWithoutSinisterInput
    truck?: truckCreateNestedOneWithoutSinisterInput
  }

  export type sinisterUncheckedCreateInput = {
    id?: number
    truck_id?: number | null
    driver_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type sinisterUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    driver?: driverUpdateOneWithoutSinisterNestedInput
    truck?: truckUpdateOneWithoutSinisterNestedInput
  }

  export type sinisterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sinisterCreateManyInput = {
    id?: number
    truck_id?: number | null
    driver_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type sinisterUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sinisterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tabletCreateInput = {
    label: string
    report?: reportCreateNestedManyWithoutTabletInput
  }

  export type tabletUncheckedCreateInput = {
    id?: number
    label: string
    report?: reportUncheckedCreateNestedManyWithoutTabletInput
  }

  export type tabletUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    report?: reportUpdateManyWithoutTabletNestedInput
  }

  export type tabletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    report?: reportUncheckedUpdateManyWithoutTabletNestedInput
  }

  export type tabletCreateManyInput = {
    id?: number
    label: string
  }

  export type tabletUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type tabletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type teamCreateInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    truck?: truckCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamCreateManyInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type townCreateInput = {
    name: string
    postal_code: number
    circuit?: circuitCreateNestedOneWithoutTownInput
    way?: wayCreateNestedManyWithoutTownInput
    worksite?: worksiteCreateNestedManyWithoutTownInput
  }

  export type townUncheckedCreateInput = {
    id?: number
    circuit_id?: number | null
    name: string
    postal_code: number
    way?: wayUncheckedCreateNestedManyWithoutTownInput
    worksite?: worksiteUncheckedCreateNestedManyWithoutTownInput
  }

  export type townUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    circuit?: circuitUpdateOneWithoutTownNestedInput
    way?: wayUpdateManyWithoutTownNestedInput
    worksite?: worksiteUpdateManyWithoutTownNestedInput
  }

  export type townUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    way?: wayUncheckedUpdateManyWithoutTownNestedInput
    worksite?: worksiteUncheckedUpdateManyWithoutTownNestedInput
  }

  export type townCreateManyInput = {
    id?: number
    circuit_id?: number | null
    name: string
    postal_code: number
  }

  export type townUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
  }

  export type townUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
  }

  export type truckCreateInput = {
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutTruckInput
    report?: reportCreateNestedManyWithoutTruckInput
    sinister?: sinisterCreateNestedManyWithoutTruckInput
    team?: teamCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateInput = {
    id?: number
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutTruckInput
    report?: reportUncheckedCreateNestedManyWithoutTruckInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutTruckInput
    team?: teamUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckUpdateInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutTruckNestedInput
    report?: reportUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUpdateManyWithoutTruckNestedInput
    team?: teamUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutTruckNestedInput
    report?: reportUncheckedUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutTruckNestedInput
    team?: teamUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type truckCreateManyInput = {
    id?: number
    registration: string
    type?: string | null
  }

  export type truckUpdateManyMutationInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type truckUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_anomalyCreateInput = {
    name: string
    anomaly?: anomalyCreateNestedManyWithoutType_anomalyInput
  }

  export type type_anomalyUncheckedCreateInput = {
    id?: number
    name: string
    anomaly?: anomalyUncheckedCreateNestedManyWithoutType_anomalyInput
  }

  export type type_anomalyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    anomaly?: anomalyUpdateManyWithoutType_anomalyNestedInput
  }

  export type type_anomalyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    anomaly?: anomalyUncheckedUpdateManyWithoutType_anomalyNestedInput
  }

  export type type_anomalyCreateManyInput = {
    id?: number
    name: string
  }

  export type type_anomalyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_anomalyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    refresh_token: string
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    refresh_token: string
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    roles: JsonNullValueInput | InputJsonValue
    password: string
    refresh_token: string
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    roles?: JsonNullValueInput | InputJsonValue
    password?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type wayCreateInput = {
    name: string
    type?: string | null
    anomaly?: anomalyCreateNestedManyWithoutWayInput
    town?: townCreateNestedOneWithoutWayInput
  }

  export type wayUncheckedCreateInput = {
    id?: number
    town_id?: number | null
    name: string
    type?: string | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutWayInput
  }

  export type wayUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutWayNestedInput
    town?: townUpdateOneWithoutWayNestedInput
  }

  export type wayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUncheckedUpdateManyWithoutWayNestedInput
  }

  export type wayCreateManyInput = {
    id?: number
    town_id?: number | null
    name: string
    type?: string | null
  }

  export type wayUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type worksiteCreateInput = {
    name: string
    adress?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutWorksiteInput
    town?: townCreateNestedOneWithoutWorksiteInput
  }

  export type worksiteUncheckedCreateInput = {
    id?: number
    town_id?: number | null
    name: string
    adress?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutWorksiteInput
  }

  export type worksiteUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutWorksiteNestedInput
    town?: townUpdateOneWithoutWorksiteNestedInput
  }

  export type worksiteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutWorksiteNestedInput
  }

  export type worksiteCreateManyInput = {
    id?: number
    town_id?: number | null
    name: string
    adress?: string | null
  }

  export type worksiteUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type worksiteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ReportRelationFilter = {
    is?: reportWhereInput | null
    isNot?: reportWhereInput | null
  }

  export type WayRelationFilter = {
    is?: wayWhereInput | null
    isNot?: wayWhereInput | null
  }

  export type Type_anomalyRelationFilter = {
    is?: type_anomalyWhereInput | null
    isNot?: type_anomalyWhereInput | null
  }

  export type anomalyCountOrderByAggregateInput = {
    id?: SortOrder
    way_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    is_collected?: SortOrder
    regularization_date?: SortOrder
    description?: SortOrder
    report_id?: SortOrder
    manual_town?: SortOrder
    manual_way?: SortOrder
    manual_flux?: SortOrder
    manual_truck?: SortOrder
    type_anomaly_id?: SortOrder
  }

  export type anomalyAvgOrderByAggregateInput = {
    id?: SortOrder
    way_id?: SortOrder
    report_id?: SortOrder
    type_anomaly_id?: SortOrder
  }

  export type anomalyMaxOrderByAggregateInput = {
    id?: SortOrder
    way_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    is_collected?: SortOrder
    regularization_date?: SortOrder
    description?: SortOrder
    report_id?: SortOrder
    manual_town?: SortOrder
    manual_way?: SortOrder
    manual_flux?: SortOrder
    manual_truck?: SortOrder
    type_anomaly_id?: SortOrder
  }

  export type anomalyMinOrderByAggregateInput = {
    id?: SortOrder
    way_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    is_collected?: SortOrder
    regularization_date?: SortOrder
    description?: SortOrder
    report_id?: SortOrder
    manual_town?: SortOrder
    manual_way?: SortOrder
    manual_flux?: SortOrder
    manual_truck?: SortOrder
    type_anomaly_id?: SortOrder
  }

  export type anomalySumOrderByAggregateInput = {
    id?: SortOrder
    way_id?: SortOrder
    report_id?: SortOrder
    type_anomaly_id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type OutletRelationFilter = {
    is?: outletWhereInput | null
    isNot?: outletWhereInput | null
  }

  export type FluxListRelationFilter = {
    every?: fluxWhereInput
    some?: fluxWhereInput
    none?: fluxWhereInput
  }

  export type ReportListRelationFilter = {
    every?: reportWhereInput
    some?: reportWhereInput
    none?: reportWhereInput
  }

  export type TownListRelationFilter = {
    every?: townWhereInput
    some?: townWhereInput
    none?: townWhereInput
  }

  export type fluxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type townOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type circuitCountOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    name?: SortOrder
  }

  export type circuitAvgOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
  }

  export type circuitMaxOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    name?: SortOrder
  }

  export type circuitMinOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    name?: SortOrder
  }

  export type circuitSumOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type Collecte_observationListRelationFilter = {
    every?: collecte_observationWhereInput
    some?: collecte_observationWhereInput
    none?: collecte_observationWhereInput
  }

  export type collecte_observationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collecteCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    observation?: SortOrder
    is_valid?: SortOrder
  }

  export type collecteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type collecteMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    observation?: SortOrder
    is_valid?: SortOrder
  }

  export type collecteMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    observation?: SortOrder
    is_valid?: SortOrder
  }

  export type collecteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type CollecteRelationFilter = {
    is?: collecteWhereInput | null
    isNot?: collecteWhereInput | null
  }

  export type collecte_observationCountOrderByAggregateInput = {
    id?: SortOrder
    collecte_id?: SortOrder
    description?: SortOrder
  }

  export type collecte_observationAvgOrderByAggregateInput = {
    id?: SortOrder
    collecte_id?: SortOrder
  }

  export type collecte_observationMaxOrderByAggregateInput = {
    id?: SortOrder
    collecte_id?: SortOrder
    description?: SortOrder
  }

  export type collecte_observationMinOrderByAggregateInput = {
    id?: SortOrder
    collecte_id?: SortOrder
    description?: SortOrder
  }

  export type collecte_observationSumOrderByAggregateInput = {
    id?: SortOrder
    collecte_id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type Container_typeRelationFilter = {
    is?: container_typeWhereInput | null
    isNot?: container_typeWhereInput | null
  }

  export type Operation_typeRelationFilter = {
    is?: operation_typeWhereInput | null
    isNot?: operation_typeWhereInput | null
  }

  export type WorksiteRelationFilter = {
    is?: worksiteWhereInput | null
    isNot?: worksiteWhereInput | null
  }

  export type DriverRelationFilter = {
    is?: driverWhereInput | null
    isNot?: driverWhereInput | null
  }

  export type TruckRelationFilter = {
    is?: truckWhereInput | null
    isNot?: truckWhereInput | null
  }

  export type FluxRelationFilter = {
    is?: fluxWhereInput | null
    isNot?: fluxWhereInput | null
  }

  export type container_mouvementCountOrderByAggregateInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    description?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
    date?: SortOrder
  }

  export type container_mouvementAvgOrderByAggregateInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
  }

  export type container_mouvementMaxOrderByAggregateInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    description?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
    date?: SortOrder
  }

  export type container_mouvementMinOrderByAggregateInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    description?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
    date?: SortOrder
  }

  export type container_mouvementSumOrderByAggregateInput = {
    id?: SortOrder
    worksite_id?: SortOrder
    driver_id?: SortOrder
    truck_id?: SortOrder
    flux_id?: SortOrder
    outlet_id?: SortOrder
    tonnage?: SortOrder
    operation_type_id?: SortOrder
    container_type_id?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type Container_mouvementListRelationFilter = {
    every?: container_mouvementWhereInput
    some?: container_mouvementWhereInput
    none?: container_mouvementWhereInput
  }

  export type container_mouvementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type container_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type container_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type container_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type container_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type container_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type doctrine_migration_versionsCountOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsAvgOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMaxOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsMinOrderByAggregateInput = {
    version?: SortOrder
    executed_at?: SortOrder
    execution_time?: SortOrder
  }

  export type doctrine_migration_versionsSumOrderByAggregateInput = {
    execution_time?: SortOrder
  }

  export type Replacement_teamListRelationFilter = {
    every?: replacement_teamWhereInput
    some?: replacement_teamWhereInput
    none?: replacement_teamWhereInput
  }

  export type SinisterListRelationFilter = {
    every?: sinisterWhereInput
    some?: sinisterWhereInput
    none?: sinisterWhereInput
  }

  export type TeamRelationFilter = {
    is?: teamWhereInput | null
    isNot?: teamWhereInput | null
  }

  export type replacement_teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sinisterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type driverCountOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    type?: SortOrder
  }

  export type driverAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type driverMaxOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    type?: SortOrder
  }

  export type driverMinOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
    type?: SortOrder
  }

  export type driverSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CircuitRelationFilter = {
    is?: circuitWhereInput | null
    isNot?: circuitWhereInput | null
  }

  export type TeamListRelationFilter = {
    every?: teamWhereInput
    some?: teamWhereInput
    none?: teamWhereInput
  }

  export type teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fluxCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    circuit_id?: SortOrder
  }

  export type fluxAvgOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
  }

  export type fluxMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    circuit_id?: SortOrder
  }

  export type fluxMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    circuit_id?: SortOrder
  }

  export type fluxSumOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type messenger_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type messenger_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    headers?: SortOrder
    queue_name?: SortOrder
    created_at?: SortOrder
    available_at?: SortOrder
    delivered_at?: SortOrder
  }

  export type messenger_messagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type operation_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type operation_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type operation_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type operation_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type operation_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CircuitListRelationFilter = {
    every?: circuitWhereInput
    some?: circuitWhereInput
    none?: circuitWhereInput
  }

  export type circuitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type outletCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type outletAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type outletMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type outletMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type outletSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RipperRelationFilter = {
    is?: ripperWhereInput | null
    isNot?: ripperWhereInput | null
  }

  export type replacement_teamCountOrderByAggregateInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
  }

  export type replacement_teamAvgOrderByAggregateInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
  }

  export type replacement_teamMaxOrderByAggregateInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
  }

  export type replacement_teamMinOrderByAggregateInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
  }

  export type replacement_teamSumOrderByAggregateInput = {
    id?: SortOrder
    substitute_driver_id?: SortOrder
    substitute_ripper1_id?: SortOrder
    substitute_ripper2_id?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type AnomalyListRelationFilter = {
    every?: anomalyWhereInput
    some?: anomalyWhereInput
    none?: anomalyWhereInput
  }

  export type TabletRelationFilter = {
    is?: tabletWhereInput | null
    isNot?: tabletWhereInput | null
  }

  export type anomalyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportCountOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    date?: SortOrder
    manual_circuit?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    observation?: SortOrder
    geoloc_id?: SortOrder
  }

  export type reportAvgOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    geoloc_id?: SortOrder
  }

  export type reportMaxOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    date?: SortOrder
    manual_circuit?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    observation?: SortOrder
    geoloc_id?: SortOrder
  }

  export type reportMinOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    date?: SortOrder
    manual_circuit?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    observation?: SortOrder
    geoloc_id?: SortOrder
  }

  export type reportSumOrderByAggregateInput = {
    id?: SortOrder
    default_outlet_id?: SortOrder
    visited_outlet_id?: SortOrder
    flux_id?: SortOrder
    truck_id?: SortOrder
    total_bac_collected?: SortOrder
    total_bac_rejected?: SortOrder
    tonnage?: SortOrder
    tonnage2?: SortOrder
    default_outlet2_id?: SortOrder
    visited_outlet2_id?: SortOrder
    default_outlet3_id?: SortOrder
    visited_outlet3_id?: SortOrder
    default_outlet4_id?: SortOrder
    visited_outlet4_id?: SortOrder
    tonnage3?: SortOrder
    tonnage4?: SortOrder
    circuit_id?: SortOrder
    collecte_id?: SortOrder
    geoloc_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type ripperCountOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
  }

  export type ripperAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ripperMaxOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
  }

  export type ripperMinOrderByAggregateInput = {
    id?: SortOrder
    last_name?: SortOrder
    first_name?: SortOrder
  }

  export type ripperSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sinisterCountOrderByAggregateInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
    date?: SortOrder
    place?: SortOrder
    opposing_vehicule?: SortOrder
    opposing_driver?: SortOrder
    circumstance?: SortOrder
    status?: SortOrder
    observation?: SortOrder
  }

  export type sinisterAvgOrderByAggregateInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
  }

  export type sinisterMaxOrderByAggregateInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
    date?: SortOrder
    place?: SortOrder
    opposing_vehicule?: SortOrder
    opposing_driver?: SortOrder
    circumstance?: SortOrder
    status?: SortOrder
    observation?: SortOrder
  }

  export type sinisterMinOrderByAggregateInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
    date?: SortOrder
    place?: SortOrder
    opposing_vehicule?: SortOrder
    opposing_driver?: SortOrder
    circumstance?: SortOrder
    status?: SortOrder
    observation?: SortOrder
  }

  export type sinisterSumOrderByAggregateInput = {
    id?: SortOrder
    truck_id?: SortOrder
    driver_id?: SortOrder
  }

  export type tabletCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type tabletAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tabletMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type tabletMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
  }

  export type tabletSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Replacement_teamRelationFilter = {
    is?: replacement_teamWhereInput | null
    isNot?: replacement_teamWhereInput | null
  }

  export type teamCountOrderByAggregateInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
    name?: SortOrder
    manual_circuit?: SortOrder
    manual_tablet?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
    name?: SortOrder
    manual_circuit?: SortOrder
    manual_tablet?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
    name?: SortOrder
    manual_circuit?: SortOrder
    manual_tablet?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    id?: SortOrder
    driver_id?: SortOrder
    flux_id?: SortOrder
    ripper1_id?: SortOrder
    ripper2_id?: SortOrder
    truck_id?: SortOrder
    replacement_team_id?: SortOrder
  }

  export type WayListRelationFilter = {
    every?: wayWhereInput
    some?: wayWhereInput
    none?: wayWhereInput
  }

  export type WorksiteListRelationFilter = {
    every?: worksiteWhereInput
    some?: worksiteWhereInput
    none?: worksiteWhereInput
  }

  export type wayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type worksiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type townCountOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
  }

  export type townAvgOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    postal_code?: SortOrder
  }

  export type townMaxOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
  }

  export type townMinOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    name?: SortOrder
    postal_code?: SortOrder
  }

  export type townSumOrderByAggregateInput = {
    id?: SortOrder
    circuit_id?: SortOrder
    postal_code?: SortOrder
  }

  export type truckCountOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    type?: SortOrder
  }

  export type truckAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type truckMaxOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    type?: SortOrder
  }

  export type truckMinOrderByAggregateInput = {
    id?: SortOrder
    registration?: SortOrder
    type?: SortOrder
  }

  export type truckSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type type_anomalyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_anomalyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type type_anomalyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_anomalyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_anomalySumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    roles?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    refresh_token?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type TownRelationFilter = {
    is?: townWhereInput | null
    isNot?: townWhereInput | null
  }

  export type wayCountOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type wayAvgOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
  }

  export type wayMaxOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type wayMinOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type waySumOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
  }

  export type worksiteCountOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    adress?: SortOrder
  }

  export type worksiteAvgOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
  }

  export type worksiteMaxOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    adress?: SortOrder
  }

  export type worksiteMinOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
    name?: SortOrder
    adress?: SortOrder
  }

  export type worksiteSumOrderByAggregateInput = {
    id?: SortOrder
    town_id?: SortOrder
  }

  export type reportCreateNestedOneWithoutAnomalyInput = {
    create?: XOR<reportCreateWithoutAnomalyInput, reportUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: reportCreateOrConnectWithoutAnomalyInput
    connect?: reportWhereUniqueInput
  }

  export type wayCreateNestedOneWithoutAnomalyInput = {
    create?: XOR<wayCreateWithoutAnomalyInput, wayUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: wayCreateOrConnectWithoutAnomalyInput
    connect?: wayWhereUniqueInput
  }

  export type type_anomalyCreateNestedOneWithoutAnomalyInput = {
    create?: XOR<type_anomalyCreateWithoutAnomalyInput, type_anomalyUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: type_anomalyCreateOrConnectWithoutAnomalyInput
    connect?: type_anomalyWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type reportUpdateOneWithoutAnomalyNestedInput = {
    create?: XOR<reportCreateWithoutAnomalyInput, reportUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: reportCreateOrConnectWithoutAnomalyInput
    upsert?: reportUpsertWithoutAnomalyInput
    disconnect?: boolean
    delete?: boolean
    connect?: reportWhereUniqueInput
    update?: XOR<reportUpdateWithoutAnomalyInput, reportUncheckedUpdateWithoutAnomalyInput>
  }

  export type wayUpdateOneWithoutAnomalyNestedInput = {
    create?: XOR<wayCreateWithoutAnomalyInput, wayUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: wayCreateOrConnectWithoutAnomalyInput
    upsert?: wayUpsertWithoutAnomalyInput
    disconnect?: boolean
    delete?: boolean
    connect?: wayWhereUniqueInput
    update?: XOR<wayUpdateWithoutAnomalyInput, wayUncheckedUpdateWithoutAnomalyInput>
  }

  export type type_anomalyUpdateOneWithoutAnomalyNestedInput = {
    create?: XOR<type_anomalyCreateWithoutAnomalyInput, type_anomalyUncheckedCreateWithoutAnomalyInput>
    connectOrCreate?: type_anomalyCreateOrConnectWithoutAnomalyInput
    upsert?: type_anomalyUpsertWithoutAnomalyInput
    disconnect?: boolean
    delete?: boolean
    connect?: type_anomalyWhereUniqueInput
    update?: XOR<type_anomalyUpdateWithoutAnomalyInput, type_anomalyUncheckedUpdateWithoutAnomalyInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type outletCreateNestedOneWithoutCircuitInput = {
    create?: XOR<outletCreateWithoutCircuitInput, outletUncheckedCreateWithoutCircuitInput>
    connectOrCreate?: outletCreateOrConnectWithoutCircuitInput
    connect?: outletWhereUniqueInput
  }

  export type fluxCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<fluxCreateWithoutCircuitInput>, Enumerable<fluxUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<fluxCreateOrConnectWithoutCircuitInput>
    createMany?: fluxCreateManyCircuitInputEnvelope
    connect?: Enumerable<fluxWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<reportCreateWithoutCircuitInput>, Enumerable<reportUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCircuitInput>
    createMany?: reportCreateManyCircuitInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type townCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<townCreateWithoutCircuitInput>, Enumerable<townUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<townCreateOrConnectWithoutCircuitInput>
    createMany?: townCreateManyCircuitInputEnvelope
    connect?: Enumerable<townWhereUniqueInput>
  }

  export type fluxUncheckedCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<fluxCreateWithoutCircuitInput>, Enumerable<fluxUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<fluxCreateOrConnectWithoutCircuitInput>
    createMany?: fluxCreateManyCircuitInputEnvelope
    connect?: Enumerable<fluxWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<reportCreateWithoutCircuitInput>, Enumerable<reportUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCircuitInput>
    createMany?: reportCreateManyCircuitInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type townUncheckedCreateNestedManyWithoutCircuitInput = {
    create?: XOR<Enumerable<townCreateWithoutCircuitInput>, Enumerable<townUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<townCreateOrConnectWithoutCircuitInput>
    createMany?: townCreateManyCircuitInputEnvelope
    connect?: Enumerable<townWhereUniqueInput>
  }

  export type outletUpdateOneWithoutCircuitNestedInput = {
    create?: XOR<outletCreateWithoutCircuitInput, outletUncheckedCreateWithoutCircuitInput>
    connectOrCreate?: outletCreateOrConnectWithoutCircuitInput
    upsert?: outletUpsertWithoutCircuitInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutCircuitInput, outletUncheckedUpdateWithoutCircuitInput>
  }

  export type fluxUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<fluxCreateWithoutCircuitInput>, Enumerable<fluxUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<fluxCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<fluxUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: fluxCreateManyCircuitInputEnvelope
    set?: Enumerable<fluxWhereUniqueInput>
    disconnect?: Enumerable<fluxWhereUniqueInput>
    delete?: Enumerable<fluxWhereUniqueInput>
    connect?: Enumerable<fluxWhereUniqueInput>
    update?: Enumerable<fluxUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<fluxUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<fluxScalarWhereInput>
  }

  export type reportUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutCircuitInput>, Enumerable<reportUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: reportCreateManyCircuitInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type townUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<townCreateWithoutCircuitInput>, Enumerable<townUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<townCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<townUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: townCreateManyCircuitInputEnvelope
    set?: Enumerable<townWhereUniqueInput>
    disconnect?: Enumerable<townWhereUniqueInput>
    delete?: Enumerable<townWhereUniqueInput>
    connect?: Enumerable<townWhereUniqueInput>
    update?: Enumerable<townUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<townUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<townScalarWhereInput>
  }

  export type fluxUncheckedUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<fluxCreateWithoutCircuitInput>, Enumerable<fluxUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<fluxCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<fluxUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: fluxCreateManyCircuitInputEnvelope
    set?: Enumerable<fluxWhereUniqueInput>
    disconnect?: Enumerable<fluxWhereUniqueInput>
    delete?: Enumerable<fluxWhereUniqueInput>
    connect?: Enumerable<fluxWhereUniqueInput>
    update?: Enumerable<fluxUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<fluxUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<fluxScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutCircuitInput>, Enumerable<reportUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: reportCreateManyCircuitInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type townUncheckedUpdateManyWithoutCircuitNestedInput = {
    create?: XOR<Enumerable<townCreateWithoutCircuitInput>, Enumerable<townUncheckedCreateWithoutCircuitInput>>
    connectOrCreate?: Enumerable<townCreateOrConnectWithoutCircuitInput>
    upsert?: Enumerable<townUpsertWithWhereUniqueWithoutCircuitInput>
    createMany?: townCreateManyCircuitInputEnvelope
    set?: Enumerable<townWhereUniqueInput>
    disconnect?: Enumerable<townWhereUniqueInput>
    delete?: Enumerable<townWhereUniqueInput>
    connect?: Enumerable<townWhereUniqueInput>
    update?: Enumerable<townUpdateWithWhereUniqueWithoutCircuitInput>
    updateMany?: Enumerable<townUpdateManyWithWhereWithoutCircuitInput>
    deleteMany?: Enumerable<townScalarWhereInput>
  }

  export type collecte_observationCreateNestedManyWithoutCollecteInput = {
    create?: XOR<Enumerable<collecte_observationCreateWithoutCollecteInput>, Enumerable<collecte_observationUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<collecte_observationCreateOrConnectWithoutCollecteInput>
    createMany?: collecte_observationCreateManyCollecteInputEnvelope
    connect?: Enumerable<collecte_observationWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutCollecteInput = {
    create?: XOR<Enumerable<reportCreateWithoutCollecteInput>, Enumerable<reportUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCollecteInput>
    createMany?: reportCreateManyCollecteInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type collecte_observationUncheckedCreateNestedManyWithoutCollecteInput = {
    create?: XOR<Enumerable<collecte_observationCreateWithoutCollecteInput>, Enumerable<collecte_observationUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<collecte_observationCreateOrConnectWithoutCollecteInput>
    createMany?: collecte_observationCreateManyCollecteInputEnvelope
    connect?: Enumerable<collecte_observationWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutCollecteInput = {
    create?: XOR<Enumerable<reportCreateWithoutCollecteInput>, Enumerable<reportUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCollecteInput>
    createMany?: reportCreateManyCollecteInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type collecte_observationUpdateManyWithoutCollecteNestedInput = {
    create?: XOR<Enumerable<collecte_observationCreateWithoutCollecteInput>, Enumerable<collecte_observationUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<collecte_observationCreateOrConnectWithoutCollecteInput>
    upsert?: Enumerable<collecte_observationUpsertWithWhereUniqueWithoutCollecteInput>
    createMany?: collecte_observationCreateManyCollecteInputEnvelope
    set?: Enumerable<collecte_observationWhereUniqueInput>
    disconnect?: Enumerable<collecte_observationWhereUniqueInput>
    delete?: Enumerable<collecte_observationWhereUniqueInput>
    connect?: Enumerable<collecte_observationWhereUniqueInput>
    update?: Enumerable<collecte_observationUpdateWithWhereUniqueWithoutCollecteInput>
    updateMany?: Enumerable<collecte_observationUpdateManyWithWhereWithoutCollecteInput>
    deleteMany?: Enumerable<collecte_observationScalarWhereInput>
  }

  export type reportUpdateManyWithoutCollecteNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutCollecteInput>, Enumerable<reportUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCollecteInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutCollecteInput>
    createMany?: reportCreateManyCollecteInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutCollecteInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutCollecteInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type collecte_observationUncheckedUpdateManyWithoutCollecteNestedInput = {
    create?: XOR<Enumerable<collecte_observationCreateWithoutCollecteInput>, Enumerable<collecte_observationUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<collecte_observationCreateOrConnectWithoutCollecteInput>
    upsert?: Enumerable<collecte_observationUpsertWithWhereUniqueWithoutCollecteInput>
    createMany?: collecte_observationCreateManyCollecteInputEnvelope
    set?: Enumerable<collecte_observationWhereUniqueInput>
    disconnect?: Enumerable<collecte_observationWhereUniqueInput>
    delete?: Enumerable<collecte_observationWhereUniqueInput>
    connect?: Enumerable<collecte_observationWhereUniqueInput>
    update?: Enumerable<collecte_observationUpdateWithWhereUniqueWithoutCollecteInput>
    updateMany?: Enumerable<collecte_observationUpdateManyWithWhereWithoutCollecteInput>
    deleteMany?: Enumerable<collecte_observationScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutCollecteNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutCollecteInput>, Enumerable<reportUncheckedCreateWithoutCollecteInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutCollecteInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutCollecteInput>
    createMany?: reportCreateManyCollecteInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutCollecteInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutCollecteInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type collecteCreateNestedOneWithoutCollecte_observationInput = {
    create?: XOR<collecteCreateWithoutCollecte_observationInput, collecteUncheckedCreateWithoutCollecte_observationInput>
    connectOrCreate?: collecteCreateOrConnectWithoutCollecte_observationInput
    connect?: collecteWhereUniqueInput
  }

  export type collecteUpdateOneWithoutCollecte_observationNestedInput = {
    create?: XOR<collecteCreateWithoutCollecte_observationInput, collecteUncheckedCreateWithoutCollecte_observationInput>
    connectOrCreate?: collecteCreateOrConnectWithoutCollecte_observationInput
    upsert?: collecteUpsertWithoutCollecte_observationInput
    disconnect?: boolean
    delete?: boolean
    connect?: collecteWhereUniqueInput
    update?: XOR<collecteUpdateWithoutCollecte_observationInput, collecteUncheckedUpdateWithoutCollecte_observationInput>
  }

  export type container_typeCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<container_typeCreateWithoutContainer_mouvementInput, container_typeUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: container_typeCreateOrConnectWithoutContainer_mouvementInput
    connect?: container_typeWhereUniqueInput
  }

  export type operation_typeCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<operation_typeCreateWithoutContainer_mouvementInput, operation_typeUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: operation_typeCreateOrConnectWithoutContainer_mouvementInput
    connect?: operation_typeWhereUniqueInput
  }

  export type worksiteCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<worksiteCreateWithoutContainer_mouvementInput, worksiteUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: worksiteCreateOrConnectWithoutContainer_mouvementInput
    connect?: worksiteWhereUniqueInput
  }

  export type driverCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<driverCreateWithoutContainer_mouvementInput, driverUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: driverCreateOrConnectWithoutContainer_mouvementInput
    connect?: driverWhereUniqueInput
  }

  export type truckCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<truckCreateWithoutContainer_mouvementInput, truckUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: truckCreateOrConnectWithoutContainer_mouvementInput
    connect?: truckWhereUniqueInput
  }

  export type fluxCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<fluxCreateWithoutContainer_mouvementInput, fluxUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: fluxCreateOrConnectWithoutContainer_mouvementInput
    connect?: fluxWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutContainer_mouvementInput = {
    create?: XOR<outletCreateWithoutContainer_mouvementInput, outletUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: outletCreateOrConnectWithoutContainer_mouvementInput
    connect?: outletWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type container_typeUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<container_typeCreateWithoutContainer_mouvementInput, container_typeUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: container_typeCreateOrConnectWithoutContainer_mouvementInput
    upsert?: container_typeUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: container_typeWhereUniqueInput
    update?: XOR<container_typeUpdateWithoutContainer_mouvementInput, container_typeUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type operation_typeUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<operation_typeCreateWithoutContainer_mouvementInput, operation_typeUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: operation_typeCreateOrConnectWithoutContainer_mouvementInput
    upsert?: operation_typeUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: operation_typeWhereUniqueInput
    update?: XOR<operation_typeUpdateWithoutContainer_mouvementInput, operation_typeUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type worksiteUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<worksiteCreateWithoutContainer_mouvementInput, worksiteUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: worksiteCreateOrConnectWithoutContainer_mouvementInput
    upsert?: worksiteUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: worksiteWhereUniqueInput
    update?: XOR<worksiteUpdateWithoutContainer_mouvementInput, worksiteUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type driverUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<driverCreateWithoutContainer_mouvementInput, driverUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: driverCreateOrConnectWithoutContainer_mouvementInput
    upsert?: driverUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: driverWhereUniqueInput
    update?: XOR<driverUpdateWithoutContainer_mouvementInput, driverUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type truckUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<truckCreateWithoutContainer_mouvementInput, truckUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: truckCreateOrConnectWithoutContainer_mouvementInput
    upsert?: truckUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: truckWhereUniqueInput
    update?: XOR<truckUpdateWithoutContainer_mouvementInput, truckUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type fluxUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<fluxCreateWithoutContainer_mouvementInput, fluxUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: fluxCreateOrConnectWithoutContainer_mouvementInput
    upsert?: fluxUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: fluxWhereUniqueInput
    update?: XOR<fluxUpdateWithoutContainer_mouvementInput, fluxUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type outletUpdateOneWithoutContainer_mouvementNestedInput = {
    create?: XOR<outletCreateWithoutContainer_mouvementInput, outletUncheckedCreateWithoutContainer_mouvementInput>
    connectOrCreate?: outletCreateOrConnectWithoutContainer_mouvementInput
    upsert?: outletUpsertWithoutContainer_mouvementInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutContainer_mouvementInput, outletUncheckedUpdateWithoutContainer_mouvementInput>
  }

  export type container_mouvementCreateNestedManyWithoutContainer_typeInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutContainer_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutContainer_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutContainer_typeInput>
    createMany?: container_mouvementCreateManyContainer_typeInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutContainer_typeInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutContainer_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutContainer_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutContainer_typeInput>
    createMany?: container_mouvementCreateManyContainer_typeInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type container_mouvementUpdateManyWithoutContainer_typeNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutContainer_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutContainer_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutContainer_typeInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutContainer_typeInput>
    createMany?: container_mouvementCreateManyContainer_typeInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutContainer_typeInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutContainer_typeInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutContainer_typeNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutContainer_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutContainer_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutContainer_typeInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutContainer_typeInput>
    createMany?: container_mouvementCreateManyContainer_typeInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutContainer_typeInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutContainer_typeInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type container_mouvementCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutDriverInput>, Enumerable<container_mouvementUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutDriverInput>
    createMany?: container_mouvementCreateManyDriverInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type replacement_teamCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutDriverInput>, Enumerable<replacement_teamUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutDriverInput>
    createMany?: replacement_teamCreateManyDriverInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type sinisterCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutDriverInput>, Enumerable<sinisterUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutDriverInput>
    createMany?: sinisterCreateManyDriverInputEnvelope
    connect?: Enumerable<sinisterWhereUniqueInput>
  }

  export type teamCreateNestedOneWithoutDriverInput = {
    create?: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
    connectOrCreate?: teamCreateOrConnectWithoutDriverInput
    connect?: teamWhereUniqueInput
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutDriverInput>, Enumerable<container_mouvementUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutDriverInput>
    createMany?: container_mouvementCreateManyDriverInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type replacement_teamUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutDriverInput>, Enumerable<replacement_teamUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutDriverInput>
    createMany?: replacement_teamCreateManyDriverInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type sinisterUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutDriverInput>, Enumerable<sinisterUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutDriverInput>
    createMany?: sinisterCreateManyDriverInputEnvelope
    connect?: Enumerable<sinisterWhereUniqueInput>
  }

  export type teamUncheckedCreateNestedOneWithoutDriverInput = {
    create?: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
    connectOrCreate?: teamCreateOrConnectWithoutDriverInput
    connect?: teamWhereUniqueInput
  }

  export type container_mouvementUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutDriverInput>, Enumerable<container_mouvementUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: container_mouvementCreateManyDriverInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type replacement_teamUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutDriverInput>, Enumerable<replacement_teamUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: replacement_teamCreateManyDriverInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type sinisterUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutDriverInput>, Enumerable<sinisterUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<sinisterUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: sinisterCreateManyDriverInputEnvelope
    set?: Enumerable<sinisterWhereUniqueInput>
    disconnect?: Enumerable<sinisterWhereUniqueInput>
    delete?: Enumerable<sinisterWhereUniqueInput>
    connect?: Enumerable<sinisterWhereUniqueInput>
    update?: Enumerable<sinisterUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<sinisterUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<sinisterScalarWhereInput>
  }

  export type teamUpdateOneWithoutDriverNestedInput = {
    create?: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
    connectOrCreate?: teamCreateOrConnectWithoutDriverInput
    upsert?: teamUpsertWithoutDriverInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutDriverInput, teamUncheckedUpdateWithoutDriverInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutDriverInput>, Enumerable<container_mouvementUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: container_mouvementCreateManyDriverInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type replacement_teamUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutDriverInput>, Enumerable<replacement_teamUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: replacement_teamCreateManyDriverInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type sinisterUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutDriverInput>, Enumerable<sinisterUncheckedCreateWithoutDriverInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutDriverInput>
    upsert?: Enumerable<sinisterUpsertWithWhereUniqueWithoutDriverInput>
    createMany?: sinisterCreateManyDriverInputEnvelope
    set?: Enumerable<sinisterWhereUniqueInput>
    disconnect?: Enumerable<sinisterWhereUniqueInput>
    delete?: Enumerable<sinisterWhereUniqueInput>
    connect?: Enumerable<sinisterWhereUniqueInput>
    update?: Enumerable<sinisterUpdateWithWhereUniqueWithoutDriverInput>
    updateMany?: Enumerable<sinisterUpdateManyWithWhereWithoutDriverInput>
    deleteMany?: Enumerable<sinisterScalarWhereInput>
  }

  export type teamUncheckedUpdateOneWithoutDriverNestedInput = {
    create?: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
    connectOrCreate?: teamCreateOrConnectWithoutDriverInput
    upsert?: teamUpsertWithoutDriverInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutDriverInput, teamUncheckedUpdateWithoutDriverInput>
  }

  export type container_mouvementCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutFluxInput>, Enumerable<container_mouvementUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutFluxInput>
    createMany?: container_mouvementCreateManyFluxInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type circuitCreateNestedOneWithoutFluxInput = {
    create?: XOR<circuitCreateWithoutFluxInput, circuitUncheckedCreateWithoutFluxInput>
    connectOrCreate?: circuitCreateOrConnectWithoutFluxInput
    connect?: circuitWhereUniqueInput
  }

  export type reportCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<reportCreateWithoutFluxInput>, Enumerable<reportUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutFluxInput>
    createMany?: reportCreateManyFluxInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type teamCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<teamCreateWithoutFluxInput>, Enumerable<teamUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutFluxInput>
    createMany?: teamCreateManyFluxInputEnvelope
    connect?: Enumerable<teamWhereUniqueInput>
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutFluxInput>, Enumerable<container_mouvementUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutFluxInput>
    createMany?: container_mouvementCreateManyFluxInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<reportCreateWithoutFluxInput>, Enumerable<reportUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutFluxInput>
    createMany?: reportCreateManyFluxInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type teamUncheckedCreateNestedManyWithoutFluxInput = {
    create?: XOR<Enumerable<teamCreateWithoutFluxInput>, Enumerable<teamUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutFluxInput>
    createMany?: teamCreateManyFluxInputEnvelope
    connect?: Enumerable<teamWhereUniqueInput>
  }

  export type container_mouvementUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutFluxInput>, Enumerable<container_mouvementUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: container_mouvementCreateManyFluxInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type circuitUpdateOneWithoutFluxNestedInput = {
    create?: XOR<circuitCreateWithoutFluxInput, circuitUncheckedCreateWithoutFluxInput>
    connectOrCreate?: circuitCreateOrConnectWithoutFluxInput
    upsert?: circuitUpsertWithoutFluxInput
    disconnect?: boolean
    delete?: boolean
    connect?: circuitWhereUniqueInput
    update?: XOR<circuitUpdateWithoutFluxInput, circuitUncheckedUpdateWithoutFluxInput>
  }

  export type reportUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutFluxInput>, Enumerable<reportUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: reportCreateManyFluxInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type teamUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<teamCreateWithoutFluxInput>, Enumerable<teamUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<teamUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: teamCreateManyFluxInputEnvelope
    set?: Enumerable<teamWhereUniqueInput>
    disconnect?: Enumerable<teamWhereUniqueInput>
    delete?: Enumerable<teamWhereUniqueInput>
    connect?: Enumerable<teamWhereUniqueInput>
    update?: Enumerable<teamUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<teamUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<teamScalarWhereInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutFluxInput>, Enumerable<container_mouvementUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: container_mouvementCreateManyFluxInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutFluxInput>, Enumerable<reportUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: reportCreateManyFluxInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type teamUncheckedUpdateManyWithoutFluxNestedInput = {
    create?: XOR<Enumerable<teamCreateWithoutFluxInput>, Enumerable<teamUncheckedCreateWithoutFluxInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutFluxInput>
    upsert?: Enumerable<teamUpsertWithWhereUniqueWithoutFluxInput>
    createMany?: teamCreateManyFluxInputEnvelope
    set?: Enumerable<teamWhereUniqueInput>
    disconnect?: Enumerable<teamWhereUniqueInput>
    delete?: Enumerable<teamWhereUniqueInput>
    connect?: Enumerable<teamWhereUniqueInput>
    update?: Enumerable<teamUpdateWithWhereUniqueWithoutFluxInput>
    updateMany?: Enumerable<teamUpdateManyWithWhereWithoutFluxInput>
    deleteMany?: Enumerable<teamScalarWhereInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type container_mouvementCreateNestedManyWithoutOperation_typeInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOperation_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutOperation_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOperation_typeInput>
    createMany?: container_mouvementCreateManyOperation_typeInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutOperation_typeInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOperation_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutOperation_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOperation_typeInput>
    createMany?: container_mouvementCreateManyOperation_typeInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type container_mouvementUpdateManyWithoutOperation_typeNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOperation_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutOperation_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOperation_typeInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutOperation_typeInput>
    createMany?: container_mouvementCreateManyOperation_typeInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutOperation_typeInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutOperation_typeInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutOperation_typeNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOperation_typeInput>, Enumerable<container_mouvementUncheckedCreateWithoutOperation_typeInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOperation_typeInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutOperation_typeInput>
    createMany?: container_mouvementCreateManyOperation_typeInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutOperation_typeInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutOperation_typeInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type circuitCreateNestedManyWithoutOutletInput = {
    create?: XOR<Enumerable<circuitCreateWithoutOutletInput>, Enumerable<circuitUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<circuitCreateOrConnectWithoutOutletInput>
    createMany?: circuitCreateManyOutletInputEnvelope
    connect?: Enumerable<circuitWhereUniqueInput>
  }

  export type container_mouvementCreateNestedManyWithoutOutletInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOutletInput>, Enumerable<container_mouvementUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOutletInput>
    createMany?: container_mouvementCreateManyOutletInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet4_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet2_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet3_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet3_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet2_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet4_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type circuitUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<Enumerable<circuitCreateWithoutOutletInput>, Enumerable<circuitUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<circuitCreateOrConnectWithoutOutletInput>
    createMany?: circuitCreateManyOutletInputEnvelope
    connect?: Enumerable<circuitWhereUniqueInput>
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutOutletInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOutletInput>, Enumerable<container_mouvementUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOutletInput>
    createMany?: container_mouvementCreateManyOutletInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet4_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet2_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet3_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet3_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet2_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet4_idTooutletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type circuitUpdateManyWithoutOutletNestedInput = {
    create?: XOR<Enumerable<circuitCreateWithoutOutletInput>, Enumerable<circuitUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<circuitCreateOrConnectWithoutOutletInput>
    upsert?: Enumerable<circuitUpsertWithWhereUniqueWithoutOutletInput>
    createMany?: circuitCreateManyOutletInputEnvelope
    set?: Enumerable<circuitWhereUniqueInput>
    disconnect?: Enumerable<circuitWhereUniqueInput>
    delete?: Enumerable<circuitWhereUniqueInput>
    connect?: Enumerable<circuitWhereUniqueInput>
    update?: Enumerable<circuitUpdateWithWhereUniqueWithoutOutletInput>
    updateMany?: Enumerable<circuitUpdateManyWithWhereWithoutOutletInput>
    deleteMany?: Enumerable<circuitScalarWhereInput>
  }

  export type container_mouvementUpdateManyWithoutOutletNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOutletInput>, Enumerable<container_mouvementUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOutletInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutOutletInput>
    createMany?: container_mouvementCreateManyOutletInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutOutletInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutOutletInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet4_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet4_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet4_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet2_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet2_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet2_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet3_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet3_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet3_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet3_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet3_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet3_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet2_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet2_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet2_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet4_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet4_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet4_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type circuitUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<Enumerable<circuitCreateWithoutOutletInput>, Enumerable<circuitUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<circuitCreateOrConnectWithoutOutletInput>
    upsert?: Enumerable<circuitUpsertWithWhereUniqueWithoutOutletInput>
    createMany?: circuitCreateManyOutletInputEnvelope
    set?: Enumerable<circuitWhereUniqueInput>
    disconnect?: Enumerable<circuitWhereUniqueInput>
    delete?: Enumerable<circuitWhereUniqueInput>
    connect?: Enumerable<circuitWhereUniqueInput>
    update?: Enumerable<circuitUpdateWithWhereUniqueWithoutOutletInput>
    updateMany?: Enumerable<circuitUpdateManyWithWhereWithoutOutletInput>
    deleteMany?: Enumerable<circuitScalarWhereInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutOutletNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutOutletInput>, Enumerable<container_mouvementUncheckedCreateWithoutOutletInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutOutletInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutOutletInput>
    createMany?: container_mouvementCreateManyOutletInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutOutletInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutOutletInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet4_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet4_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet4_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet2_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet2_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet2_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet3_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet3_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet3_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet3_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet3_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet3_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_visited_outlet_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_visited_outlet_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet2_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet2_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet2_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput>, Enumerable<reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutOutlet_report_default_outlet4_idTooutletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput>
    createMany?: reportCreateManyOutlet_report_default_outlet4_idTooutletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutOutlet_report_default_outlet4_idTooutletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    create?: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    connect?: ripperWhereUniqueInput
  }

  export type ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    create?: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    connect?: ripperWhereUniqueInput
  }

  export type driverCreateNestedOneWithoutReplacement_teamInput = {
    create?: XOR<driverCreateWithoutReplacement_teamInput, driverUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: driverCreateOrConnectWithoutReplacement_teamInput
    connect?: driverWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutReplacement_teamInput = {
    create?: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutReplacement_teamInput
    connect?: teamWhereUniqueInput
  }

  export type teamUncheckedCreateNestedOneWithoutReplacement_teamInput = {
    create?: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutReplacement_teamInput
    connect?: teamWhereUniqueInput
  }

  export type ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperNestedInput = {
    create?: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    upsert?: ripperUpsertWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: ripperWhereUniqueInput
    update?: XOR<ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperNestedInput = {
    create?: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    upsert?: ripperUpsertWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: ripperWhereUniqueInput
    update?: XOR<ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type driverUpdateOneWithoutReplacement_teamNestedInput = {
    create?: XOR<driverCreateWithoutReplacement_teamInput, driverUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: driverCreateOrConnectWithoutReplacement_teamInput
    upsert?: driverUpsertWithoutReplacement_teamInput
    disconnect?: boolean
    delete?: boolean
    connect?: driverWhereUniqueInput
    update?: XOR<driverUpdateWithoutReplacement_teamInput, driverUncheckedUpdateWithoutReplacement_teamInput>
  }

  export type teamUpdateOneWithoutReplacement_teamNestedInput = {
    create?: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutReplacement_teamInput
    upsert?: teamUpsertWithoutReplacement_teamInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutReplacement_teamInput, teamUncheckedUpdateWithoutReplacement_teamInput>
  }

  export type teamUncheckedUpdateOneWithoutReplacement_teamNestedInput = {
    create?: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
    connectOrCreate?: teamCreateOrConnectWithoutReplacement_teamInput
    upsert?: teamUpsertWithoutReplacement_teamInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutReplacement_teamInput, teamUncheckedUpdateWithoutReplacement_teamInput>
  }

  export type anomalyCreateNestedManyWithoutReportInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutReportInput>, Enumerable<anomalyUncheckedCreateWithoutReportInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutReportInput>
    createMany?: anomalyCreateManyReportInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet4_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet4_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet2_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet2_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type collecteCreateNestedOneWithoutReportInput = {
    create?: XOR<collecteCreateWithoutReportInput, collecteUncheckedCreateWithoutReportInput>
    connectOrCreate?: collecteCreateOrConnectWithoutReportInput
    connect?: collecteWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet3_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet3_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet3_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet3_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet2_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet2_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type truckCreateNestedOneWithoutReportInput = {
    create?: XOR<truckCreateWithoutReportInput, truckUncheckedCreateWithoutReportInput>
    connectOrCreate?: truckCreateOrConnectWithoutReportInput
    connect?: truckWhereUniqueInput
  }

  export type fluxCreateNestedOneWithoutReportInput = {
    create?: XOR<fluxCreateWithoutReportInput, fluxUncheckedCreateWithoutReportInput>
    connectOrCreate?: fluxCreateOrConnectWithoutReportInput
    connect?: fluxWhereUniqueInput
  }

  export type circuitCreateNestedOneWithoutReportInput = {
    create?: XOR<circuitCreateWithoutReportInput, circuitUncheckedCreateWithoutReportInput>
    connectOrCreate?: circuitCreateOrConnectWithoutReportInput
    connect?: circuitWhereUniqueInput
  }

  export type outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet4_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet4_idTooutletInput
    connect?: outletWhereUniqueInput
  }

  export type tabletCreateNestedOneWithoutReportInput = {
    create?: XOR<tabletCreateWithoutReportInput, tabletUncheckedCreateWithoutReportInput>
    connectOrCreate?: tabletCreateOrConnectWithoutReportInput
    connect?: tabletWhereUniqueInput
  }

  export type anomalyUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutReportInput>, Enumerable<anomalyUncheckedCreateWithoutReportInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutReportInput>
    createMany?: anomalyCreateManyReportInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type anomalyUpdateManyWithoutReportNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutReportInput>, Enumerable<anomalyUncheckedCreateWithoutReportInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutReportInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutReportInput>
    createMany?: anomalyCreateManyReportInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutReportInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutReportInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet4_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet4_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_visited_outlet4_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet4_idTooutletInput>
  }

  export type outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet2_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet2_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_visited_outlet2_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet2_idTooutletInput>
  }

  export type outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_default_outlet_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet_idTooutletInput>
  }

  export type collecteUpdateOneWithoutReportNestedInput = {
    create?: XOR<collecteCreateWithoutReportInput, collecteUncheckedCreateWithoutReportInput>
    connectOrCreate?: collecteCreateOrConnectWithoutReportInput
    upsert?: collecteUpsertWithoutReportInput
    disconnect?: boolean
    delete?: boolean
    connect?: collecteWhereUniqueInput
    update?: XOR<collecteUpdateWithoutReportInput, collecteUncheckedUpdateWithoutReportInput>
  }

  export type outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet3_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet3_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_default_outlet3_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet3_idTooutletInput>
  }

  export type outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet3_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet3_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_visited_outlet3_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet3_idTooutletInput>
  }

  export type outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_visited_outlet_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_visited_outlet_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet_idTooutletInput>
  }

  export type outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet2_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet2_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_default_outlet2_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet2_idTooutletInput>
  }

  export type truckUpdateOneWithoutReportNestedInput = {
    create?: XOR<truckCreateWithoutReportInput, truckUncheckedCreateWithoutReportInput>
    connectOrCreate?: truckCreateOrConnectWithoutReportInput
    upsert?: truckUpsertWithoutReportInput
    disconnect?: boolean
    delete?: boolean
    connect?: truckWhereUniqueInput
    update?: XOR<truckUpdateWithoutReportInput, truckUncheckedUpdateWithoutReportInput>
  }

  export type fluxUpdateOneWithoutReportNestedInput = {
    create?: XOR<fluxCreateWithoutReportInput, fluxUncheckedCreateWithoutReportInput>
    connectOrCreate?: fluxCreateOrConnectWithoutReportInput
    upsert?: fluxUpsertWithoutReportInput
    disconnect?: boolean
    delete?: boolean
    connect?: fluxWhereUniqueInput
    update?: XOR<fluxUpdateWithoutReportInput, fluxUncheckedUpdateWithoutReportInput>
  }

  export type circuitUpdateOneWithoutReportNestedInput = {
    create?: XOR<circuitCreateWithoutReportInput, circuitUncheckedCreateWithoutReportInput>
    connectOrCreate?: circuitCreateOrConnectWithoutReportInput
    upsert?: circuitUpsertWithoutReportInput
    disconnect?: boolean
    delete?: boolean
    connect?: circuitWhereUniqueInput
    update?: XOR<circuitUpdateWithoutReportInput, circuitUncheckedUpdateWithoutReportInput>
  }

  export type outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput = {
    create?: XOR<outletCreateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet4_idTooutletInput>
    connectOrCreate?: outletCreateOrConnectWithoutReport_report_default_outlet4_idTooutletInput
    upsert?: outletUpsertWithoutReport_report_default_outlet4_idTooutletInput
    disconnect?: boolean
    delete?: boolean
    connect?: outletWhereUniqueInput
    update?: XOR<outletUpdateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet4_idTooutletInput>
  }

  export type tabletUpdateOneWithoutReportNestedInput = {
    create?: XOR<tabletCreateWithoutReportInput, tabletUncheckedCreateWithoutReportInput>
    connectOrCreate?: tabletCreateOrConnectWithoutReportInput
    upsert?: tabletUpsertWithoutReportInput
    disconnect?: boolean
    delete?: boolean
    connect?: tabletWhereUniqueInput
    update?: XOR<tabletUpdateWithoutReportInput, tabletUncheckedUpdateWithoutReportInput>
  }

  export type anomalyUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutReportInput>, Enumerable<anomalyUncheckedCreateWithoutReportInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutReportInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutReportInput>
    createMany?: anomalyCreateManyReportInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutReportInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutReportInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type teamCreateNestedOneWithoutRipper_team_ripper1_idToripperInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper1_idToripperInput
    connect?: teamWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutRipper_team_ripper2_idToripperInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper2_idToripperInput
    connect?: teamWhereUniqueInput
  }

  export type replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInputEnvelope
    connect?: Enumerable<replacement_teamWhereUniqueInput>
  }

  export type teamUncheckedCreateNestedOneWithoutRipper_team_ripper1_idToripperInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper1_idToripperInput
    connect?: teamWhereUniqueInput
  }

  export type teamUncheckedCreateNestedOneWithoutRipper_team_ripper2_idToripperInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper2_idToripperInput
    connect?: teamWhereUniqueInput
  }

  export type replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type teamUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper1_idToripperInput
    upsert?: teamUpsertWithoutRipper_team_ripper1_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper1_idToripperInput>
  }

  export type teamUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper2_idToripperInput
    upsert?: teamUpsertWithoutRipper_team_ripper2_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper2_idToripperInput>
  }

  export type replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput = {
    create?: XOR<Enumerable<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>, Enumerable<replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>>
    connectOrCreate?: Enumerable<replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    upsert?: Enumerable<replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    createMany?: replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInputEnvelope
    set?: Enumerable<replacement_teamWhereUniqueInput>
    disconnect?: Enumerable<replacement_teamWhereUniqueInput>
    delete?: Enumerable<replacement_teamWhereUniqueInput>
    connect?: Enumerable<replacement_teamWhereUniqueInput>
    update?: Enumerable<replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    updateMany?: Enumerable<replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    deleteMany?: Enumerable<replacement_teamScalarWhereInput>
  }

  export type teamUncheckedUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper1_idToripperInput
    upsert?: teamUpsertWithoutRipper_team_ripper1_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper1_idToripperInput>
  }

  export type teamUncheckedUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput = {
    create?: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
    connectOrCreate?: teamCreateOrConnectWithoutRipper_team_ripper2_idToripperInput
    upsert?: teamUpsertWithoutRipper_team_ripper2_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper2_idToripperInput>
  }

  export type driverCreateNestedOneWithoutSinisterInput = {
    create?: XOR<driverCreateWithoutSinisterInput, driverUncheckedCreateWithoutSinisterInput>
    connectOrCreate?: driverCreateOrConnectWithoutSinisterInput
    connect?: driverWhereUniqueInput
  }

  export type truckCreateNestedOneWithoutSinisterInput = {
    create?: XOR<truckCreateWithoutSinisterInput, truckUncheckedCreateWithoutSinisterInput>
    connectOrCreate?: truckCreateOrConnectWithoutSinisterInput
    connect?: truckWhereUniqueInput
  }

  export type driverUpdateOneWithoutSinisterNestedInput = {
    create?: XOR<driverCreateWithoutSinisterInput, driverUncheckedCreateWithoutSinisterInput>
    connectOrCreate?: driverCreateOrConnectWithoutSinisterInput
    upsert?: driverUpsertWithoutSinisterInput
    disconnect?: boolean
    delete?: boolean
    connect?: driverWhereUniqueInput
    update?: XOR<driverUpdateWithoutSinisterInput, driverUncheckedUpdateWithoutSinisterInput>
  }

  export type truckUpdateOneWithoutSinisterNestedInput = {
    create?: XOR<truckCreateWithoutSinisterInput, truckUncheckedCreateWithoutSinisterInput>
    connectOrCreate?: truckCreateOrConnectWithoutSinisterInput
    upsert?: truckUpsertWithoutSinisterInput
    disconnect?: boolean
    delete?: boolean
    connect?: truckWhereUniqueInput
    update?: XOR<truckUpdateWithoutSinisterInput, truckUncheckedUpdateWithoutSinisterInput>
  }

  export type reportCreateNestedManyWithoutTabletInput = {
    create?: XOR<Enumerable<reportCreateWithoutTabletInput>, Enumerable<reportUncheckedCreateWithoutTabletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTabletInput>
    createMany?: reportCreateManyTabletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutTabletInput = {
    create?: XOR<Enumerable<reportCreateWithoutTabletInput>, Enumerable<reportUncheckedCreateWithoutTabletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTabletInput>
    createMany?: reportCreateManyTabletInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type reportUpdateManyWithoutTabletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTabletInput>, Enumerable<reportUncheckedCreateWithoutTabletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTabletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTabletInput>
    createMany?: reportCreateManyTabletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTabletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTabletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutTabletNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTabletInput>, Enumerable<reportUncheckedCreateWithoutTabletInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTabletInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTabletInput>
    createMany?: reportCreateManyTabletInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTabletInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTabletInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput = {
    create?: XOR<ripperCreateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper1_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutTeam_team_ripper1_idToripperInput
    connect?: ripperWhereUniqueInput
  }

  export type ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput = {
    create?: XOR<ripperCreateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper2_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutTeam_team_ripper2_idToripperInput
    connect?: ripperWhereUniqueInput
  }

  export type driverCreateNestedOneWithoutTeamInput = {
    create?: XOR<driverCreateWithoutTeamInput, driverUncheckedCreateWithoutTeamInput>
    connectOrCreate?: driverCreateOrConnectWithoutTeamInput
    connect?: driverWhereUniqueInput
  }

  export type truckCreateNestedOneWithoutTeamInput = {
    create?: XOR<truckCreateWithoutTeamInput, truckUncheckedCreateWithoutTeamInput>
    connectOrCreate?: truckCreateOrConnectWithoutTeamInput
    connect?: truckWhereUniqueInput
  }

  export type fluxCreateNestedOneWithoutTeamInput = {
    create?: XOR<fluxCreateWithoutTeamInput, fluxUncheckedCreateWithoutTeamInput>
    connectOrCreate?: fluxCreateOrConnectWithoutTeamInput
    connect?: fluxWhereUniqueInput
  }

  export type replacement_teamCreateNestedOneWithoutTeamInput = {
    create?: XOR<replacement_teamCreateWithoutTeamInput, replacement_teamUncheckedCreateWithoutTeamInput>
    connectOrCreate?: replacement_teamCreateOrConnectWithoutTeamInput
    connect?: replacement_teamWhereUniqueInput
  }

  export type ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput = {
    create?: XOR<ripperCreateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper1_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutTeam_team_ripper1_idToripperInput
    upsert?: ripperUpsertWithoutTeam_team_ripper1_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: ripperWhereUniqueInput
    update?: XOR<ripperUpdateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedUpdateWithoutTeam_team_ripper1_idToripperInput>
  }

  export type ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput = {
    create?: XOR<ripperCreateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper2_idToripperInput>
    connectOrCreate?: ripperCreateOrConnectWithoutTeam_team_ripper2_idToripperInput
    upsert?: ripperUpsertWithoutTeam_team_ripper2_idToripperInput
    disconnect?: boolean
    delete?: boolean
    connect?: ripperWhereUniqueInput
    update?: XOR<ripperUpdateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedUpdateWithoutTeam_team_ripper2_idToripperInput>
  }

  export type driverUpdateOneWithoutTeamNestedInput = {
    create?: XOR<driverCreateWithoutTeamInput, driverUncheckedCreateWithoutTeamInput>
    connectOrCreate?: driverCreateOrConnectWithoutTeamInput
    upsert?: driverUpsertWithoutTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: driverWhereUniqueInput
    update?: XOR<driverUpdateWithoutTeamInput, driverUncheckedUpdateWithoutTeamInput>
  }

  export type truckUpdateOneWithoutTeamNestedInput = {
    create?: XOR<truckCreateWithoutTeamInput, truckUncheckedCreateWithoutTeamInput>
    connectOrCreate?: truckCreateOrConnectWithoutTeamInput
    upsert?: truckUpsertWithoutTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: truckWhereUniqueInput
    update?: XOR<truckUpdateWithoutTeamInput, truckUncheckedUpdateWithoutTeamInput>
  }

  export type fluxUpdateOneWithoutTeamNestedInput = {
    create?: XOR<fluxCreateWithoutTeamInput, fluxUncheckedCreateWithoutTeamInput>
    connectOrCreate?: fluxCreateOrConnectWithoutTeamInput
    upsert?: fluxUpsertWithoutTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: fluxWhereUniqueInput
    update?: XOR<fluxUpdateWithoutTeamInput, fluxUncheckedUpdateWithoutTeamInput>
  }

  export type replacement_teamUpdateOneWithoutTeamNestedInput = {
    create?: XOR<replacement_teamCreateWithoutTeamInput, replacement_teamUncheckedCreateWithoutTeamInput>
    connectOrCreate?: replacement_teamCreateOrConnectWithoutTeamInput
    upsert?: replacement_teamUpsertWithoutTeamInput
    disconnect?: boolean
    delete?: boolean
    connect?: replacement_teamWhereUniqueInput
    update?: XOR<replacement_teamUpdateWithoutTeamInput, replacement_teamUncheckedUpdateWithoutTeamInput>
  }

  export type circuitCreateNestedOneWithoutTownInput = {
    create?: XOR<circuitCreateWithoutTownInput, circuitUncheckedCreateWithoutTownInput>
    connectOrCreate?: circuitCreateOrConnectWithoutTownInput
    connect?: circuitWhereUniqueInput
  }

  export type wayCreateNestedManyWithoutTownInput = {
    create?: XOR<Enumerable<wayCreateWithoutTownInput>, Enumerable<wayUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<wayCreateOrConnectWithoutTownInput>
    createMany?: wayCreateManyTownInputEnvelope
    connect?: Enumerable<wayWhereUniqueInput>
  }

  export type worksiteCreateNestedManyWithoutTownInput = {
    create?: XOR<Enumerable<worksiteCreateWithoutTownInput>, Enumerable<worksiteUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<worksiteCreateOrConnectWithoutTownInput>
    createMany?: worksiteCreateManyTownInputEnvelope
    connect?: Enumerable<worksiteWhereUniqueInput>
  }

  export type wayUncheckedCreateNestedManyWithoutTownInput = {
    create?: XOR<Enumerable<wayCreateWithoutTownInput>, Enumerable<wayUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<wayCreateOrConnectWithoutTownInput>
    createMany?: wayCreateManyTownInputEnvelope
    connect?: Enumerable<wayWhereUniqueInput>
  }

  export type worksiteUncheckedCreateNestedManyWithoutTownInput = {
    create?: XOR<Enumerable<worksiteCreateWithoutTownInput>, Enumerable<worksiteUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<worksiteCreateOrConnectWithoutTownInput>
    createMany?: worksiteCreateManyTownInputEnvelope
    connect?: Enumerable<worksiteWhereUniqueInput>
  }

  export type circuitUpdateOneWithoutTownNestedInput = {
    create?: XOR<circuitCreateWithoutTownInput, circuitUncheckedCreateWithoutTownInput>
    connectOrCreate?: circuitCreateOrConnectWithoutTownInput
    upsert?: circuitUpsertWithoutTownInput
    disconnect?: boolean
    delete?: boolean
    connect?: circuitWhereUniqueInput
    update?: XOR<circuitUpdateWithoutTownInput, circuitUncheckedUpdateWithoutTownInput>
  }

  export type wayUpdateManyWithoutTownNestedInput = {
    create?: XOR<Enumerable<wayCreateWithoutTownInput>, Enumerable<wayUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<wayCreateOrConnectWithoutTownInput>
    upsert?: Enumerable<wayUpsertWithWhereUniqueWithoutTownInput>
    createMany?: wayCreateManyTownInputEnvelope
    set?: Enumerable<wayWhereUniqueInput>
    disconnect?: Enumerable<wayWhereUniqueInput>
    delete?: Enumerable<wayWhereUniqueInput>
    connect?: Enumerable<wayWhereUniqueInput>
    update?: Enumerable<wayUpdateWithWhereUniqueWithoutTownInput>
    updateMany?: Enumerable<wayUpdateManyWithWhereWithoutTownInput>
    deleteMany?: Enumerable<wayScalarWhereInput>
  }

  export type worksiteUpdateManyWithoutTownNestedInput = {
    create?: XOR<Enumerable<worksiteCreateWithoutTownInput>, Enumerable<worksiteUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<worksiteCreateOrConnectWithoutTownInput>
    upsert?: Enumerable<worksiteUpsertWithWhereUniqueWithoutTownInput>
    createMany?: worksiteCreateManyTownInputEnvelope
    set?: Enumerable<worksiteWhereUniqueInput>
    disconnect?: Enumerable<worksiteWhereUniqueInput>
    delete?: Enumerable<worksiteWhereUniqueInput>
    connect?: Enumerable<worksiteWhereUniqueInput>
    update?: Enumerable<worksiteUpdateWithWhereUniqueWithoutTownInput>
    updateMany?: Enumerable<worksiteUpdateManyWithWhereWithoutTownInput>
    deleteMany?: Enumerable<worksiteScalarWhereInput>
  }

  export type wayUncheckedUpdateManyWithoutTownNestedInput = {
    create?: XOR<Enumerable<wayCreateWithoutTownInput>, Enumerable<wayUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<wayCreateOrConnectWithoutTownInput>
    upsert?: Enumerable<wayUpsertWithWhereUniqueWithoutTownInput>
    createMany?: wayCreateManyTownInputEnvelope
    set?: Enumerable<wayWhereUniqueInput>
    disconnect?: Enumerable<wayWhereUniqueInput>
    delete?: Enumerable<wayWhereUniqueInput>
    connect?: Enumerable<wayWhereUniqueInput>
    update?: Enumerable<wayUpdateWithWhereUniqueWithoutTownInput>
    updateMany?: Enumerable<wayUpdateManyWithWhereWithoutTownInput>
    deleteMany?: Enumerable<wayScalarWhereInput>
  }

  export type worksiteUncheckedUpdateManyWithoutTownNestedInput = {
    create?: XOR<Enumerable<worksiteCreateWithoutTownInput>, Enumerable<worksiteUncheckedCreateWithoutTownInput>>
    connectOrCreate?: Enumerable<worksiteCreateOrConnectWithoutTownInput>
    upsert?: Enumerable<worksiteUpsertWithWhereUniqueWithoutTownInput>
    createMany?: worksiteCreateManyTownInputEnvelope
    set?: Enumerable<worksiteWhereUniqueInput>
    disconnect?: Enumerable<worksiteWhereUniqueInput>
    delete?: Enumerable<worksiteWhereUniqueInput>
    connect?: Enumerable<worksiteWhereUniqueInput>
    update?: Enumerable<worksiteUpdateWithWhereUniqueWithoutTownInput>
    updateMany?: Enumerable<worksiteUpdateManyWithWhereWithoutTownInput>
    deleteMany?: Enumerable<worksiteScalarWhereInput>
  }

  export type container_mouvementCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutTruckInput>, Enumerable<container_mouvementUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutTruckInput>
    createMany?: container_mouvementCreateManyTruckInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<reportCreateWithoutTruckInput>, Enumerable<reportUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTruckInput>
    createMany?: reportCreateManyTruckInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type sinisterCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutTruckInput>, Enumerable<sinisterUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutTruckInput>
    createMany?: sinisterCreateManyTruckInputEnvelope
    connect?: Enumerable<sinisterWhereUniqueInput>
  }

  export type teamCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<teamCreateWithoutTruckInput>, Enumerable<teamUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutTruckInput>
    createMany?: teamCreateManyTruckInputEnvelope
    connect?: Enumerable<teamWhereUniqueInput>
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutTruckInput>, Enumerable<container_mouvementUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutTruckInput>
    createMany?: container_mouvementCreateManyTruckInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<reportCreateWithoutTruckInput>, Enumerable<reportUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTruckInput>
    createMany?: reportCreateManyTruckInputEnvelope
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type sinisterUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutTruckInput>, Enumerable<sinisterUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutTruckInput>
    createMany?: sinisterCreateManyTruckInputEnvelope
    connect?: Enumerable<sinisterWhereUniqueInput>
  }

  export type teamUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<Enumerable<teamCreateWithoutTruckInput>, Enumerable<teamUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutTruckInput>
    createMany?: teamCreateManyTruckInputEnvelope
    connect?: Enumerable<teamWhereUniqueInput>
  }

  export type container_mouvementUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutTruckInput>, Enumerable<container_mouvementUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: container_mouvementCreateManyTruckInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type reportUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTruckInput>, Enumerable<reportUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: reportCreateManyTruckInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type sinisterUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutTruckInput>, Enumerable<sinisterUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<sinisterUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: sinisterCreateManyTruckInputEnvelope
    set?: Enumerable<sinisterWhereUniqueInput>
    disconnect?: Enumerable<sinisterWhereUniqueInput>
    delete?: Enumerable<sinisterWhereUniqueInput>
    connect?: Enumerable<sinisterWhereUniqueInput>
    update?: Enumerable<sinisterUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<sinisterUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<sinisterScalarWhereInput>
  }

  export type teamUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<teamCreateWithoutTruckInput>, Enumerable<teamUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<teamUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: teamCreateManyTruckInputEnvelope
    set?: Enumerable<teamWhereUniqueInput>
    disconnect?: Enumerable<teamWhereUniqueInput>
    delete?: Enumerable<teamWhereUniqueInput>
    connect?: Enumerable<teamWhereUniqueInput>
    update?: Enumerable<teamUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<teamUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<teamScalarWhereInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutTruckInput>, Enumerable<container_mouvementUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: container_mouvementCreateManyTruckInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTruckInput>, Enumerable<reportUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: reportCreateManyTruckInputEnvelope
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type sinisterUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<sinisterCreateWithoutTruckInput>, Enumerable<sinisterUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<sinisterCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<sinisterUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: sinisterCreateManyTruckInputEnvelope
    set?: Enumerable<sinisterWhereUniqueInput>
    disconnect?: Enumerable<sinisterWhereUniqueInput>
    delete?: Enumerable<sinisterWhereUniqueInput>
    connect?: Enumerable<sinisterWhereUniqueInput>
    update?: Enumerable<sinisterUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<sinisterUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<sinisterScalarWhereInput>
  }

  export type teamUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<Enumerable<teamCreateWithoutTruckInput>, Enumerable<teamUncheckedCreateWithoutTruckInput>>
    connectOrCreate?: Enumerable<teamCreateOrConnectWithoutTruckInput>
    upsert?: Enumerable<teamUpsertWithWhereUniqueWithoutTruckInput>
    createMany?: teamCreateManyTruckInputEnvelope
    set?: Enumerable<teamWhereUniqueInput>
    disconnect?: Enumerable<teamWhereUniqueInput>
    delete?: Enumerable<teamWhereUniqueInput>
    connect?: Enumerable<teamWhereUniqueInput>
    update?: Enumerable<teamUpdateWithWhereUniqueWithoutTruckInput>
    updateMany?: Enumerable<teamUpdateManyWithWhereWithoutTruckInput>
    deleteMany?: Enumerable<teamScalarWhereInput>
  }

  export type anomalyCreateNestedManyWithoutType_anomalyInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutType_anomalyInput>, Enumerable<anomalyUncheckedCreateWithoutType_anomalyInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutType_anomalyInput>
    createMany?: anomalyCreateManyType_anomalyInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type anomalyUncheckedCreateNestedManyWithoutType_anomalyInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutType_anomalyInput>, Enumerable<anomalyUncheckedCreateWithoutType_anomalyInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutType_anomalyInput>
    createMany?: anomalyCreateManyType_anomalyInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type anomalyUpdateManyWithoutType_anomalyNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutType_anomalyInput>, Enumerable<anomalyUncheckedCreateWithoutType_anomalyInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutType_anomalyInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutType_anomalyInput>
    createMany?: anomalyCreateManyType_anomalyInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutType_anomalyInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutType_anomalyInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type anomalyUncheckedUpdateManyWithoutType_anomalyNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutType_anomalyInput>, Enumerable<anomalyUncheckedCreateWithoutType_anomalyInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutType_anomalyInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutType_anomalyInput>
    createMany?: anomalyCreateManyType_anomalyInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutType_anomalyInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutType_anomalyInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type anomalyCreateNestedManyWithoutWayInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutWayInput>, Enumerable<anomalyUncheckedCreateWithoutWayInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutWayInput>
    createMany?: anomalyCreateManyWayInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type townCreateNestedOneWithoutWayInput = {
    create?: XOR<townCreateWithoutWayInput, townUncheckedCreateWithoutWayInput>
    connectOrCreate?: townCreateOrConnectWithoutWayInput
    connect?: townWhereUniqueInput
  }

  export type anomalyUncheckedCreateNestedManyWithoutWayInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutWayInput>, Enumerable<anomalyUncheckedCreateWithoutWayInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutWayInput>
    createMany?: anomalyCreateManyWayInputEnvelope
    connect?: Enumerable<anomalyWhereUniqueInput>
  }

  export type anomalyUpdateManyWithoutWayNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutWayInput>, Enumerable<anomalyUncheckedCreateWithoutWayInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutWayInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutWayInput>
    createMany?: anomalyCreateManyWayInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutWayInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutWayInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type townUpdateOneWithoutWayNestedInput = {
    create?: XOR<townCreateWithoutWayInput, townUncheckedCreateWithoutWayInput>
    connectOrCreate?: townCreateOrConnectWithoutWayInput
    upsert?: townUpsertWithoutWayInput
    disconnect?: boolean
    delete?: boolean
    connect?: townWhereUniqueInput
    update?: XOR<townUpdateWithoutWayInput, townUncheckedUpdateWithoutWayInput>
  }

  export type anomalyUncheckedUpdateManyWithoutWayNestedInput = {
    create?: XOR<Enumerable<anomalyCreateWithoutWayInput>, Enumerable<anomalyUncheckedCreateWithoutWayInput>>
    connectOrCreate?: Enumerable<anomalyCreateOrConnectWithoutWayInput>
    upsert?: Enumerable<anomalyUpsertWithWhereUniqueWithoutWayInput>
    createMany?: anomalyCreateManyWayInputEnvelope
    set?: Enumerable<anomalyWhereUniqueInput>
    disconnect?: Enumerable<anomalyWhereUniqueInput>
    delete?: Enumerable<anomalyWhereUniqueInput>
    connect?: Enumerable<anomalyWhereUniqueInput>
    update?: Enumerable<anomalyUpdateWithWhereUniqueWithoutWayInput>
    updateMany?: Enumerable<anomalyUpdateManyWithWhereWithoutWayInput>
    deleteMany?: Enumerable<anomalyScalarWhereInput>
  }

  export type container_mouvementCreateNestedManyWithoutWorksiteInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutWorksiteInput>, Enumerable<container_mouvementUncheckedCreateWithoutWorksiteInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutWorksiteInput>
    createMany?: container_mouvementCreateManyWorksiteInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type townCreateNestedOneWithoutWorksiteInput = {
    create?: XOR<townCreateWithoutWorksiteInput, townUncheckedCreateWithoutWorksiteInput>
    connectOrCreate?: townCreateOrConnectWithoutWorksiteInput
    connect?: townWhereUniqueInput
  }

  export type container_mouvementUncheckedCreateNestedManyWithoutWorksiteInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutWorksiteInput>, Enumerable<container_mouvementUncheckedCreateWithoutWorksiteInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutWorksiteInput>
    createMany?: container_mouvementCreateManyWorksiteInputEnvelope
    connect?: Enumerable<container_mouvementWhereUniqueInput>
  }

  export type container_mouvementUpdateManyWithoutWorksiteNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutWorksiteInput>, Enumerable<container_mouvementUncheckedCreateWithoutWorksiteInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutWorksiteInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutWorksiteInput>
    createMany?: container_mouvementCreateManyWorksiteInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutWorksiteInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutWorksiteInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type townUpdateOneWithoutWorksiteNestedInput = {
    create?: XOR<townCreateWithoutWorksiteInput, townUncheckedCreateWithoutWorksiteInput>
    connectOrCreate?: townCreateOrConnectWithoutWorksiteInput
    upsert?: townUpsertWithoutWorksiteInput
    disconnect?: boolean
    delete?: boolean
    connect?: townWhereUniqueInput
    update?: XOR<townUpdateWithoutWorksiteInput, townUncheckedUpdateWithoutWorksiteInput>
  }

  export type container_mouvementUncheckedUpdateManyWithoutWorksiteNestedInput = {
    create?: XOR<Enumerable<container_mouvementCreateWithoutWorksiteInput>, Enumerable<container_mouvementUncheckedCreateWithoutWorksiteInput>>
    connectOrCreate?: Enumerable<container_mouvementCreateOrConnectWithoutWorksiteInput>
    upsert?: Enumerable<container_mouvementUpsertWithWhereUniqueWithoutWorksiteInput>
    createMany?: container_mouvementCreateManyWorksiteInputEnvelope
    set?: Enumerable<container_mouvementWhereUniqueInput>
    disconnect?: Enumerable<container_mouvementWhereUniqueInput>
    delete?: Enumerable<container_mouvementWhereUniqueInput>
    connect?: Enumerable<container_mouvementWhereUniqueInput>
    update?: Enumerable<container_mouvementUpdateWithWhereUniqueWithoutWorksiteInput>
    updateMany?: Enumerable<container_mouvementUpdateManyWithWhereWithoutWorksiteInput>
    deleteMany?: Enumerable<container_mouvementScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type reportCreateWithoutAnomalyInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutAnomalyInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateOrConnectWithoutAnomalyInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutAnomalyInput, reportUncheckedCreateWithoutAnomalyInput>
  }

  export type wayCreateWithoutAnomalyInput = {
    name: string
    type?: string | null
    town?: townCreateNestedOneWithoutWayInput
  }

  export type wayUncheckedCreateWithoutAnomalyInput = {
    id?: number
    town_id?: number | null
    name: string
    type?: string | null
  }

  export type wayCreateOrConnectWithoutAnomalyInput = {
    where: wayWhereUniqueInput
    create: XOR<wayCreateWithoutAnomalyInput, wayUncheckedCreateWithoutAnomalyInput>
  }

  export type type_anomalyCreateWithoutAnomalyInput = {
    name: string
  }

  export type type_anomalyUncheckedCreateWithoutAnomalyInput = {
    id?: number
    name: string
  }

  export type type_anomalyCreateOrConnectWithoutAnomalyInput = {
    where: type_anomalyWhereUniqueInput
    create: XOR<type_anomalyCreateWithoutAnomalyInput, type_anomalyUncheckedCreateWithoutAnomalyInput>
  }

  export type reportUpsertWithoutAnomalyInput = {
    update: XOR<reportUpdateWithoutAnomalyInput, reportUncheckedUpdateWithoutAnomalyInput>
    create: XOR<reportCreateWithoutAnomalyInput, reportUncheckedCreateWithoutAnomalyInput>
  }

  export type reportUpdateWithoutAnomalyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutAnomalyInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type wayUpsertWithoutAnomalyInput = {
    update: XOR<wayUpdateWithoutAnomalyInput, wayUncheckedUpdateWithoutAnomalyInput>
    create: XOR<wayCreateWithoutAnomalyInput, wayUncheckedCreateWithoutAnomalyInput>
  }

  export type wayUpdateWithoutAnomalyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    town?: townUpdateOneWithoutWayNestedInput
  }

  export type wayUncheckedUpdateWithoutAnomalyInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_anomalyUpsertWithoutAnomalyInput = {
    update: XOR<type_anomalyUpdateWithoutAnomalyInput, type_anomalyUncheckedUpdateWithoutAnomalyInput>
    create: XOR<type_anomalyCreateWithoutAnomalyInput, type_anomalyUncheckedCreateWithoutAnomalyInput>
  }

  export type type_anomalyUpdateWithoutAnomalyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_anomalyUncheckedUpdateWithoutAnomalyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type outletCreateWithoutCircuitInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutCircuitInput = {
    id?: number
    name: string
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutCircuitInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutCircuitInput, outletUncheckedCreateWithoutCircuitInput>
  }

  export type fluxCreateWithoutCircuitInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutFluxInput
    report?: reportCreateNestedManyWithoutFluxInput
    team?: teamCreateNestedManyWithoutFluxInput
  }

  export type fluxUncheckedCreateWithoutCircuitInput = {
    id?: number
    name: string
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutFluxInput
    report?: reportUncheckedCreateNestedManyWithoutFluxInput
    team?: teamUncheckedCreateNestedManyWithoutFluxInput
  }

  export type fluxCreateOrConnectWithoutCircuitInput = {
    where: fluxWhereUniqueInput
    create: XOR<fluxCreateWithoutCircuitInput, fluxUncheckedCreateWithoutCircuitInput>
  }

  export type fluxCreateManyCircuitInputEnvelope = {
    data: Enumerable<fluxCreateManyCircuitInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutCircuitInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutCircuitInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutCircuitInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutCircuitInput, reportUncheckedCreateWithoutCircuitInput>
  }

  export type reportCreateManyCircuitInputEnvelope = {
    data: Enumerable<reportCreateManyCircuitInput>
    skipDuplicates?: boolean
  }

  export type townCreateWithoutCircuitInput = {
    name: string
    postal_code: number
    way?: wayCreateNestedManyWithoutTownInput
    worksite?: worksiteCreateNestedManyWithoutTownInput
  }

  export type townUncheckedCreateWithoutCircuitInput = {
    id?: number
    name: string
    postal_code: number
    way?: wayUncheckedCreateNestedManyWithoutTownInput
    worksite?: worksiteUncheckedCreateNestedManyWithoutTownInput
  }

  export type townCreateOrConnectWithoutCircuitInput = {
    where: townWhereUniqueInput
    create: XOR<townCreateWithoutCircuitInput, townUncheckedCreateWithoutCircuitInput>
  }

  export type townCreateManyCircuitInputEnvelope = {
    data: Enumerable<townCreateManyCircuitInput>
    skipDuplicates?: boolean
  }

  export type outletUpsertWithoutCircuitInput = {
    update: XOR<outletUpdateWithoutCircuitInput, outletUncheckedUpdateWithoutCircuitInput>
    create: XOR<outletCreateWithoutCircuitInput, outletUncheckedCreateWithoutCircuitInput>
  }

  export type outletUpdateWithoutCircuitInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutCircuitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type fluxUpsertWithWhereUniqueWithoutCircuitInput = {
    where: fluxWhereUniqueInput
    update: XOR<fluxUpdateWithoutCircuitInput, fluxUncheckedUpdateWithoutCircuitInput>
    create: XOR<fluxCreateWithoutCircuitInput, fluxUncheckedCreateWithoutCircuitInput>
  }

  export type fluxUpdateWithWhereUniqueWithoutCircuitInput = {
    where: fluxWhereUniqueInput
    data: XOR<fluxUpdateWithoutCircuitInput, fluxUncheckedUpdateWithoutCircuitInput>
  }

  export type fluxUpdateManyWithWhereWithoutCircuitInput = {
    where: fluxScalarWhereInput
    data: XOR<fluxUpdateManyMutationInput, fluxUncheckedUpdateManyWithoutFluxInput>
  }

  export type fluxScalarWhereInput = {
    AND?: Enumerable<fluxScalarWhereInput>
    OR?: Enumerable<fluxScalarWhereInput>
    NOT?: Enumerable<fluxScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    circuit_id?: IntNullableFilter | number | null
  }

  export type reportUpsertWithWhereUniqueWithoutCircuitInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutCircuitInput, reportUncheckedUpdateWithoutCircuitInput>
    create: XOR<reportCreateWithoutCircuitInput, reportUncheckedCreateWithoutCircuitInput>
  }

  export type reportUpdateWithWhereUniqueWithoutCircuitInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutCircuitInput, reportUncheckedUpdateWithoutCircuitInput>
  }

  export type reportUpdateManyWithWhereWithoutCircuitInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportInput>
  }

  export type reportScalarWhereInput = {
    AND?: Enumerable<reportScalarWhereInput>
    OR?: Enumerable<reportScalarWhereInput>
    NOT?: Enumerable<reportScalarWhereInput>
    id?: IntFilter | number
    default_outlet_id?: IntNullableFilter | number | null
    visited_outlet_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    manual_circuit?: StringNullableFilter | string | null
    total_bac_collected?: IntFilter | number
    total_bac_rejected?: IntFilter | number
    tonnage?: FloatNullableFilter | number | null
    tonnage2?: FloatNullableFilter | number | null
    default_outlet2_id?: IntNullableFilter | number | null
    visited_outlet2_id?: IntNullableFilter | number | null
    default_outlet3_id?: IntNullableFilter | number | null
    visited_outlet3_id?: IntNullableFilter | number | null
    default_outlet4_id?: IntNullableFilter | number | null
    visited_outlet4_id?: IntNullableFilter | number | null
    tonnage3?: FloatNullableFilter | number | null
    tonnage4?: FloatNullableFilter | number | null
    circuit_id?: IntNullableFilter | number | null
    collecte_id?: IntNullableFilter | number | null
    observation?: StringNullableFilter | string | null
    geoloc_id?: IntNullableFilter | number | null
  }

  export type townUpsertWithWhereUniqueWithoutCircuitInput = {
    where: townWhereUniqueInput
    update: XOR<townUpdateWithoutCircuitInput, townUncheckedUpdateWithoutCircuitInput>
    create: XOR<townCreateWithoutCircuitInput, townUncheckedCreateWithoutCircuitInput>
  }

  export type townUpdateWithWhereUniqueWithoutCircuitInput = {
    where: townWhereUniqueInput
    data: XOR<townUpdateWithoutCircuitInput, townUncheckedUpdateWithoutCircuitInput>
  }

  export type townUpdateManyWithWhereWithoutCircuitInput = {
    where: townScalarWhereInput
    data: XOR<townUpdateManyMutationInput, townUncheckedUpdateManyWithoutTownInput>
  }

  export type townScalarWhereInput = {
    AND?: Enumerable<townScalarWhereInput>
    OR?: Enumerable<townScalarWhereInput>
    NOT?: Enumerable<townScalarWhereInput>
    id?: IntFilter | number
    circuit_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    postal_code?: IntFilter | number
  }

  export type collecte_observationCreateWithoutCollecteInput = {
    description: string
  }

  export type collecte_observationUncheckedCreateWithoutCollecteInput = {
    id?: number
    description: string
  }

  export type collecte_observationCreateOrConnectWithoutCollecteInput = {
    where: collecte_observationWhereUniqueInput
    create: XOR<collecte_observationCreateWithoutCollecteInput, collecte_observationUncheckedCreateWithoutCollecteInput>
  }

  export type collecte_observationCreateManyCollecteInputEnvelope = {
    data: Enumerable<collecte_observationCreateManyCollecteInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutCollecteInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutCollecteInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutCollecteInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutCollecteInput, reportUncheckedCreateWithoutCollecteInput>
  }

  export type reportCreateManyCollecteInputEnvelope = {
    data: Enumerable<reportCreateManyCollecteInput>
    skipDuplicates?: boolean
  }

  export type collecte_observationUpsertWithWhereUniqueWithoutCollecteInput = {
    where: collecte_observationWhereUniqueInput
    update: XOR<collecte_observationUpdateWithoutCollecteInput, collecte_observationUncheckedUpdateWithoutCollecteInput>
    create: XOR<collecte_observationCreateWithoutCollecteInput, collecte_observationUncheckedCreateWithoutCollecteInput>
  }

  export type collecte_observationUpdateWithWhereUniqueWithoutCollecteInput = {
    where: collecte_observationWhereUniqueInput
    data: XOR<collecte_observationUpdateWithoutCollecteInput, collecte_observationUncheckedUpdateWithoutCollecteInput>
  }

  export type collecte_observationUpdateManyWithWhereWithoutCollecteInput = {
    where: collecte_observationScalarWhereInput
    data: XOR<collecte_observationUpdateManyMutationInput, collecte_observationUncheckedUpdateManyWithoutCollecte_observationInput>
  }

  export type collecte_observationScalarWhereInput = {
    AND?: Enumerable<collecte_observationScalarWhereInput>
    OR?: Enumerable<collecte_observationScalarWhereInput>
    NOT?: Enumerable<collecte_observationScalarWhereInput>
    id?: IntFilter | number
    collecte_id?: IntNullableFilter | number | null
    description?: StringFilter | string
  }

  export type reportUpsertWithWhereUniqueWithoutCollecteInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutCollecteInput, reportUncheckedUpdateWithoutCollecteInput>
    create: XOR<reportCreateWithoutCollecteInput, reportUncheckedCreateWithoutCollecteInput>
  }

  export type reportUpdateWithWhereUniqueWithoutCollecteInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutCollecteInput, reportUncheckedUpdateWithoutCollecteInput>
  }

  export type reportUpdateManyWithWhereWithoutCollecteInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportInput>
  }

  export type collecteCreateWithoutCollecte_observationInput = {
    date: Date | string
    observation: string
    is_valid: boolean
    report?: reportCreateNestedManyWithoutCollecteInput
  }

  export type collecteUncheckedCreateWithoutCollecte_observationInput = {
    id?: number
    date: Date | string
    observation: string
    is_valid: boolean
    report?: reportUncheckedCreateNestedManyWithoutCollecteInput
  }

  export type collecteCreateOrConnectWithoutCollecte_observationInput = {
    where: collecteWhereUniqueInput
    create: XOR<collecteCreateWithoutCollecte_observationInput, collecteUncheckedCreateWithoutCollecte_observationInput>
  }

  export type collecteUpsertWithoutCollecte_observationInput = {
    update: XOR<collecteUpdateWithoutCollecte_observationInput, collecteUncheckedUpdateWithoutCollecte_observationInput>
    create: XOR<collecteCreateWithoutCollecte_observationInput, collecteUncheckedCreateWithoutCollecte_observationInput>
  }

  export type collecteUpdateWithoutCollecte_observationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    report?: reportUpdateManyWithoutCollecteNestedInput
  }

  export type collecteUncheckedUpdateWithoutCollecte_observationInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    report?: reportUncheckedUpdateManyWithoutCollecteNestedInput
  }

  export type container_typeCreateWithoutContainer_mouvementInput = {
    name: string
  }

  export type container_typeUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    name: string
  }

  export type container_typeCreateOrConnectWithoutContainer_mouvementInput = {
    where: container_typeWhereUniqueInput
    create: XOR<container_typeCreateWithoutContainer_mouvementInput, container_typeUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type operation_typeCreateWithoutContainer_mouvementInput = {
    name: string
  }

  export type operation_typeUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    name: string
  }

  export type operation_typeCreateOrConnectWithoutContainer_mouvementInput = {
    where: operation_typeWhereUniqueInput
    create: XOR<operation_typeCreateWithoutContainer_mouvementInput, operation_typeUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type worksiteCreateWithoutContainer_mouvementInput = {
    name: string
    adress?: string | null
    town?: townCreateNestedOneWithoutWorksiteInput
  }

  export type worksiteUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    town_id?: number | null
    name: string
    adress?: string | null
  }

  export type worksiteCreateOrConnectWithoutContainer_mouvementInput = {
    where: worksiteWhereUniqueInput
    create: XOR<worksiteCreateWithoutContainer_mouvementInput, worksiteUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type driverCreateWithoutContainer_mouvementInput = {
    last_name: string
    first_name: string
    type?: string | null
    replacement_team?: replacement_teamCreateNestedManyWithoutDriverInput
    sinister?: sinisterCreateNestedManyWithoutDriverInput
    team?: teamCreateNestedOneWithoutDriverInput
  }

  export type driverUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
    replacement_team?: replacement_teamUncheckedCreateNestedManyWithoutDriverInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutDriverInput
    team?: teamUncheckedCreateNestedOneWithoutDriverInput
  }

  export type driverCreateOrConnectWithoutContainer_mouvementInput = {
    where: driverWhereUniqueInput
    create: XOR<driverCreateWithoutContainer_mouvementInput, driverUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type truckCreateWithoutContainer_mouvementInput = {
    registration: string
    type?: string | null
    report?: reportCreateNestedManyWithoutTruckInput
    sinister?: sinisterCreateNestedManyWithoutTruckInput
    team?: teamCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    registration: string
    type?: string | null
    report?: reportUncheckedCreateNestedManyWithoutTruckInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutTruckInput
    team?: teamUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutContainer_mouvementInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutContainer_mouvementInput, truckUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type fluxCreateWithoutContainer_mouvementInput = {
    name: string
    circuit?: circuitCreateNestedOneWithoutFluxInput
    report?: reportCreateNestedManyWithoutFluxInput
    team?: teamCreateNestedManyWithoutFluxInput
  }

  export type fluxUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    name: string
    circuit_id?: number | null
    report?: reportUncheckedCreateNestedManyWithoutFluxInput
    team?: teamUncheckedCreateNestedManyWithoutFluxInput
  }

  export type fluxCreateOrConnectWithoutContainer_mouvementInput = {
    where: fluxWhereUniqueInput
    create: XOR<fluxCreateWithoutContainer_mouvementInput, fluxUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type outletCreateWithoutContainer_mouvementInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutContainer_mouvementInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutContainer_mouvementInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutContainer_mouvementInput, outletUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type container_typeUpsertWithoutContainer_mouvementInput = {
    update: XOR<container_typeUpdateWithoutContainer_mouvementInput, container_typeUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<container_typeCreateWithoutContainer_mouvementInput, container_typeUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type container_typeUpdateWithoutContainer_mouvementInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type container_typeUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type operation_typeUpsertWithoutContainer_mouvementInput = {
    update: XOR<operation_typeUpdateWithoutContainer_mouvementInput, operation_typeUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<operation_typeCreateWithoutContainer_mouvementInput, operation_typeUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type operation_typeUpdateWithoutContainer_mouvementInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type operation_typeUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type worksiteUpsertWithoutContainer_mouvementInput = {
    update: XOR<worksiteUpdateWithoutContainer_mouvementInput, worksiteUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<worksiteCreateWithoutContainer_mouvementInput, worksiteUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type worksiteUpdateWithoutContainer_mouvementInput = {
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    town?: townUpdateOneWithoutWorksiteNestedInput
  }

  export type worksiteUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    town_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driverUpsertWithoutContainer_mouvementInput = {
    update: XOR<driverUpdateWithoutContainer_mouvementInput, driverUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<driverCreateWithoutContainer_mouvementInput, driverUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type driverUpdateWithoutContainer_mouvementInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_team?: replacement_teamUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUpdateManyWithoutDriverNestedInput
    team?: teamUpdateOneWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_team?: replacement_teamUncheckedUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutDriverNestedInput
    team?: teamUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type truckUpsertWithoutContainer_mouvementInput = {
    update: XOR<truckUpdateWithoutContainer_mouvementInput, truckUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<truckCreateWithoutContainer_mouvementInput, truckUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type truckUpdateWithoutContainer_mouvementInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUpdateManyWithoutTruckNestedInput
    team?: teamUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportUncheckedUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutTruckNestedInput
    team?: teamUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type fluxUpsertWithoutContainer_mouvementInput = {
    update: XOR<fluxUpdateWithoutContainer_mouvementInput, fluxUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<fluxCreateWithoutContainer_mouvementInput, fluxUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type fluxUpdateWithoutContainer_mouvementInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateOneWithoutFluxNestedInput
    report?: reportUpdateManyWithoutFluxNestedInput
    team?: teamUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    report?: reportUncheckedUpdateManyWithoutFluxNestedInput
    team?: teamUncheckedUpdateManyWithoutFluxNestedInput
  }

  export type outletUpsertWithoutContainer_mouvementInput = {
    update: XOR<outletUpdateWithoutContainer_mouvementInput, outletUncheckedUpdateWithoutContainer_mouvementInput>
    create: XOR<outletCreateWithoutContainer_mouvementInput, outletUncheckedCreateWithoutContainer_mouvementInput>
  }

  export type outletUpdateWithoutContainer_mouvementInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type container_mouvementCreateWithoutContainer_typeInput = {
    description: string
    tonnage: number
    date: Date | string
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutContainer_typeInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutContainer_typeInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutContainer_typeInput, container_mouvementUncheckedCreateWithoutContainer_typeInput>
  }

  export type container_mouvementCreateManyContainer_typeInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyContainer_typeInput>
    skipDuplicates?: boolean
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutContainer_typeInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutContainer_typeInput, container_mouvementUncheckedUpdateWithoutContainer_typeInput>
    create: XOR<container_mouvementCreateWithoutContainer_typeInput, container_mouvementUncheckedCreateWithoutContainer_typeInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutContainer_typeInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutContainer_typeInput, container_mouvementUncheckedUpdateWithoutContainer_typeInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutContainer_typeInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type container_mouvementScalarWhereInput = {
    AND?: Enumerable<container_mouvementScalarWhereInput>
    OR?: Enumerable<container_mouvementScalarWhereInput>
    NOT?: Enumerable<container_mouvementScalarWhereInput>
    id?: IntFilter | number
    worksite_id?: IntNullableFilter | number | null
    driver_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    outlet_id?: IntNullableFilter | number | null
    description?: StringFilter | string
    tonnage?: FloatFilter | number
    operation_type_id?: IntNullableFilter | number | null
    container_type_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
  }

  export type container_mouvementCreateWithoutDriverInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutDriverInput = {
    id?: number
    worksite_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutDriverInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutDriverInput, container_mouvementUncheckedCreateWithoutDriverInput>
  }

  export type container_mouvementCreateManyDriverInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyDriverInput>
    skipDuplicates?: boolean
  }

  export type replacement_teamCreateWithoutDriverInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    team?: teamCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUncheckedCreateWithoutDriverInput = {
    id?: number
    substitute_ripper1_id?: number | null
    substitute_ripper2_id?: number | null
    team?: teamUncheckedCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamCreateOrConnectWithoutDriverInput = {
    where: replacement_teamWhereUniqueInput
    create: XOR<replacement_teamCreateWithoutDriverInput, replacement_teamUncheckedCreateWithoutDriverInput>
  }

  export type replacement_teamCreateManyDriverInputEnvelope = {
    data: Enumerable<replacement_teamCreateManyDriverInput>
    skipDuplicates?: boolean
  }

  export type sinisterCreateWithoutDriverInput = {
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
    truck?: truckCreateNestedOneWithoutSinisterInput
  }

  export type sinisterUncheckedCreateWithoutDriverInput = {
    id?: number
    truck_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type sinisterCreateOrConnectWithoutDriverInput = {
    where: sinisterWhereUniqueInput
    create: XOR<sinisterCreateWithoutDriverInput, sinisterUncheckedCreateWithoutDriverInput>
  }

  export type sinisterCreateManyDriverInputEnvelope = {
    data: Enumerable<sinisterCreateManyDriverInput>
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutDriverInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    truck?: truckCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutDriverInput = {
    id?: number
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutDriverInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutDriverInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutDriverInput, container_mouvementUncheckedUpdateWithoutDriverInput>
    create: XOR<container_mouvementCreateWithoutDriverInput, container_mouvementUncheckedCreateWithoutDriverInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutDriverInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutDriverInput, container_mouvementUncheckedUpdateWithoutDriverInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutDriverInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type replacement_teamUpsertWithWhereUniqueWithoutDriverInput = {
    where: replacement_teamWhereUniqueInput
    update: XOR<replacement_teamUpdateWithoutDriverInput, replacement_teamUncheckedUpdateWithoutDriverInput>
    create: XOR<replacement_teamCreateWithoutDriverInput, replacement_teamUncheckedCreateWithoutDriverInput>
  }

  export type replacement_teamUpdateWithWhereUniqueWithoutDriverInput = {
    where: replacement_teamWhereUniqueInput
    data: XOR<replacement_teamUpdateWithoutDriverInput, replacement_teamUncheckedUpdateWithoutDriverInput>
  }

  export type replacement_teamUpdateManyWithWhereWithoutDriverInput = {
    where: replacement_teamScalarWhereInput
    data: XOR<replacement_teamUpdateManyMutationInput, replacement_teamUncheckedUpdateManyWithoutReplacement_teamInput>
  }

  export type replacement_teamScalarWhereInput = {
    AND?: Enumerable<replacement_teamScalarWhereInput>
    OR?: Enumerable<replacement_teamScalarWhereInput>
    NOT?: Enumerable<replacement_teamScalarWhereInput>
    id?: IntFilter | number
    substitute_driver_id?: IntNullableFilter | number | null
    substitute_ripper1_id?: IntNullableFilter | number | null
    substitute_ripper2_id?: IntNullableFilter | number | null
  }

  export type sinisterUpsertWithWhereUniqueWithoutDriverInput = {
    where: sinisterWhereUniqueInput
    update: XOR<sinisterUpdateWithoutDriverInput, sinisterUncheckedUpdateWithoutDriverInput>
    create: XOR<sinisterCreateWithoutDriverInput, sinisterUncheckedCreateWithoutDriverInput>
  }

  export type sinisterUpdateWithWhereUniqueWithoutDriverInput = {
    where: sinisterWhereUniqueInput
    data: XOR<sinisterUpdateWithoutDriverInput, sinisterUncheckedUpdateWithoutDriverInput>
  }

  export type sinisterUpdateManyWithWhereWithoutDriverInput = {
    where: sinisterScalarWhereInput
    data: XOR<sinisterUpdateManyMutationInput, sinisterUncheckedUpdateManyWithoutSinisterInput>
  }

  export type sinisterScalarWhereInput = {
    AND?: Enumerable<sinisterScalarWhereInput>
    OR?: Enumerable<sinisterScalarWhereInput>
    NOT?: Enumerable<sinisterScalarWhereInput>
    id?: IntFilter | number
    truck_id?: IntNullableFilter | number | null
    driver_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    place?: StringFilter | string
    opposing_vehicule?: StringNullableFilter | string | null
    opposing_driver?: StringNullableFilter | string | null
    circumstance?: StringNullableFilter | string | null
    status?: StringFilter | string
    observation?: StringNullableFilter | string | null
  }

  export type teamUpsertWithoutDriverInput = {
    update: XOR<teamUpdateWithoutDriverInput, teamUncheckedUpdateWithoutDriverInput>
    create: XOR<teamCreateWithoutDriverInput, teamUncheckedCreateWithoutDriverInput>
  }

  export type teamUpdateWithoutDriverInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type container_mouvementCreateWithoutFluxInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutFluxInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutFluxInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutFluxInput, container_mouvementUncheckedCreateWithoutFluxInput>
  }

  export type container_mouvementCreateManyFluxInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyFluxInput>
    skipDuplicates?: boolean
  }

  export type circuitCreateWithoutFluxInput = {
    name: string
    outlet?: outletCreateNestedOneWithoutCircuitInput
    report?: reportCreateNestedManyWithoutCircuitInput
    town?: townCreateNestedManyWithoutCircuitInput
  }

  export type circuitUncheckedCreateWithoutFluxInput = {
    id?: number
    default_outlet_id?: number | null
    name: string
    report?: reportUncheckedCreateNestedManyWithoutCircuitInput
    town?: townUncheckedCreateNestedManyWithoutCircuitInput
  }

  export type circuitCreateOrConnectWithoutFluxInput = {
    where: circuitWhereUniqueInput
    create: XOR<circuitCreateWithoutFluxInput, circuitUncheckedCreateWithoutFluxInput>
  }

  export type reportCreateWithoutFluxInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutFluxInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutFluxInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutFluxInput, reportUncheckedCreateWithoutFluxInput>
  }

  export type reportCreateManyFluxInputEnvelope = {
    data: Enumerable<reportCreateManyFluxInput>
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutFluxInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    truck?: truckCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutFluxInput = {
    id?: number
    driver_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutFluxInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutFluxInput, teamUncheckedCreateWithoutFluxInput>
  }

  export type teamCreateManyFluxInputEnvelope = {
    data: Enumerable<teamCreateManyFluxInput>
    skipDuplicates?: boolean
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutFluxInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutFluxInput, container_mouvementUncheckedUpdateWithoutFluxInput>
    create: XOR<container_mouvementCreateWithoutFluxInput, container_mouvementUncheckedCreateWithoutFluxInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutFluxInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutFluxInput, container_mouvementUncheckedUpdateWithoutFluxInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutFluxInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type circuitUpsertWithoutFluxInput = {
    update: XOR<circuitUpdateWithoutFluxInput, circuitUncheckedUpdateWithoutFluxInput>
    create: XOR<circuitCreateWithoutFluxInput, circuitUncheckedCreateWithoutFluxInput>
  }

  export type circuitUpdateWithoutFluxInput = {
    name?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneWithoutCircuitNestedInput
    report?: reportUpdateManyWithoutCircuitNestedInput
    town?: townUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateWithoutFluxInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    report?: reportUncheckedUpdateManyWithoutCircuitNestedInput
    town?: townUncheckedUpdateManyWithoutCircuitNestedInput
  }

  export type reportUpsertWithWhereUniqueWithoutFluxInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutFluxInput, reportUncheckedUpdateWithoutFluxInput>
    create: XOR<reportCreateWithoutFluxInput, reportUncheckedCreateWithoutFluxInput>
  }

  export type reportUpdateWithWhereUniqueWithoutFluxInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutFluxInput, reportUncheckedUpdateWithoutFluxInput>
  }

  export type reportUpdateManyWithWhereWithoutFluxInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportInput>
  }

  export type teamUpsertWithWhereUniqueWithoutFluxInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutFluxInput, teamUncheckedUpdateWithoutFluxInput>
    create: XOR<teamCreateWithoutFluxInput, teamUncheckedCreateWithoutFluxInput>
  }

  export type teamUpdateWithWhereUniqueWithoutFluxInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutFluxInput, teamUncheckedUpdateWithoutFluxInput>
  }

  export type teamUpdateManyWithWhereWithoutFluxInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutTeamInput>
  }

  export type teamScalarWhereInput = {
    AND?: Enumerable<teamScalarWhereInput>
    OR?: Enumerable<teamScalarWhereInput>
    NOT?: Enumerable<teamScalarWhereInput>
    id?: IntFilter | number
    driver_id?: IntNullableFilter | number | null
    flux_id?: IntNullableFilter | number | null
    ripper1_id?: IntNullableFilter | number | null
    ripper2_id?: IntNullableFilter | number | null
    truck_id?: IntNullableFilter | number | null
    replacement_team_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    manual_circuit?: StringNullableFilter | string | null
    manual_tablet?: StringNullableFilter | string | null
  }

  export type container_mouvementCreateWithoutOperation_typeInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutOperation_typeInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutOperation_typeInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutOperation_typeInput, container_mouvementUncheckedCreateWithoutOperation_typeInput>
  }

  export type container_mouvementCreateManyOperation_typeInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyOperation_typeInput>
    skipDuplicates?: boolean
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutOperation_typeInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutOperation_typeInput, container_mouvementUncheckedUpdateWithoutOperation_typeInput>
    create: XOR<container_mouvementCreateWithoutOperation_typeInput, container_mouvementUncheckedCreateWithoutOperation_typeInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutOperation_typeInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutOperation_typeInput, container_mouvementUncheckedUpdateWithoutOperation_typeInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutOperation_typeInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type circuitCreateWithoutOutletInput = {
    name: string
    flux?: fluxCreateNestedManyWithoutCircuitInput
    report?: reportCreateNestedManyWithoutCircuitInput
    town?: townCreateNestedManyWithoutCircuitInput
  }

  export type circuitUncheckedCreateWithoutOutletInput = {
    id?: number
    name: string
    flux?: fluxUncheckedCreateNestedManyWithoutCircuitInput
    report?: reportUncheckedCreateNestedManyWithoutCircuitInput
    town?: townUncheckedCreateNestedManyWithoutCircuitInput
  }

  export type circuitCreateOrConnectWithoutOutletInput = {
    where: circuitWhereUniqueInput
    create: XOR<circuitCreateWithoutOutletInput, circuitUncheckedCreateWithoutOutletInput>
  }

  export type circuitCreateManyOutletInputEnvelope = {
    data: Enumerable<circuitCreateManyOutletInput>
    skipDuplicates?: boolean
  }

  export type container_mouvementCreateWithoutOutletInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutOutletInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutOutletInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutOutletInput, container_mouvementUncheckedCreateWithoutOutletInput>
  }

  export type container_mouvementCreateManyOutletInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyOutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_visited_outlet4_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_visited_outlet4_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_visited_outlet2_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_visited_outlet2_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_default_outlet_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput = {
    id?: number
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_default_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_default_outlet_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_default_outlet_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_default_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_default_outlet3_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_default_outlet3_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_visited_outlet3_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_visited_outlet3_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_visited_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_visited_outlet_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_visited_outlet_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_default_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_default_outlet2_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_default_outlet2_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutOutlet_report_default_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>
  }

  export type reportCreateManyOutlet_report_default_outlet4_idTooutletInputEnvelope = {
    data: Enumerable<reportCreateManyOutlet_report_default_outlet4_idTooutletInput>
    skipDuplicates?: boolean
  }

  export type circuitUpsertWithWhereUniqueWithoutOutletInput = {
    where: circuitWhereUniqueInput
    update: XOR<circuitUpdateWithoutOutletInput, circuitUncheckedUpdateWithoutOutletInput>
    create: XOR<circuitCreateWithoutOutletInput, circuitUncheckedCreateWithoutOutletInput>
  }

  export type circuitUpdateWithWhereUniqueWithoutOutletInput = {
    where: circuitWhereUniqueInput
    data: XOR<circuitUpdateWithoutOutletInput, circuitUncheckedUpdateWithoutOutletInput>
  }

  export type circuitUpdateManyWithWhereWithoutOutletInput = {
    where: circuitScalarWhereInput
    data: XOR<circuitUpdateManyMutationInput, circuitUncheckedUpdateManyWithoutCircuitInput>
  }

  export type circuitScalarWhereInput = {
    AND?: Enumerable<circuitScalarWhereInput>
    OR?: Enumerable<circuitScalarWhereInput>
    NOT?: Enumerable<circuitScalarWhereInput>
    id?: IntFilter | number
    default_outlet_id?: IntNullableFilter | number | null
    name?: StringFilter | string
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutOutletInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutOutletInput, container_mouvementUncheckedUpdateWithoutOutletInput>
    create: XOR<container_mouvementCreateWithoutOutletInput, container_mouvementUncheckedCreateWithoutOutletInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutOutletInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutOutletInput, container_mouvementUncheckedUpdateWithoutOutletInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutOutletInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet4_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet4_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_visited_outlet4_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet2_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet2_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_visited_outlet2_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_default_outlet_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_default_outlet_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_default_outlet_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_default_outlet_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_default_outlet_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_default_outlet3_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet3_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_default_outlet3_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet3_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_default_outlet3_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet3_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_default_outlet3_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_default_outlet3_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet3_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet3_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_visited_outlet3_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_visited_outlet_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_visited_outlet_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_visited_outlet_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_visited_outlet_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_visited_outlet_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_visited_outlet_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_visited_outlet_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_visited_outlet_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_default_outlet2_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet2_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_default_outlet2_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet2_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet2_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_default_outlet2_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet2_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_default_outlet2_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_default_outlet2_idTooutletInput>
  }

  export type reportUpsertWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutOutlet_report_default_outlet4_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet4_idTooutletInput>
    create: XOR<reportCreateWithoutOutlet_report_default_outlet4_idTooutletInput, reportUncheckedCreateWithoutOutlet_report_default_outlet4_idTooutletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutOutlet_report_default_outlet4_idTooutletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutOutlet_report_default_outlet4_idTooutletInput, reportUncheckedUpdateWithoutOutlet_report_default_outlet4_idTooutletInput>
  }

  export type reportUpdateManyWithWhereWithoutOutlet_report_default_outlet4_idTooutletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReport_report_default_outlet4_idTooutletInput>
  }

  export type ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    id?: number
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    where: ripperWhereUniqueInput
    create: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    team_team_ripper1_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    id?: number
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    team_team_ripper1_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperCreateOrConnectWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    where: ripperWhereUniqueInput
    create: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type driverCreateWithoutReplacement_teamInput = {
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutDriverInput
    sinister?: sinisterCreateNestedManyWithoutDriverInput
    team?: teamCreateNestedOneWithoutDriverInput
  }

  export type driverUncheckedCreateWithoutReplacement_teamInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutDriverInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutDriverInput
    team?: teamUncheckedCreateNestedOneWithoutDriverInput
  }

  export type driverCreateOrConnectWithoutReplacement_teamInput = {
    where: driverWhereUniqueInput
    create: XOR<driverCreateWithoutReplacement_teamInput, driverUncheckedCreateWithoutReplacement_teamInput>
  }

  export type teamCreateWithoutReplacement_teamInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    truck?: truckCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutReplacement_teamInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutReplacement_teamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
  }

  export type ripperUpsertWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    update: XOR<ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
    create: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUpsertWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    update: XOR<ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
    create: XOR<ripperCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput, ripperUncheckedCreateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type ripperUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUncheckedUpdateWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type driverUpsertWithoutReplacement_teamInput = {
    update: XOR<driverUpdateWithoutReplacement_teamInput, driverUncheckedUpdateWithoutReplacement_teamInput>
    create: XOR<driverCreateWithoutReplacement_teamInput, driverUncheckedCreateWithoutReplacement_teamInput>
  }

  export type driverUpdateWithoutReplacement_teamInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUpdateManyWithoutDriverNestedInput
    team?: teamUpdateOneWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateWithoutReplacement_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutDriverNestedInput
    team?: teamUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type teamUpsertWithoutReplacement_teamInput = {
    update: XOR<teamUpdateWithoutReplacement_teamInput, teamUncheckedUpdateWithoutReplacement_teamInput>
    create: XOR<teamCreateWithoutReplacement_teamInput, teamUncheckedCreateWithoutReplacement_teamInput>
  }

  export type teamUpdateWithoutReplacement_teamInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutReplacement_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type anomalyCreateWithoutReportInput = {
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    way?: wayCreateNestedOneWithoutAnomalyInput
    type_anomaly?: type_anomalyCreateNestedOneWithoutAnomalyInput
  }

  export type anomalyUncheckedCreateWithoutReportInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyCreateOrConnectWithoutReportInput = {
    where: anomalyWhereUniqueInput
    create: XOR<anomalyCreateWithoutReportInput, anomalyUncheckedCreateWithoutReportInput>
  }

  export type anomalyCreateManyReportInputEnvelope = {
    data: Enumerable<anomalyCreateManyReportInput>
    skipDuplicates?: boolean
  }

  export type outletCreateWithoutReport_report_visited_outlet4_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_visited_outlet4_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_visited_outlet4_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet4_idTooutletInput>
  }

  export type outletCreateWithoutReport_report_visited_outlet2_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_visited_outlet2_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_visited_outlet2_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet2_idTooutletInput>
  }

  export type outletCreateWithoutReport_report_default_outlet_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_default_outlet_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_default_outlet_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet_idTooutletInput>
  }

  export type collecteCreateWithoutReportInput = {
    date: Date | string
    observation: string
    is_valid: boolean
    collecte_observation?: collecte_observationCreateNestedManyWithoutCollecteInput
  }

  export type collecteUncheckedCreateWithoutReportInput = {
    id?: number
    date: Date | string
    observation: string
    is_valid: boolean
    collecte_observation?: collecte_observationUncheckedCreateNestedManyWithoutCollecteInput
  }

  export type collecteCreateOrConnectWithoutReportInput = {
    where: collecteWhereUniqueInput
    create: XOR<collecteCreateWithoutReportInput, collecteUncheckedCreateWithoutReportInput>
  }

  export type outletCreateWithoutReport_report_default_outlet3_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_default_outlet3_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_default_outlet3_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet3_idTooutletInput>
  }

  export type outletCreateWithoutReport_report_visited_outlet3_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_visited_outlet3_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_visited_outlet3_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet3_idTooutletInput>
  }

  export type outletCreateWithoutReport_report_visited_outlet_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_visited_outlet_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_visited_outlet_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet_idTooutletInput>
  }

  export type outletCreateWithoutReport_report_default_outlet2_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_default_outlet2_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet4_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_default_outlet2_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet2_idTooutletInput>
  }

  export type truckCreateWithoutReportInput = {
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutTruckInput
    sinister?: sinisterCreateNestedManyWithoutTruckInput
    team?: teamCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutReportInput = {
    id?: number
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutTruckInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutTruckInput
    team?: teamUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutReportInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutReportInput, truckUncheckedCreateWithoutReportInput>
  }

  export type fluxCreateWithoutReportInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutFluxInput
    circuit?: circuitCreateNestedOneWithoutFluxInput
    team?: teamCreateNestedManyWithoutFluxInput
  }

  export type fluxUncheckedCreateWithoutReportInput = {
    id?: number
    name: string
    circuit_id?: number | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutFluxInput
    team?: teamUncheckedCreateNestedManyWithoutFluxInput
  }

  export type fluxCreateOrConnectWithoutReportInput = {
    where: fluxWhereUniqueInput
    create: XOR<fluxCreateWithoutReportInput, fluxUncheckedCreateWithoutReportInput>
  }

  export type circuitCreateWithoutReportInput = {
    name: string
    outlet?: outletCreateNestedOneWithoutCircuitInput
    flux?: fluxCreateNestedManyWithoutCircuitInput
    town?: townCreateNestedManyWithoutCircuitInput
  }

  export type circuitUncheckedCreateWithoutReportInput = {
    id?: number
    default_outlet_id?: number | null
    name: string
    flux?: fluxUncheckedCreateNestedManyWithoutCircuitInput
    town?: townUncheckedCreateNestedManyWithoutCircuitInput
  }

  export type circuitCreateOrConnectWithoutReportInput = {
    where: circuitWhereUniqueInput
    create: XOR<circuitCreateWithoutReportInput, circuitUncheckedCreateWithoutReportInput>
  }

  export type outletCreateWithoutReport_report_default_outlet4_idTooutletInput = {
    name: string
    circuit?: circuitCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
  }

  export type outletUncheckedCreateWithoutReport_report_default_outlet4_idTooutletInput = {
    id?: number
    name: string
    circuit?: circuitUncheckedCreateNestedManyWithoutOutletInput
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutOutletInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet4_idTooutletInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet2_idTooutletInput
    report_report_default_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet_idTooutletInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet3_idTooutletInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet3_idTooutletInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_visited_outlet_idTooutletInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedCreateNestedManyWithoutOutlet_report_default_outlet2_idTooutletInput
  }

  export type outletCreateOrConnectWithoutReport_report_default_outlet4_idTooutletInput = {
    where: outletWhereUniqueInput
    create: XOR<outletCreateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet4_idTooutletInput>
  }

  export type tabletCreateWithoutReportInput = {
    label: string
  }

  export type tabletUncheckedCreateWithoutReportInput = {
    id?: number
    label: string
  }

  export type tabletCreateOrConnectWithoutReportInput = {
    where: tabletWhereUniqueInput
    create: XOR<tabletCreateWithoutReportInput, tabletUncheckedCreateWithoutReportInput>
  }

  export type anomalyUpsertWithWhereUniqueWithoutReportInput = {
    where: anomalyWhereUniqueInput
    update: XOR<anomalyUpdateWithoutReportInput, anomalyUncheckedUpdateWithoutReportInput>
    create: XOR<anomalyCreateWithoutReportInput, anomalyUncheckedCreateWithoutReportInput>
  }

  export type anomalyUpdateWithWhereUniqueWithoutReportInput = {
    where: anomalyWhereUniqueInput
    data: XOR<anomalyUpdateWithoutReportInput, anomalyUncheckedUpdateWithoutReportInput>
  }

  export type anomalyUpdateManyWithWhereWithoutReportInput = {
    where: anomalyScalarWhereInput
    data: XOR<anomalyUpdateManyMutationInput, anomalyUncheckedUpdateManyWithoutAnomalyInput>
  }

  export type anomalyScalarWhereInput = {
    AND?: Enumerable<anomalyScalarWhereInput>
    OR?: Enumerable<anomalyScalarWhereInput>
    NOT?: Enumerable<anomalyScalarWhereInput>
    id?: IntFilter | number
    way_id?: IntNullableFilter | number | null
    date?: DateTimeFilter | Date | string
    type?: StringNullableFilter | string | null
    is_collected?: StringFilter | string
    regularization_date?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    report_id?: IntNullableFilter | number | null
    manual_town?: StringNullableFilter | string | null
    manual_way?: StringNullableFilter | string | null
    manual_flux?: StringNullableFilter | string | null
    manual_truck?: StringNullableFilter | string | null
    type_anomaly_id?: IntNullableFilter | number | null
  }

  export type outletUpsertWithoutReport_report_visited_outlet4_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet4_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_visited_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet4_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_visited_outlet4_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_visited_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUpsertWithoutReport_report_visited_outlet2_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet2_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_visited_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet2_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_visited_outlet2_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_visited_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUpsertWithoutReport_report_default_outlet_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_default_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_default_outlet_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_default_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type collecteUpsertWithoutReportInput = {
    update: XOR<collecteUpdateWithoutReportInput, collecteUncheckedUpdateWithoutReportInput>
    create: XOR<collecteCreateWithoutReportInput, collecteUncheckedCreateWithoutReportInput>
  }

  export type collecteUpdateWithoutReportInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    collecte_observation?: collecte_observationUpdateManyWithoutCollecteNestedInput
  }

  export type collecteUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    observation?: StringFieldUpdateOperationsInput | string
    is_valid?: BoolFieldUpdateOperationsInput | boolean
    collecte_observation?: collecte_observationUncheckedUpdateManyWithoutCollecteNestedInput
  }

  export type outletUpsertWithoutReport_report_default_outlet3_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet3_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_default_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet3_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_default_outlet3_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_default_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUpsertWithoutReport_report_visited_outlet3_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet3_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_visited_outlet3_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet3_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_visited_outlet3_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_visited_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUpsertWithoutReport_report_visited_outlet_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedUpdateWithoutReport_report_visited_outlet_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_visited_outlet_idTooutletInput, outletUncheckedCreateWithoutReport_report_visited_outlet_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_visited_outlet_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_visited_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUpsertWithoutReport_report_default_outlet2_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet2_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_default_outlet2_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet2_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_default_outlet2_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_default_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet4_idTooutletNestedInput
  }

  export type truckUpsertWithoutReportInput = {
    update: XOR<truckUpdateWithoutReportInput, truckUncheckedUpdateWithoutReportInput>
    create: XOR<truckCreateWithoutReportInput, truckUncheckedCreateWithoutReportInput>
  }

  export type truckUpdateWithoutReportInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUpdateManyWithoutTruckNestedInput
    team?: teamUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutTruckNestedInput
    team?: teamUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type fluxUpsertWithoutReportInput = {
    update: XOR<fluxUpdateWithoutReportInput, fluxUncheckedUpdateWithoutReportInput>
    create: XOR<fluxCreateWithoutReportInput, fluxUncheckedCreateWithoutReportInput>
  }

  export type fluxUpdateWithoutReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutFluxNestedInput
    circuit?: circuitUpdateOneWithoutFluxNestedInput
    team?: teamUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutFluxNestedInput
    team?: teamUncheckedUpdateManyWithoutFluxNestedInput
  }

  export type circuitUpsertWithoutReportInput = {
    update: XOR<circuitUpdateWithoutReportInput, circuitUncheckedUpdateWithoutReportInput>
    create: XOR<circuitCreateWithoutReportInput, circuitUncheckedCreateWithoutReportInput>
  }

  export type circuitUpdateWithoutReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneWithoutCircuitNestedInput
    flux?: fluxUpdateManyWithoutCircuitNestedInput
    town?: townUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    flux?: fluxUncheckedUpdateManyWithoutCircuitNestedInput
    town?: townUncheckedUpdateManyWithoutCircuitNestedInput
  }

  export type outletUpsertWithoutReport_report_default_outlet4_idTooutletInput = {
    update: XOR<outletUpdateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedUpdateWithoutReport_report_default_outlet4_idTooutletInput>
    create: XOR<outletCreateWithoutReport_report_default_outlet4_idTooutletInput, outletUncheckedCreateWithoutReport_report_default_outlet4_idTooutletInput>
  }

  export type outletUpdateWithoutReport_report_default_outlet4_idTooutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
  }

  export type outletUncheckedUpdateWithoutReport_report_default_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit?: circuitUncheckedUpdateManyWithoutOutletNestedInput
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutOutletNestedInput
    report_report_visited_outlet4_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet4_idTooutletNestedInput
    report_report_visited_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet2_idTooutletNestedInput
    report_report_default_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet_idTooutletNestedInput
    report_report_default_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet3_idTooutletNestedInput
    report_report_visited_outlet3_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet3_idTooutletNestedInput
    report_report_visited_outlet_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_visited_outlet_idTooutletNestedInput
    report_report_default_outlet2_idTooutlet?: reportUncheckedUpdateManyWithoutOutlet_report_default_outlet2_idTooutletNestedInput
  }

  export type tabletUpsertWithoutReportInput = {
    update: XOR<tabletUpdateWithoutReportInput, tabletUncheckedUpdateWithoutReportInput>
    create: XOR<tabletCreateWithoutReportInput, tabletUncheckedCreateWithoutReportInput>
  }

  export type tabletUpdateWithoutReportInput = {
    label?: StringFieldUpdateOperationsInput | string
  }

  export type tabletUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
  }

  export type replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    driver?: driverCreateNestedOneWithoutReplacement_teamInput
    team?: teamCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper1_id?: number | null
    team?: teamUncheckedCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    create: XOR<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput, replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInputEnvelope = {
    data: Enumerable<replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInput>
    skipDuplicates?: boolean
  }

  export type replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutReplacement_teamInput
    team?: teamCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper2_id?: number | null
    team?: teamUncheckedCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamCreateOrConnectWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    create: XOR<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput, replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInputEnvelope = {
    data: Enumerable<replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInput>
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutRipper_team_ripper1_idToripperInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    truck?: truckCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutRipper_team_ripper1_idToripperInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
  }

  export type teamCreateWithoutRipper_team_ripper2_idToripperInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    truck?: truckCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutRipper_team_ripper2_idToripperInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
  }

  export type replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    update: XOR<replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput, replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
    create: XOR<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput, replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    data: XOR<replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput, replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    where: replacement_teamScalarWhereInput
    data: XOR<replacement_teamUpdateManyMutationInput, replacement_teamUncheckedUpdateManyWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput>
  }

  export type replacement_teamUpsertWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    update: XOR<replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput, replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
    create: XOR<replacement_teamCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput, replacement_teamUncheckedCreateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type replacement_teamUpdateWithWhereUniqueWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    where: replacement_teamWhereUniqueInput
    data: XOR<replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput, replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type replacement_teamUpdateManyWithWhereWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    where: replacement_teamScalarWhereInput
    data: XOR<replacement_teamUpdateManyMutationInput, replacement_teamUncheckedUpdateManyWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput>
  }

  export type teamUpsertWithoutRipper_team_ripper1_idToripperInput = {
    update: XOR<teamUpdateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper1_idToripperInput>
    create: XOR<teamCreateWithoutRipper_team_ripper1_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper1_idToripperInput>
  }

  export type teamUpdateWithoutRipper_team_ripper1_idToripperInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutRipper_team_ripper1_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUpsertWithoutRipper_team_ripper2_idToripperInput = {
    update: XOR<teamUpdateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedUpdateWithoutRipper_team_ripper2_idToripperInput>
    create: XOR<teamCreateWithoutRipper_team_ripper2_idToripperInput, teamUncheckedCreateWithoutRipper_team_ripper2_idToripperInput>
  }

  export type teamUpdateWithoutRipper_team_ripper2_idToripperInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutRipper_team_ripper2_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driverCreateWithoutSinisterInput = {
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamCreateNestedManyWithoutDriverInput
    team?: teamCreateNestedOneWithoutDriverInput
  }

  export type driverUncheckedCreateWithoutSinisterInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamUncheckedCreateNestedManyWithoutDriverInput
    team?: teamUncheckedCreateNestedOneWithoutDriverInput
  }

  export type driverCreateOrConnectWithoutSinisterInput = {
    where: driverWhereUniqueInput
    create: XOR<driverCreateWithoutSinisterInput, driverUncheckedCreateWithoutSinisterInput>
  }

  export type truckCreateWithoutSinisterInput = {
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutTruckInput
    report?: reportCreateNestedManyWithoutTruckInput
    team?: teamCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutSinisterInput = {
    id?: number
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutTruckInput
    report?: reportUncheckedCreateNestedManyWithoutTruckInput
    team?: teamUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutSinisterInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutSinisterInput, truckUncheckedCreateWithoutSinisterInput>
  }

  export type driverUpsertWithoutSinisterInput = {
    update: XOR<driverUpdateWithoutSinisterInput, driverUncheckedUpdateWithoutSinisterInput>
    create: XOR<driverCreateWithoutSinisterInput, driverUncheckedCreateWithoutSinisterInput>
  }

  export type driverUpdateWithoutSinisterInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUpdateManyWithoutDriverNestedInput
    team?: teamUpdateOneWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateWithoutSinisterInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUncheckedUpdateManyWithoutDriverNestedInput
    team?: teamUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type truckUpsertWithoutSinisterInput = {
    update: XOR<truckUpdateWithoutSinisterInput, truckUncheckedUpdateWithoutSinisterInput>
    create: XOR<truckCreateWithoutSinisterInput, truckUncheckedCreateWithoutSinisterInput>
  }

  export type truckUpdateWithoutSinisterInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutTruckNestedInput
    report?: reportUpdateManyWithoutTruckNestedInput
    team?: teamUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutSinisterInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutTruckNestedInput
    report?: reportUncheckedUpdateManyWithoutTruckNestedInput
    team?: teamUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type reportCreateWithoutTabletInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    truck?: truckCreateNestedOneWithoutReportInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
  }

  export type reportUncheckedCreateWithoutTabletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutTabletInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutTabletInput, reportUncheckedCreateWithoutTabletInput>
  }

  export type reportCreateManyTabletInputEnvelope = {
    data: Enumerable<reportCreateManyTabletInput>
    skipDuplicates?: boolean
  }

  export type reportUpsertWithWhereUniqueWithoutTabletInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutTabletInput, reportUncheckedUpdateWithoutTabletInput>
    create: XOR<reportCreateWithoutTabletInput, reportUncheckedCreateWithoutTabletInput>
  }

  export type reportUpdateWithWhereUniqueWithoutTabletInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutTabletInput, reportUncheckedUpdateWithoutTabletInput>
  }

  export type reportUpdateManyWithWhereWithoutTabletInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportInput>
  }

  export type ripperCreateWithoutTeam_team_ripper1_idToripperInput = {
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperUncheckedCreateWithoutTeam_team_ripper1_idToripperInput = {
    id?: number
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper2_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper2_idToripperInput
  }

  export type ripperCreateOrConnectWithoutTeam_team_ripper1_idToripperInput = {
    where: ripperWhereUniqueInput
    create: XOR<ripperCreateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper1_idToripperInput>
  }

  export type ripperCreateWithoutTeam_team_ripper2_idToripperInput = {
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
  }

  export type ripperUncheckedCreateWithoutTeam_team_ripper2_idToripperInput = {
    id?: number
    last_name: string
    first_name: string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper2_idToripperInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedCreateNestedManyWithoutRipper_replacement_team_substitute_ripper1_idToripperInput
    team_team_ripper1_idToripper?: teamUncheckedCreateNestedOneWithoutRipper_team_ripper1_idToripperInput
  }

  export type ripperCreateOrConnectWithoutTeam_team_ripper2_idToripperInput = {
    where: ripperWhereUniqueInput
    create: XOR<ripperCreateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper2_idToripperInput>
  }

  export type driverCreateWithoutTeamInput = {
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamCreateNestedManyWithoutDriverInput
    sinister?: sinisterCreateNestedManyWithoutDriverInput
  }

  export type driverUncheckedCreateWithoutTeamInput = {
    id?: number
    last_name: string
    first_name: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutDriverInput
    replacement_team?: replacement_teamUncheckedCreateNestedManyWithoutDriverInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutDriverInput
  }

  export type driverCreateOrConnectWithoutTeamInput = {
    where: driverWhereUniqueInput
    create: XOR<driverCreateWithoutTeamInput, driverUncheckedCreateWithoutTeamInput>
  }

  export type truckCreateWithoutTeamInput = {
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutTruckInput
    report?: reportCreateNestedManyWithoutTruckInput
    sinister?: sinisterCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutTeamInput = {
    id?: number
    registration: string
    type?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutTruckInput
    report?: reportUncheckedCreateNestedManyWithoutTruckInput
    sinister?: sinisterUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutTeamInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutTeamInput, truckUncheckedCreateWithoutTeamInput>
  }

  export type fluxCreateWithoutTeamInput = {
    name: string
    container_mouvement?: container_mouvementCreateNestedManyWithoutFluxInput
    circuit?: circuitCreateNestedOneWithoutFluxInput
    report?: reportCreateNestedManyWithoutFluxInput
  }

  export type fluxUncheckedCreateWithoutTeamInput = {
    id?: number
    name: string
    circuit_id?: number | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutFluxInput
    report?: reportUncheckedCreateNestedManyWithoutFluxInput
  }

  export type fluxCreateOrConnectWithoutTeamInput = {
    where: fluxWhereUniqueInput
    create: XOR<fluxCreateWithoutTeamInput, fluxUncheckedCreateWithoutTeamInput>
  }

  export type replacement_teamCreateWithoutTeamInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperCreateNestedOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput
    driver?: driverCreateNestedOneWithoutReplacement_teamInput
  }

  export type replacement_teamUncheckedCreateWithoutTeamInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper1_id?: number | null
    substitute_ripper2_id?: number | null
  }

  export type replacement_teamCreateOrConnectWithoutTeamInput = {
    where: replacement_teamWhereUniqueInput
    create: XOR<replacement_teamCreateWithoutTeamInput, replacement_teamUncheckedCreateWithoutTeamInput>
  }

  export type ripperUpsertWithoutTeam_team_ripper1_idToripperInput = {
    update: XOR<ripperUpdateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedUpdateWithoutTeam_team_ripper1_idToripperInput>
    create: XOR<ripperCreateWithoutTeam_team_ripper1_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper1_idToripperInput>
  }

  export type ripperUpdateWithoutTeam_team_ripper1_idToripperInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUncheckedUpdateWithoutTeam_team_ripper1_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper2_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper2_idToripperNestedInput
  }

  export type ripperUpsertWithoutTeam_team_ripper2_idToripperInput = {
    update: XOR<ripperUpdateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedUpdateWithoutTeam_team_ripper2_idToripperInput>
    create: XOR<ripperCreateWithoutTeam_team_ripper2_idToripperInput, ripperUncheckedCreateWithoutTeam_team_ripper2_idToripperInput>
  }

  export type ripperUpdateWithoutTeam_team_ripper2_idToripperInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
  }

  export type ripperUncheckedUpdateWithoutTeam_team_ripper2_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    replacement_team_replacement_team_substitute_ripper2_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper2_idToripperNestedInput
    replacement_team_replacement_team_substitute_ripper1_idToripper?: replacement_teamUncheckedUpdateManyWithoutRipper_replacement_team_substitute_ripper1_idToripperNestedInput
    team_team_ripper1_idToripper?: teamUncheckedUpdateOneWithoutRipper_team_ripper1_idToripperNestedInput
  }

  export type driverUpsertWithoutTeamInput = {
    update: XOR<driverUpdateWithoutTeamInput, driverUncheckedUpdateWithoutTeamInput>
    create: XOR<driverCreateWithoutTeamInput, driverUncheckedCreateWithoutTeamInput>
  }

  export type driverUpdateWithoutTeamInput = {
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUpdateManyWithoutDriverNestedInput
  }

  export type driverUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    last_name?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutDriverNestedInput
    replacement_team?: replacement_teamUncheckedUpdateManyWithoutDriverNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type truckUpsertWithoutTeamInput = {
    update: XOR<truckUpdateWithoutTeamInput, truckUncheckedUpdateWithoutTeamInput>
    create: XOR<truckCreateWithoutTeamInput, truckUncheckedCreateWithoutTeamInput>
  }

  export type truckUpdateWithoutTeamInput = {
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutTruckNestedInput
    report?: reportUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    registration?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutTruckNestedInput
    report?: reportUncheckedUpdateManyWithoutTruckNestedInput
    sinister?: sinisterUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type fluxUpsertWithoutTeamInput = {
    update: XOR<fluxUpdateWithoutTeamInput, fluxUncheckedUpdateWithoutTeamInput>
    create: XOR<fluxCreateWithoutTeamInput, fluxUncheckedCreateWithoutTeamInput>
  }

  export type fluxUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutFluxNestedInput
    circuit?: circuitUpdateOneWithoutFluxNestedInput
    report?: reportUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutFluxNestedInput
    report?: reportUncheckedUpdateManyWithoutFluxNestedInput
  }

  export type replacement_teamUpsertWithoutTeamInput = {
    update: XOR<replacement_teamUpdateWithoutTeamInput, replacement_teamUncheckedUpdateWithoutTeamInput>
    create: XOR<replacement_teamCreateWithoutTeamInput, replacement_teamUncheckedCreateWithoutTeamInput>
  }

  export type replacement_teamUpdateWithoutTeamInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperNestedInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperNestedInput
    driver?: driverUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type circuitCreateWithoutTownInput = {
    name: string
    outlet?: outletCreateNestedOneWithoutCircuitInput
    flux?: fluxCreateNestedManyWithoutCircuitInput
    report?: reportCreateNestedManyWithoutCircuitInput
  }

  export type circuitUncheckedCreateWithoutTownInput = {
    id?: number
    default_outlet_id?: number | null
    name: string
    flux?: fluxUncheckedCreateNestedManyWithoutCircuitInput
    report?: reportUncheckedCreateNestedManyWithoutCircuitInput
  }

  export type circuitCreateOrConnectWithoutTownInput = {
    where: circuitWhereUniqueInput
    create: XOR<circuitCreateWithoutTownInput, circuitUncheckedCreateWithoutTownInput>
  }

  export type wayCreateWithoutTownInput = {
    name: string
    type?: string | null
    anomaly?: anomalyCreateNestedManyWithoutWayInput
  }

  export type wayUncheckedCreateWithoutTownInput = {
    id?: number
    name: string
    type?: string | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutWayInput
  }

  export type wayCreateOrConnectWithoutTownInput = {
    where: wayWhereUniqueInput
    create: XOR<wayCreateWithoutTownInput, wayUncheckedCreateWithoutTownInput>
  }

  export type wayCreateManyTownInputEnvelope = {
    data: Enumerable<wayCreateManyTownInput>
    skipDuplicates?: boolean
  }

  export type worksiteCreateWithoutTownInput = {
    name: string
    adress?: string | null
    container_mouvement?: container_mouvementCreateNestedManyWithoutWorksiteInput
  }

  export type worksiteUncheckedCreateWithoutTownInput = {
    id?: number
    name: string
    adress?: string | null
    container_mouvement?: container_mouvementUncheckedCreateNestedManyWithoutWorksiteInput
  }

  export type worksiteCreateOrConnectWithoutTownInput = {
    where: worksiteWhereUniqueInput
    create: XOR<worksiteCreateWithoutTownInput, worksiteUncheckedCreateWithoutTownInput>
  }

  export type worksiteCreateManyTownInputEnvelope = {
    data: Enumerable<worksiteCreateManyTownInput>
    skipDuplicates?: boolean
  }

  export type circuitUpsertWithoutTownInput = {
    update: XOR<circuitUpdateWithoutTownInput, circuitUncheckedUpdateWithoutTownInput>
    create: XOR<circuitCreateWithoutTownInput, circuitUncheckedCreateWithoutTownInput>
  }

  export type circuitUpdateWithoutTownInput = {
    name?: StringFieldUpdateOperationsInput | string
    outlet?: outletUpdateOneWithoutCircuitNestedInput
    flux?: fluxUpdateManyWithoutCircuitNestedInput
    report?: reportUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateWithoutTownInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    flux?: fluxUncheckedUpdateManyWithoutCircuitNestedInput
    report?: reportUncheckedUpdateManyWithoutCircuitNestedInput
  }

  export type wayUpsertWithWhereUniqueWithoutTownInput = {
    where: wayWhereUniqueInput
    update: XOR<wayUpdateWithoutTownInput, wayUncheckedUpdateWithoutTownInput>
    create: XOR<wayCreateWithoutTownInput, wayUncheckedCreateWithoutTownInput>
  }

  export type wayUpdateWithWhereUniqueWithoutTownInput = {
    where: wayWhereUniqueInput
    data: XOR<wayUpdateWithoutTownInput, wayUncheckedUpdateWithoutTownInput>
  }

  export type wayUpdateManyWithWhereWithoutTownInput = {
    where: wayScalarWhereInput
    data: XOR<wayUpdateManyMutationInput, wayUncheckedUpdateManyWithoutWayInput>
  }

  export type wayScalarWhereInput = {
    AND?: Enumerable<wayScalarWhereInput>
    OR?: Enumerable<wayScalarWhereInput>
    NOT?: Enumerable<wayScalarWhereInput>
    id?: IntFilter | number
    town_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    type?: StringNullableFilter | string | null
  }

  export type worksiteUpsertWithWhereUniqueWithoutTownInput = {
    where: worksiteWhereUniqueInput
    update: XOR<worksiteUpdateWithoutTownInput, worksiteUncheckedUpdateWithoutTownInput>
    create: XOR<worksiteCreateWithoutTownInput, worksiteUncheckedCreateWithoutTownInput>
  }

  export type worksiteUpdateWithWhereUniqueWithoutTownInput = {
    where: worksiteWhereUniqueInput
    data: XOR<worksiteUpdateWithoutTownInput, worksiteUncheckedUpdateWithoutTownInput>
  }

  export type worksiteUpdateManyWithWhereWithoutTownInput = {
    where: worksiteScalarWhereInput
    data: XOR<worksiteUpdateManyMutationInput, worksiteUncheckedUpdateManyWithoutWorksiteInput>
  }

  export type worksiteScalarWhereInput = {
    AND?: Enumerable<worksiteScalarWhereInput>
    OR?: Enumerable<worksiteScalarWhereInput>
    NOT?: Enumerable<worksiteScalarWhereInput>
    id?: IntFilter | number
    town_id?: IntNullableFilter | number | null
    name?: StringFilter | string
    adress?: StringNullableFilter | string | null
  }

  export type container_mouvementCreateWithoutTruckInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    worksite?: worksiteCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutTruckInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutTruckInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutTruckInput, container_mouvementUncheckedCreateWithoutTruckInput>
  }

  export type container_mouvementCreateManyTruckInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyTruckInput>
    skipDuplicates?: boolean
  }

  export type reportCreateWithoutTruckInput = {
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    observation?: string | null
    anomaly?: anomalyCreateNestedManyWithoutReportInput
    outlet_report_visited_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet4_idTooutletInput
    outlet_report_visited_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet2_idTooutletInput
    outlet_report_default_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet_idTooutletInput
    collecte?: collecteCreateNestedOneWithoutReportInput
    outlet_report_default_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet3_idTooutletInput
    outlet_report_visited_outlet3_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet3_idTooutletInput
    outlet_report_visited_outlet_idTooutlet?: outletCreateNestedOneWithoutReport_report_visited_outlet_idTooutletInput
    outlet_report_default_outlet2_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet2_idTooutletInput
    flux?: fluxCreateNestedOneWithoutReportInput
    circuit?: circuitCreateNestedOneWithoutReportInput
    outlet_report_default_outlet4_idTooutlet?: outletCreateNestedOneWithoutReport_report_default_outlet4_idTooutletInput
    tablet?: tabletCreateNestedOneWithoutReportInput
  }

  export type reportUncheckedCreateWithoutTruckInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
    anomaly?: anomalyUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportCreateOrConnectWithoutTruckInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutTruckInput, reportUncheckedCreateWithoutTruckInput>
  }

  export type reportCreateManyTruckInputEnvelope = {
    data: Enumerable<reportCreateManyTruckInput>
    skipDuplicates?: boolean
  }

  export type sinisterCreateWithoutTruckInput = {
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
    driver?: driverCreateNestedOneWithoutSinisterInput
  }

  export type sinisterUncheckedCreateWithoutTruckInput = {
    id?: number
    driver_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type sinisterCreateOrConnectWithoutTruckInput = {
    where: sinisterWhereUniqueInput
    create: XOR<sinisterCreateWithoutTruckInput, sinisterUncheckedCreateWithoutTruckInput>
  }

  export type sinisterCreateManyTruckInputEnvelope = {
    data: Enumerable<sinisterCreateManyTruckInput>
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutTruckInput = {
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
    ripper_team_ripper1_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper1_idToripperInput
    ripper_team_ripper2_idToripper?: ripperCreateNestedOneWithoutTeam_team_ripper2_idToripperInput
    driver?: driverCreateNestedOneWithoutTeamInput
    flux?: fluxCreateNestedOneWithoutTeamInput
    replacement_team?: replacement_teamCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTruckInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type teamCreateOrConnectWithoutTruckInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTruckInput, teamUncheckedCreateWithoutTruckInput>
  }

  export type teamCreateManyTruckInputEnvelope = {
    data: Enumerable<teamCreateManyTruckInput>
    skipDuplicates?: boolean
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutTruckInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutTruckInput, container_mouvementUncheckedUpdateWithoutTruckInput>
    create: XOR<container_mouvementCreateWithoutTruckInput, container_mouvementUncheckedCreateWithoutTruckInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutTruckInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutTruckInput, container_mouvementUncheckedUpdateWithoutTruckInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutTruckInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type reportUpsertWithWhereUniqueWithoutTruckInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutTruckInput, reportUncheckedUpdateWithoutTruckInput>
    create: XOR<reportCreateWithoutTruckInput, reportUncheckedCreateWithoutTruckInput>
  }

  export type reportUpdateWithWhereUniqueWithoutTruckInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutTruckInput, reportUncheckedUpdateWithoutTruckInput>
  }

  export type reportUpdateManyWithWhereWithoutTruckInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportInput>
  }

  export type sinisterUpsertWithWhereUniqueWithoutTruckInput = {
    where: sinisterWhereUniqueInput
    update: XOR<sinisterUpdateWithoutTruckInput, sinisterUncheckedUpdateWithoutTruckInput>
    create: XOR<sinisterCreateWithoutTruckInput, sinisterUncheckedCreateWithoutTruckInput>
  }

  export type sinisterUpdateWithWhereUniqueWithoutTruckInput = {
    where: sinisterWhereUniqueInput
    data: XOR<sinisterUpdateWithoutTruckInput, sinisterUncheckedUpdateWithoutTruckInput>
  }

  export type sinisterUpdateManyWithWhereWithoutTruckInput = {
    where: sinisterScalarWhereInput
    data: XOR<sinisterUpdateManyMutationInput, sinisterUncheckedUpdateManyWithoutSinisterInput>
  }

  export type teamUpsertWithWhereUniqueWithoutTruckInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutTruckInput, teamUncheckedUpdateWithoutTruckInput>
    create: XOR<teamCreateWithoutTruckInput, teamUncheckedCreateWithoutTruckInput>
  }

  export type teamUpdateWithWhereUniqueWithoutTruckInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutTruckInput, teamUncheckedUpdateWithoutTruckInput>
  }

  export type teamUpdateManyWithWhereWithoutTruckInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutTeamInput>
  }

  export type anomalyCreateWithoutType_anomalyInput = {
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    report?: reportCreateNestedOneWithoutAnomalyInput
    way?: wayCreateNestedOneWithoutAnomalyInput
  }

  export type anomalyUncheckedCreateWithoutType_anomalyInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
  }

  export type anomalyCreateOrConnectWithoutType_anomalyInput = {
    where: anomalyWhereUniqueInput
    create: XOR<anomalyCreateWithoutType_anomalyInput, anomalyUncheckedCreateWithoutType_anomalyInput>
  }

  export type anomalyCreateManyType_anomalyInputEnvelope = {
    data: Enumerable<anomalyCreateManyType_anomalyInput>
    skipDuplicates?: boolean
  }

  export type anomalyUpsertWithWhereUniqueWithoutType_anomalyInput = {
    where: anomalyWhereUniqueInput
    update: XOR<anomalyUpdateWithoutType_anomalyInput, anomalyUncheckedUpdateWithoutType_anomalyInput>
    create: XOR<anomalyCreateWithoutType_anomalyInput, anomalyUncheckedCreateWithoutType_anomalyInput>
  }

  export type anomalyUpdateWithWhereUniqueWithoutType_anomalyInput = {
    where: anomalyWhereUniqueInput
    data: XOR<anomalyUpdateWithoutType_anomalyInput, anomalyUncheckedUpdateWithoutType_anomalyInput>
  }

  export type anomalyUpdateManyWithWhereWithoutType_anomalyInput = {
    where: anomalyScalarWhereInput
    data: XOR<anomalyUpdateManyMutationInput, anomalyUncheckedUpdateManyWithoutAnomalyInput>
  }

  export type anomalyCreateWithoutWayInput = {
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    report?: reportCreateNestedOneWithoutAnomalyInput
    type_anomaly?: type_anomalyCreateNestedOneWithoutAnomalyInput
  }

  export type anomalyUncheckedCreateWithoutWayInput = {
    id?: number
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyCreateOrConnectWithoutWayInput = {
    where: anomalyWhereUniqueInput
    create: XOR<anomalyCreateWithoutWayInput, anomalyUncheckedCreateWithoutWayInput>
  }

  export type anomalyCreateManyWayInputEnvelope = {
    data: Enumerable<anomalyCreateManyWayInput>
    skipDuplicates?: boolean
  }

  export type townCreateWithoutWayInput = {
    name: string
    postal_code: number
    circuit?: circuitCreateNestedOneWithoutTownInput
    worksite?: worksiteCreateNestedManyWithoutTownInput
  }

  export type townUncheckedCreateWithoutWayInput = {
    id?: number
    circuit_id?: number | null
    name: string
    postal_code: number
    worksite?: worksiteUncheckedCreateNestedManyWithoutTownInput
  }

  export type townCreateOrConnectWithoutWayInput = {
    where: townWhereUniqueInput
    create: XOR<townCreateWithoutWayInput, townUncheckedCreateWithoutWayInput>
  }

  export type anomalyUpsertWithWhereUniqueWithoutWayInput = {
    where: anomalyWhereUniqueInput
    update: XOR<anomalyUpdateWithoutWayInput, anomalyUncheckedUpdateWithoutWayInput>
    create: XOR<anomalyCreateWithoutWayInput, anomalyUncheckedCreateWithoutWayInput>
  }

  export type anomalyUpdateWithWhereUniqueWithoutWayInput = {
    where: anomalyWhereUniqueInput
    data: XOR<anomalyUpdateWithoutWayInput, anomalyUncheckedUpdateWithoutWayInput>
  }

  export type anomalyUpdateManyWithWhereWithoutWayInput = {
    where: anomalyScalarWhereInput
    data: XOR<anomalyUpdateManyMutationInput, anomalyUncheckedUpdateManyWithoutAnomalyInput>
  }

  export type townUpsertWithoutWayInput = {
    update: XOR<townUpdateWithoutWayInput, townUncheckedUpdateWithoutWayInput>
    create: XOR<townCreateWithoutWayInput, townUncheckedCreateWithoutWayInput>
  }

  export type townUpdateWithoutWayInput = {
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    circuit?: circuitUpdateOneWithoutTownNestedInput
    worksite?: worksiteUpdateManyWithoutTownNestedInput
  }

  export type townUncheckedUpdateWithoutWayInput = {
    id?: IntFieldUpdateOperationsInput | number
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    worksite?: worksiteUncheckedUpdateManyWithoutTownNestedInput
  }

  export type container_mouvementCreateWithoutWorksiteInput = {
    description: string
    tonnage: number
    date: Date | string
    container_type?: container_typeCreateNestedOneWithoutContainer_mouvementInput
    operation_type?: operation_typeCreateNestedOneWithoutContainer_mouvementInput
    driver?: driverCreateNestedOneWithoutContainer_mouvementInput
    truck?: truckCreateNestedOneWithoutContainer_mouvementInput
    flux?: fluxCreateNestedOneWithoutContainer_mouvementInput
    outlet?: outletCreateNestedOneWithoutContainer_mouvementInput
  }

  export type container_mouvementUncheckedCreateWithoutWorksiteInput = {
    id?: number
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementCreateOrConnectWithoutWorksiteInput = {
    where: container_mouvementWhereUniqueInput
    create: XOR<container_mouvementCreateWithoutWorksiteInput, container_mouvementUncheckedCreateWithoutWorksiteInput>
  }

  export type container_mouvementCreateManyWorksiteInputEnvelope = {
    data: Enumerable<container_mouvementCreateManyWorksiteInput>
    skipDuplicates?: boolean
  }

  export type townCreateWithoutWorksiteInput = {
    name: string
    postal_code: number
    circuit?: circuitCreateNestedOneWithoutTownInput
    way?: wayCreateNestedManyWithoutTownInput
  }

  export type townUncheckedCreateWithoutWorksiteInput = {
    id?: number
    circuit_id?: number | null
    name: string
    postal_code: number
    way?: wayUncheckedCreateNestedManyWithoutTownInput
  }

  export type townCreateOrConnectWithoutWorksiteInput = {
    where: townWhereUniqueInput
    create: XOR<townCreateWithoutWorksiteInput, townUncheckedCreateWithoutWorksiteInput>
  }

  export type container_mouvementUpsertWithWhereUniqueWithoutWorksiteInput = {
    where: container_mouvementWhereUniqueInput
    update: XOR<container_mouvementUpdateWithoutWorksiteInput, container_mouvementUncheckedUpdateWithoutWorksiteInput>
    create: XOR<container_mouvementCreateWithoutWorksiteInput, container_mouvementUncheckedCreateWithoutWorksiteInput>
  }

  export type container_mouvementUpdateWithWhereUniqueWithoutWorksiteInput = {
    where: container_mouvementWhereUniqueInput
    data: XOR<container_mouvementUpdateWithoutWorksiteInput, container_mouvementUncheckedUpdateWithoutWorksiteInput>
  }

  export type container_mouvementUpdateManyWithWhereWithoutWorksiteInput = {
    where: container_mouvementScalarWhereInput
    data: XOR<container_mouvementUpdateManyMutationInput, container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput>
  }

  export type townUpsertWithoutWorksiteInput = {
    update: XOR<townUpdateWithoutWorksiteInput, townUncheckedUpdateWithoutWorksiteInput>
    create: XOR<townCreateWithoutWorksiteInput, townUncheckedCreateWithoutWorksiteInput>
  }

  export type townUpdateWithoutWorksiteInput = {
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    circuit?: circuitUpdateOneWithoutTownNestedInput
    way?: wayUpdateManyWithoutTownNestedInput
  }

  export type townUncheckedUpdateWithoutWorksiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    way?: wayUncheckedUpdateManyWithoutTownNestedInput
  }

  export type fluxCreateManyCircuitInput = {
    id?: number
    name: string
  }

  export type reportCreateManyCircuitInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type townCreateManyCircuitInput = {
    id?: number
    name: string
    postal_code: number
  }

  export type fluxUpdateWithoutCircuitInput = {
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUpdateManyWithoutFluxNestedInput
    report?: reportUpdateManyWithoutFluxNestedInput
    team?: teamUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateWithoutCircuitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutFluxNestedInput
    report?: reportUncheckedUpdateManyWithoutFluxNestedInput
    team?: teamUncheckedUpdateManyWithoutFluxNestedInput
  }

  export type fluxUncheckedUpdateManyWithoutFluxInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type reportUpdateWithoutCircuitInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutCircuitInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type townUpdateWithoutCircuitInput = {
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    way?: wayUpdateManyWithoutTownNestedInput
    worksite?: worksiteUpdateManyWithoutTownNestedInput
  }

  export type townUncheckedUpdateWithoutCircuitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
    way?: wayUncheckedUpdateManyWithoutTownNestedInput
    worksite?: worksiteUncheckedUpdateManyWithoutTownNestedInput
  }

  export type townUncheckedUpdateManyWithoutTownInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    postal_code?: IntFieldUpdateOperationsInput | number
  }

  export type collecte_observationCreateManyCollecteInput = {
    id?: number
    description: string
  }

  export type reportCreateManyCollecteInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type collecte_observationUpdateWithoutCollecteInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type collecte_observationUncheckedUpdateWithoutCollecteInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type collecte_observationUncheckedUpdateManyWithoutCollecte_observationInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type reportUpdateWithoutCollecteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutCollecteInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type container_mouvementCreateManyContainer_typeInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementUpdateWithoutContainer_typeInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutContainer_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type container_mouvementUncheckedUpdateManyWithoutContainer_mouvementInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type container_mouvementCreateManyDriverInput = {
    id?: number
    worksite_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type replacement_teamCreateManyDriverInput = {
    id?: number
    substitute_ripper1_id?: number | null
    substitute_ripper2_id?: number | null
  }

  export type sinisterCreateManyDriverInput = {
    id?: number
    truck_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type container_mouvementUpdateWithoutDriverInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type replacement_teamUpdateWithoutDriverInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperNestedInput
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperNestedInput
    team?: teamUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    team?: teamUncheckedUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateManyWithoutReplacement_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sinisterUpdateWithoutDriverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    truck?: truckUpdateOneWithoutSinisterNestedInput
  }

  export type sinisterUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sinisterUncheckedUpdateManyWithoutSinisterInput = {
    id?: IntFieldUpdateOperationsInput | number
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type container_mouvementCreateManyFluxInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type reportCreateManyFluxInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type teamCreateManyFluxInput = {
    id?: number
    driver_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    truck_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type container_mouvementUpdateWithoutFluxInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutFluxInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportUpdateWithoutFluxInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutFluxInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type teamUpdateWithoutFluxInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    truck?: truckUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutFluxInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type container_mouvementCreateManyOperation_typeInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementUpdateWithoutOperation_typeInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutOperation_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type circuitCreateManyOutletInput = {
    id?: number
    name: string
  }

  export type container_mouvementCreateManyOutletInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type reportCreateManyOutlet_report_visited_outlet4_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_visited_outlet2_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_default_outlet_idTooutletInput = {
    id?: number
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_default_outlet3_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_visited_outlet3_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_visited_outlet_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_default_outlet2_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type reportCreateManyOutlet_report_default_outlet4_idTooutletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type circuitUpdateWithoutOutletInput = {
    name?: StringFieldUpdateOperationsInput | string
    flux?: fluxUpdateManyWithoutCircuitNestedInput
    report?: reportUpdateManyWithoutCircuitNestedInput
    town?: townUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateWithoutOutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    flux?: fluxUncheckedUpdateManyWithoutCircuitNestedInput
    report?: reportUncheckedUpdateManyWithoutCircuitNestedInput
    town?: townUncheckedUpdateManyWithoutCircuitNestedInput
  }

  export type circuitUncheckedUpdateManyWithoutCircuitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type container_mouvementUpdateWithoutOutletInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutOutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_visited_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_visited_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_visited_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_visited_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_default_outlet_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_default_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_default_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_default_outlet3_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_default_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_default_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_visited_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_visited_outlet3_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_visited_outlet_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_visited_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_visited_outlet_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_default_outlet2_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_default_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_default_outlet2_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportUpdateWithoutOutlet_report_default_outlet4_idTooutletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutOutlet_report_default_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportUncheckedUpdateManyWithoutReport_report_default_outlet4_idTooutletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type anomalyCreateManyReportInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyUpdateWithoutReportInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    way?: wayUpdateOneWithoutAnomalyNestedInput
    type_anomaly?: type_anomalyUpdateOneWithoutAnomalyNestedInput
  }

  export type anomalyUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    way_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    type_anomaly_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type anomalyUncheckedUpdateManyWithoutAnomalyInput = {
    id?: IntFieldUpdateOperationsInput | number
    way_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    type_anomaly_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type replacement_teamCreateManyRipper_replacement_team_substitute_ripper2_idToripperInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper1_id?: number | null
  }

  export type replacement_teamCreateManyRipper_replacement_team_substitute_ripper1_idToripperInput = {
    id?: number
    substitute_driver_id?: number | null
    substitute_ripper2_id?: number | null
  }

  export type replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    ripper_replacement_team_substitute_ripper1_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperNestedInput
    driver?: driverUpdateOneWithoutReplacement_teamNestedInput
    team?: teamUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper2_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    team?: teamUncheckedUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateManyWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type replacement_teamUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    ripper_replacement_team_substitute_ripper2_idToripper?: ripperUpdateOneWithoutReplacement_team_replacement_team_substitute_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutReplacement_teamNestedInput
    team?: teamUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateWithoutRipper_replacement_team_substitute_ripper1_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    team?: teamUncheckedUpdateOneWithoutReplacement_teamNestedInput
  }

  export type replacement_teamUncheckedUpdateManyWithoutReplacement_team_replacement_team_substitute_ripper1_idToripperInput = {
    id?: IntFieldUpdateOperationsInput | number
    substitute_driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    substitute_ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type reportCreateManyTabletInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    truck_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
  }

  export type reportUpdateWithoutTabletInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    truck?: truckUpdateOneWithoutReportNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
  }

  export type reportUncheckedUpdateWithoutTabletInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type wayCreateManyTownInput = {
    id?: number
    name: string
    type?: string | null
  }

  export type worksiteCreateManyTownInput = {
    id?: number
    name: string
    adress?: string | null
  }

  export type wayUpdateWithoutTownInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutWayNestedInput
  }

  export type wayUncheckedUpdateWithoutTownInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUncheckedUpdateManyWithoutWayNestedInput
  }

  export type wayUncheckedUpdateManyWithoutWayInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type worksiteUpdateWithoutTownInput = {
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUpdateManyWithoutWorksiteNestedInput
  }

  export type worksiteUncheckedUpdateWithoutTownInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
    container_mouvement?: container_mouvementUncheckedUpdateManyWithoutWorksiteNestedInput
  }

  export type worksiteUncheckedUpdateManyWithoutWorksiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    adress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type container_mouvementCreateManyTruckInput = {
    id?: number
    worksite_id?: number | null
    driver_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type reportCreateManyTruckInput = {
    id?: number
    default_outlet_id?: number | null
    visited_outlet_id?: number | null
    flux_id?: number | null
    date: Date | string
    manual_circuit?: string | null
    total_bac_collected: number
    total_bac_rejected: number
    tonnage?: number | null
    tonnage2?: number | null
    default_outlet2_id?: number | null
    visited_outlet2_id?: number | null
    default_outlet3_id?: number | null
    visited_outlet3_id?: number | null
    default_outlet4_id?: number | null
    visited_outlet4_id?: number | null
    tonnage3?: number | null
    tonnage4?: number | null
    circuit_id?: number | null
    collecte_id?: number | null
    observation?: string | null
    geoloc_id?: number | null
  }

  export type sinisterCreateManyTruckInput = {
    id?: number
    driver_id?: number | null
    date: Date | string
    place: string
    opposing_vehicule?: string | null
    opposing_driver?: string | null
    circumstance?: string | null
    status: string
    observation?: string | null
  }

  export type teamCreateManyTruckInput = {
    id?: number
    driver_id?: number | null
    flux_id?: number | null
    ripper1_id?: number | null
    ripper2_id?: number | null
    replacement_team_id?: number | null
    name: string
    manual_circuit?: string | null
    manual_tablet?: string | null
  }

  export type container_mouvementUpdateWithoutTruckInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    worksite?: worksiteUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutTruckInput = {
    id?: IntFieldUpdateOperationsInput | number
    worksite_id?: NullableIntFieldUpdateOperationsInput | number | null
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportUpdateWithoutTruckInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    anomaly?: anomalyUpdateManyWithoutReportNestedInput
    outlet_report_visited_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet4_idTooutletNestedInput
    outlet_report_visited_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet2_idTooutletNestedInput
    outlet_report_default_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet_idTooutletNestedInput
    collecte?: collecteUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet3_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet3_idTooutletNestedInput
    outlet_report_visited_outlet_idTooutlet?: outletUpdateOneWithoutReport_report_visited_outlet_idTooutletNestedInput
    outlet_report_default_outlet2_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet2_idTooutletNestedInput
    flux?: fluxUpdateOneWithoutReportNestedInput
    circuit?: circuitUpdateOneWithoutReportNestedInput
    outlet_report_default_outlet4_idTooutlet?: outletUpdateOneWithoutReport_report_default_outlet4_idTooutletNestedInput
    tablet?: tabletUpdateOneWithoutReportNestedInput
  }

  export type reportUncheckedUpdateWithoutTruckInput = {
    id?: IntFieldUpdateOperationsInput | number
    default_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    total_bac_collected?: IntFieldUpdateOperationsInput | number
    total_bac_rejected?: IntFieldUpdateOperationsInput | number
    tonnage?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage2?: NullableFloatFieldUpdateOperationsInput | number | null
    default_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet2_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet3_id?: NullableIntFieldUpdateOperationsInput | number | null
    default_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    visited_outlet4_id?: NullableIntFieldUpdateOperationsInput | number | null
    tonnage3?: NullableFloatFieldUpdateOperationsInput | number | null
    tonnage4?: NullableFloatFieldUpdateOperationsInput | number | null
    circuit_id?: NullableIntFieldUpdateOperationsInput | number | null
    collecte_id?: NullableIntFieldUpdateOperationsInput | number | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    geoloc_id?: NullableIntFieldUpdateOperationsInput | number | null
    anomaly?: anomalyUncheckedUpdateManyWithoutReportNestedInput
  }

  export type sinisterUpdateWithoutTruckInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    driver?: driverUpdateOneWithoutSinisterNestedInput
  }

  export type sinisterUncheckedUpdateWithoutTruckInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: StringFieldUpdateOperationsInput | string
    opposing_vehicule?: NullableStringFieldUpdateOperationsInput | string | null
    opposing_driver?: NullableStringFieldUpdateOperationsInput | string | null
    circumstance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    observation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUpdateWithoutTruckInput = {
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
    ripper_team_ripper1_idToripper?: ripperUpdateOneWithoutTeam_team_ripper1_idToripperNestedInput
    ripper_team_ripper2_idToripper?: ripperUpdateOneWithoutTeam_team_ripper2_idToripperNestedInput
    driver?: driverUpdateOneWithoutTeamNestedInput
    flux?: fluxUpdateOneWithoutTeamNestedInput
    replacement_team?: replacement_teamUpdateOneWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTruckInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper1_id?: NullableIntFieldUpdateOperationsInput | number | null
    ripper2_id?: NullableIntFieldUpdateOperationsInput | number | null
    replacement_team_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    manual_circuit?: NullableStringFieldUpdateOperationsInput | string | null
    manual_tablet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type anomalyCreateManyType_anomalyInput = {
    id?: number
    way_id?: number | null
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
  }

  export type anomalyUpdateWithoutType_anomalyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportUpdateOneWithoutAnomalyNestedInput
    way?: wayUpdateOneWithoutAnomalyNestedInput
  }

  export type anomalyUncheckedUpdateWithoutType_anomalyInput = {
    id?: IntFieldUpdateOperationsInput | number
    way_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    report_id?: NullableIntFieldUpdateOperationsInput | number | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type anomalyCreateManyWayInput = {
    id?: number
    date: Date | string
    type?: string | null
    is_collected: string
    regularization_date?: Date | string | null
    description?: string | null
    report_id?: number | null
    manual_town?: string | null
    manual_way?: string | null
    manual_flux?: string | null
    manual_truck?: string | null
    type_anomaly_id?: number | null
  }

  export type anomalyUpdateWithoutWayInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportUpdateOneWithoutAnomalyNestedInput
    type_anomaly?: type_anomalyUpdateOneWithoutAnomalyNestedInput
  }

  export type anomalyUncheckedUpdateWithoutWayInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_collected?: StringFieldUpdateOperationsInput | string
    regularization_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    report_id?: NullableIntFieldUpdateOperationsInput | number | null
    manual_town?: NullableStringFieldUpdateOperationsInput | string | null
    manual_way?: NullableStringFieldUpdateOperationsInput | string | null
    manual_flux?: NullableStringFieldUpdateOperationsInput | string | null
    manual_truck?: NullableStringFieldUpdateOperationsInput | string | null
    type_anomaly_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type container_mouvementCreateManyWorksiteInput = {
    id?: number
    driver_id?: number | null
    truck_id?: number | null
    flux_id?: number | null
    outlet_id?: number | null
    description: string
    tonnage: number
    operation_type_id?: number | null
    container_type_id?: number | null
    date: Date | string
  }

  export type container_mouvementUpdateWithoutWorksiteInput = {
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    container_type?: container_typeUpdateOneWithoutContainer_mouvementNestedInput
    operation_type?: operation_typeUpdateOneWithoutContainer_mouvementNestedInput
    driver?: driverUpdateOneWithoutContainer_mouvementNestedInput
    truck?: truckUpdateOneWithoutContainer_mouvementNestedInput
    flux?: fluxUpdateOneWithoutContainer_mouvementNestedInput
    outlet?: outletUpdateOneWithoutContainer_mouvementNestedInput
  }

  export type container_mouvementUncheckedUpdateWithoutWorksiteInput = {
    id?: IntFieldUpdateOperationsInput | number
    driver_id?: NullableIntFieldUpdateOperationsInput | number | null
    truck_id?: NullableIntFieldUpdateOperationsInput | number | null
    flux_id?: NullableIntFieldUpdateOperationsInput | number | null
    outlet_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    tonnage?: FloatFieldUpdateOperationsInput | number
    operation_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    container_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}